#!/usr/bin/env perl
use strict;
use warnings;
use lib $ENV{'GALACTICUS_EXEC_PATH'}."/perl";
use Galacticus::Options;
use Data::Dumper;

# Analzye debugging output generated by the "GALACTICUS_OBJECTS_DEBUG=yes" compile option. This output lists every "own" and
# "disown" of a pointer to a functionClass object. Each own should have a matching disown (and vice-versa). This script checks for
# this matching and outputs a summary of cases where no match can be found.
# Andrew Benson (04-February-2019)

# Get arguments.
die("Usage: functionClassReferenceDebug.pl <logFile>")
    unless ( scalar(@ARGV) >= 1 );
my $logFileName  = $ARGV[0];
my %options = 
    (
     thread => "all" # Match all threads by default.
    );
&Galacticus::Options::Parse_Options(\@ARGV,\%options);

# Parse the log file and extract all own/disown actions.
my $count = {own => 0, disown => 0};
my $actions;
open(my $log,$logFileName);
while ( my $line = <$log> ) {
    if ( $line =~ m/^([M\s\d:]+):\s+functionClass\[(own|disown)\]\s+\([^\)]+\): (.*)$/) {
	my $thread = $1;
	my $state  = $2;
	my $data   = $3;
	$data =~ s/^\s*//;
	$data =~ s/\s*$//;
	my @columns = split(/\s+:\s+/,$data);
	my $class     = $columns[0];
	my $ownerName = $columns[1];
	my $ownerLoc  = $columns[2];
	my $objectLoc = $columns[3];
	my $sourceLoc = $columns[4];
	# Master thread is equivalent to thread 0.
	$thread =~ s/(M+)/(" " x (length($1)-1))."0"/e;
	# Check for thread match.
	if ( $options{'thread'} eq "all" || $options{'thread'} eq $thread ) {
	    # Store the action.
	    push(
		@{$actions->{$objectLoc}->{$state}->{$ownerLoc}},
		{
		    thread    => $thread   ,
		    class     => $class    ,
		    ownerName => $ownerName,
		    sourceLoc => $sourceLoc
		}
		);
	    ++$count->{$state};
	}
    }
}
close($log);

# Give total counts of owns and disowns.
print "Counts (prior to matching):\n";
print "     own = ".$count->{   'own'}."\n"  ;
print "  disown = ".$count->{'disown'}."\n\n";

# Scan owns.
foreach my $object ( keys(%{$actions}) ) {
    foreach my $owner ( keys(%{$actions->{$object}->{'own'}}) ) {
	# Search for a matching disown.
	my $matchedDisowner = 0;
	foreach my $disowner ( keys(%{$actions->{$object}->{'disown'}}) ) {
	    if ( $disowner eq $owner ) {
		$matchedDisowner = 1;
		# Owner and disowner names match - look for matches.
		foreach my $own ( @{$actions->{$object}->{'own'}->{$owner}} ) {
		    next
			unless ( defined($own) );
		    my $matched = 0;
		    foreach my $disown ( @{$actions->{$object}->{'disown'}->{$owner}} ) {
			next
			    unless ( defined($disown) && ! $matched );
			# Require a match by thread unless we have an owner object loc.
			if ( $own->{'thread'} eq $disown->{'thread'} || $owner =~ m/^\d/ ) {
			    $matched = 1;
			    undef($disown);
			    --$count->{'disown'};
			}
		    }
		    if ( $matched ) {
			# A match was found, so we can remove the owner (we've already removed the disowner).
			undef($own);
			--$count->{'own'};
		    } else {
			print "Own lacks matching disown:\n";
			print "   Object: ".$object               ."\n"  ;
			print "    Owner: ".$owner                ."\n"  ;
			print "   Thread: ".$own   ->{'thread'   }."\n"  ;
			print "    Class: ".$own   ->{'class'    }."\n"  ;
			print "   Source: ".$own   ->{'sourceLoc'}."\n\n";
		    }
		}
	    }
	}
	if ( ! $matchedDisowner ) {
	    # No matching disowner was found.
	    foreach my $own ( @{$actions->{$object}->{'own'}->{$owner}} ) {
		next
		    unless ( defined($own) );
		print "Own lacks matching disown:\n";
		print "   Object: ".$object               ."\n"  ;
		print "    Owner: ".$owner                ."\n"  ;
		print "   Thread: ".$own   ->{'thread'   }."\n"  ;
		print "    Class: ".$own   ->{'class'    }."\n"  ;
		print "   Source: ".$own   ->{'sourceLoc'}."\n\n";
	    }
	}
    }
}

# Scan disowns.
foreach my $object ( keys(%{$actions}) ) {
    foreach my $disowner ( keys(%{$actions->{$object}->{'disown'}}) ) {
	# Search for a matching own.
	my $matchedOwner = 0;
	foreach my $owner ( keys(%{$actions->{$object}->{'own'}}) ) {
	    if ( $owner eq $disowner ) {
		$matchedOwner = 1;
		# Disowner and owner names match - look for matches.
		foreach my $disown ( @{$actions->{$object}->{'disown'}->{$disowner}} ) {
		    next
			unless ( defined($disown) );
		    my $matched = 0;
		    foreach my $own ( @{$actions->{$object}->{'own'}->{$disowner}} ) {
			next
			    unless ( defined($own) && ! $matched );
			# Require a match by thread unless we have an owner object loc.
			if ( $disown->{'thread'} eq $own->{'thread'} || $owner =~ m/^\d/ ) {
			    $matched = 1;
			    undef($own);
			    --$count->{'own'};
			}
		    }
		    if ( $matched ) {
			# A match was found, so we can remove the disowner (we've already removed the owner).
			undef($disown);
			    --$count->{'disown'};
		    } else {
			print "Disown lacks matching own:\n";
			print "     Object: ".$object                  ."\n"  ;
			print "   Disowner: ".$disowner                ."\n"  ;
			print "     Thread: ".$disown   ->{'thread'   }."\n"  ;
			print "      Class: ".$disown   ->{'class'    }."\n"  ;
			print "     Source: ".$disown   ->{'sourceLoc'}."\n\n";
		    }
		}
	    }
	}
	if ( ! $matchedOwner ) {
	    # No matching owner was found.
	    foreach my $disown ( @{$actions->{$object}->{'disown'}->{$disowner}} ) {
		next
		    unless ( defined($disown) );
		print "Disown lacks matching own:\n";
		print "     Object: ".$object                  ."\n"  ;
		print "   Disowner: ".$disowner                ."\n"  ;
		print "     Thread: ".$disown   ->{'thread'   }."\n"  ;
		print "      Class: ".$disown   ->{'class'    }."\n"  ;
		print "     Source: ".$disown   ->{'sourceLoc'}."\n\n";
	    }
	}
    }
}

# Give total counts of owns and disowns.
print "Counts (after matching):\n";
print "     own = ".$count->{   'own'}."\n"  ;
print "  disown = ".$count->{'disown'}."\n\n";

exit 0;
