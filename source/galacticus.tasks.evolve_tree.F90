!! Copyright 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017
!!    Andrew Benson <abenson@carnegiescience.edu>
!!
!! This file is part of Galacticus.
!!
!!    Galacticus is free software: you can redistribute it and/or modify
!!    it under the terms of the GNU General Public License as published by
!!    the Free Software Foundation, either version 3 of the License, or
!!    (at your option) any later version.
!!
!!    Galacticus is distributed in the hope that it will be useful,
!!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!!    GNU General Public License for more details.
!!
!!    You should have received a copy of the GNU General Public License
!!    along with Galacticus.  If not, see <http://www.gnu.org/licenses/>.

!% Contains a module which implements the task of evolving merger trees.

module Galacticus_Tasks_Evolve_Tree
  !% Implements the task of evolving merger trees.
  use ISO_Varying_String
  use Galacticus_Nodes
  implicit none
  private
  public :: Galacticus_Task_Evolve_Tree

  ! Flag to indicate if output times have been initialized.
  logical                          :: treeEvolveInitialized       =.false.

  ! Parameters controlling which trees will be processed.
  integer                          :: treeEvolveWorkerCount               , treeEvolveWorkerNumber

  ! Parameters controlling load averaging and thread locking.
  logical                          :: treeEvolveLimitLoadAverage          , treeEvolveThreadLock
  double precision                 :: treeEvolveLoadAverageMaximum
  integer                          :: treeEvolveThreadsMaximum
  type            (varying_string) :: treeEvolveThreadLockName

  ! Tree universes used while processing all trees.
  type            (universe      ) :: universeWaiting                     , universeProcessed

  ! Parameters controlling tree suspension.
  logical                          :: treeEvolveSuspendToRAM
  type            (varying_string) :: treeEvolveSuspendPath

  ! Object used to build lists of tree branches which get processed independently.
  type :: branchList
     type(treeNode  ), pointer :: nodeParent
     type(mergerTree), pointer :: branch
     type(branchList), pointer :: next
  end type branchList
  
contains

  !# <galacticusTask>
  !#  <unitName>Galacticus_Task_Evolve_Tree</unitName>
  !#  <after>Galacticus_Task_Start</after>
  !#  <before>Galacticus_Task_End</before>
  !# </galacticusTask>
  logical function Galacticus_Task_Evolve_Tree()
    !% Evolves the complete set of merger trees as specified.
    use, intrinsic :: ISO_C_Binding
    use String_Handling
    use Merger_Tree_Operators
    use Merger_Trees_Evolve
    use Galacticus_Output_Merger_Tree
    use Galacticus_Display
    use Node_Components
    use Input_Parameters
    use Galacticus_Output_Times
    use Galacticus_Error
    use Memory_Management
    use System_Load
    use Semaphores
    use Node_Events_Inter_Tree
    use Sort
    !$ use omp_lib
    ! Include modules needed for pre- and post-evolution and pre-construction tasks.
    !# <include directive="mergerTreePreEvolveTask" type="moduleUse">
    include 'galacticus.tasks.evolve_tree.preEvolveTask.moduleUse.inc'
    !# </include>
    !# <include directive="mergerTreePostEvolveTask" type="moduleUse">
    include 'galacticus.tasks.evolve_tree.postEvolveTask.moduleUse.inc'
    !# </include>
    !# <include directive="universePreEvolveTask" type="moduleUse" functionType="void">
    include 'galacticus.tasks.evolve_tree.universePreEvolveTask.moduleUse.inc'
    !# </include>
    !# <include directive="universePostEvolveTask" type="moduleUse" functionType="void">
    include 'galacticus.tasks.evolve_tree.universePostEvolveTask.moduleUse.inc'
    !# </include>
    implicit none
    type            (mergerTree             ), pointer                  , save :: thisTree
    logical                                                             , save :: finished                                  , skipTree                    , &
         &                                                                        treeIsNew
    integer         (c_size_t               )                           , save :: iOutput
    double precision                                                    , save :: evolveToTime                              , treeTimeEarliest            , &
         &                                                                        universalEvolveToTime                     , treeTimeLatest              , &
         &                                                                        outputTimeNext
    type            (varying_string         )                           , save :: message
    character       (len=20                 )                           , save :: label
    !$omp threadprivate(thisTree,finished,skipTree,iOutput,evolveToTime,message,label,treeIsNew,treeTimeEarliest,universalEvolveToTime,outputTimeNext)
    integer                                                                    :: iTree                                     , treeCount
    integer                                                             , save :: activeTasks                               , totalTasks
    double precision                                      , dimension(3), save :: loadAverage
    logical                                                             , save :: overloaded                                , deadlockReport              , &
         &                                                                        treeIsFinished                            , evolutionIsEventLimited     , &
         &                                                                        success                                   , removeTree                  , &
         &                                                                        suspendTree                               , treesDidEvolve              , &
         &                                                                        treeDidEvolve
    type            (mergerTree             ), pointer                  , save :: currentTree                               , previousTree                , &
         &                                                                        nextTree
    !$omp threadprivate(currentTree,previousTree)
    type            (treeNode               ), pointer                  , save :: satelliteNode
    class           (nodeComponentBasic     ), pointer                  , save :: baseNodeBasic
    !$omp threadprivate(satelliteNode,baseNodeBasic)
    class           (mergerTreeOperatorClass), pointer                  , save :: mergerTreeOperator_              => null()
    !$omp threadprivate(mergerTreeOperator_)
    type            (semaphore              ), pointer                         :: galacticusMutex                  => null()
    type            (varying_string         )                                  :: treeEvolveLoadAverageMaximumText          , treeEvolveThreadsMaximumText
    character       (len=32                 )                                  :: text
    !$omp threadprivate(activeTasks,totalTasks,loadAverage,overloaded,treeIsFinished,evolutionIsEventLimited,success,removeTree,suspendTree)
    type            (universeEvent          ), pointer                  , save :: thisEvent
    !$omp threadprivate(thisEvent)
    ! Variables used in processing individual forests in parallel.
    double precision                                                    , save :: timeBranchSplit
    type            (treeNode               ), pointer                  , save :: node
    class           (nodeComponentBasic     ), pointer                  , save :: basic                                      , basicParent
    type            (branchList             ), pointer                  , save :: branchList_                                , branchNew                  , &
         &                                                                        branchNext
    logical                                                             , save :: branchAccept
    integer         (c_size_t               )                           , save :: iBranch                                    , i                          , &
         &                                                                        countBranch
    integer         (c_size_t               ), allocatable, dimension(:), save :: rankBranch
    double precision                         , allocatable, dimension(:), save :: massBranch
    integer                                                             , save :: forestSection
    double precision                                                    , save :: timeSectionForestBegin
    logical                                                                    :: treeEvolveSingleForest
    integer         (c_size_t               )                                  :: iBranchAcceptedLast
    integer                                                                    :: treeEvolveSingleForestSections
    !$omp threadprivate(node,basic,basicParent,timeBranchSplit,branchList_,branchNew,branchNext,i,iBranch,branchAccept,rankBranch,countBranch,massBranch,timeSectionForestBegin,forestSection)

    ! Initialize the task if necessary.
    if (.not.treeEvolveInitialized) then
       !$omp critical (Tasks_Evolve_Tree_Initialize)

       if (.not.treeEvolveInitialized) then

          ! Get parameters controlling which trees will be processed.
          !# <inputParameter>
          !#   <name>treeEvolveSingleForest</name>
          !#   <cardinality>1</cardinality>
          !#   <defaultValue>.false.</defaultValue>
          !#   <description>If true then each forest is processed sequentially, with multiple parallel threads (if available) working on the same forest. If false, multiple forests are processed simultaneously, with a single parallel thread (if available) working on each.</description>
          !#   <source>globalParameters</source>
          !#   <type>integer</type>
          !# </inputParameter>
          !# <inputParameter>
          !#   <name>treeEvolveSingleForestSections</name>
          !#   <cardinality>1</cardinality>
          !#   <defaultValue>100</defaultValue>
          !#   <description>The number of timesteps into which forests should be split when processing single forests in parallel.</description>
          !#   <source>globalParameters</source>
          !#   <type>integer</type>
          !# </inputParameter>
          !# <inputParameter>
          !#   <name>treeEvolveWorkerCount</name>
          !#   <cardinality>1</cardinality>
          !#   <defaultValue>1</defaultValue>
          !#   <description>The number of workers that will work on this calculation.</description>
          !#   <source>globalParameters</source>
          !#   <type>integer</type>
          !# </inputParameter>
          !# <inputParameter>
          !#   <name>treeEvolveWorkerNumber</name>
          !#   <cardinality>1</cardinality>
          !#   <defaultValue>1</defaultValue>
          !#   <description>The number of this worker.</description>
          !#   <source>globalParameters</source>
          !#   <type>integer</type>
          !# </inputParameter>
          !# <inputParameter>
          !#   <name>treeEvolveLimitLoadAverage</name>
          !#   <cardinality>1</cardinality>
          !#   <defaultValue>.false.</defaultValue>
          !#   <description>Specifies whether or not to limit the load average</description>
          !#   <source>globalParameters</source>
          !#   <type>boolean</type>
          !# </inputParameter>
          !# <inputParameter>
          !#   <name>treeEvolveLoadAverageMaximum</name>
          !#   <cardinality>1</cardinality>
          !#   <defaultValue>var_str('processorCount')</defaultValue>
          !#   <description>The maximum load average for which new trees will be processed.</description>
          !#   <source>globalParameters</source>
          !#   <type>boolean</type>
          !#   <variable>treeEvolveLoadAverageMaximumText</variable>
          !# </inputParameter>
          if (treeEvolveLoadAverageMaximumText == "processorCount" ) then
             treeEvolveLoadAverageMaximum=dble(System_Processor_Count())
          else
             text=char(treeEvolveLoadAverageMaximumText)
             read (text,*) treeEvolveLoadAverageMaximum
          end if
          !# <inputParameter>
          !#   <name>treeEvolveThreadLock</name>
          !#   <cardinality>1</cardinality>
          !#   <defaultValue>.false.</defaultValue>
          !#   <description>Specifies whether or not to limit the number of threads across all \glc\ processes.</description>
          !#   <source>globalParameters</source>
          !#   <type>boolean</type>
          !# </inputParameter>
          !# <inputParameter>
          !#   <name>treeEvolveThreadsMaximum</name>
          !#   <cardinality>1</cardinality>
          !#   <defaultValue>var_str('processorCount')</defaultValue>
          !#   <description>The maximum number of active threads across all \glc\ processes.</description>
          !#   <source>globalParameters</source>
          !#   <type>string</type>
          !#   <variable>treeEvolveThreadsMaximumText</variable>
          !# </inputParameter>
          if (treeEvolveThreadsMaximumText == "processorCount") then
             treeEvolveThreadsMaximum=System_Processor_Count()
          else
             text=char(treeEvolveThreadsMaximumText)
             read (text,*) treeEvolveThreadsMaximum
          end if
          !# <inputParameter>
          !#   <name>treeEvolveThreadLockName</name>
          !#   <cardinality>1</cardinality>
          !#   <defaultValue>var_str('galacticus')</defaultValue>
          !#   <description>The name to use for the semaphore used to lock threads across all \glc\ processes.</description>
          !#   <source>globalParameters</source>
          !#   <type>string</type>
          !# </inputParameter>
          !# <inputParameter>
          !#   <name>treeEvolveSuspendToRAM</name>
          !#   <cardinality>1</cardinality>
          !#   <defaultValue>.true.</defaultValue>
          !#   <description>Specifies whether trees should be suspended to RAM (otherwise they are suspend to file).</description>
          !#   <source>globalParameters</source>
          !#   <type>boolean</type>
          !# </inputParameter>
          if (.not.treeEvolveSuspendToRAM) then
             !# <inputParameter>
             !#   <name>treeEvolveSuspendPath</name>
             !#   <cardinality>1</cardinality>
             !#   <description>The path to which tree suspension files will be stored.</description>
             !#   <source>globalParameters</source>
             !#   <type>string</type>
             !# </inputParameter>
          end if
          ! Flag that this task is now initialized.
          treeEvolveInitialized=.true.
       end if
       !$omp end critical (Tasks_Evolve_Tree_Initialize)
    end if

    ! Ensure the nodes objects are initialized.
    call nodeClassHierarchyInitialize()
    call Node_Components_Initialize ()

    ! The following processes merger trees, one at a time, to each successive output time, then dumps their contents to file. It
    ! allows for the possibility of "universal events" - events which require all merger trees to reach the same cosmic time. If
    ! such an event exists, each tree is processed up to that time and then pushed onto a stack where it waits to be
    ! processed. Once all trees reach the event time the stack of trees is passed to the event task. Tree processing then
    ! continues by popping trees off of the stack and processing them further (possibly to the next universal event).

    ! Allow events to be attached to the universe.
    universeWaiting%event => null()
    !# <include directive="universePreEvolveTask" type="functionCall" functionType="void">
    !#  <functionArgs>universeWaiting</functionArgs>
    include 'galacticus.tasks.evolve_tree.universePreEvolveTask.inc'
    !# </include>

    ! Initialize tree counter and record that we are not finished processing trees.
    deadlockReport=.false.
    finished      =.false.
    iTree         =0

    ! Create a semaphore if threads are being locked.
    if (treeEvolveThreadLock) galacticusMutex => Semaphore_Open("/"//char(treeEvolveThreadLockName),treeEvolveThreadsMaximum)
    
    ! Initialize universes which will act as tree stacks. We use two stacks: one for trees waiting to be processed, one for trees
    ! that have already been processed.
    universeWaiting  %trees => null()
    universeProcessed%trees => null()

    ! Set record of whether any trees were evolved to false initially.
    treesDidEvolve=.false.
    
    ! Begin parallel processing of trees until all work is done.
    !$omp parallel copyin(finished) if (.not.treeEvolveSingleForest)
    do while (.not.finished)       
       ! Get required objects.
       if (.not.associated(mergerTreeOperator_)) mergerTreeOperator_ => mergerTreeOperator()
       
       ! If locking threads, claim one.
       if (treeEvolveThreadLock) call galacticusMutex%wait()
       
       ! Attempt to get a new tree to process. We first try to get a new tree. If no new trees exist, we will look for a tree on
       ! the stack waiting to be processed.
       if (treeEvolveWorkerCount == 1) then
          call Get_Tree(iTree,skipTree,thisTree,finished)
       else
          !$omp critical(Tree_Sharing)
          call Get_Tree(iTree,skipTree,thisTree,finished)
          !$omp end critical(Tree_Sharing)
       end if
       treeIsNew=.not.finished
       ! If no new tree was available, attempt to pop one off the universe stack.
       if (finished) then
          call treeResume(thisTree)
          skipTree =.false.
          treeIsNew=.false.
          finished =.not.associated(thisTree)
       end if
       ! If we got a tree (i.e. we are not "finished") process it.
       if (.not.finished) then
          treeIsFinished=.false.

          ! Skip this tree if necessary.
          if (.not.skipTree) then

             ! Spin while the system is overloaded.
             overloaded=treeEvolveLimitLoadAverage
             do while (overloaded)
                ! Get the load average.
                call System_Load_Get(loadAverage,activeTasks,totalTasks)
                ! If load is above allowed tolerances, sleep for a while.
                overloaded=(loadAverage(1) > treeEvolveLoadAverageMaximum)
                if (overloaded)                         &
                     & call Sleep( 5                    &
                     !$ &         +omp_get_thread_num() &
                     &           )
             end do

             ! If this is a new tree, perform any pre-evolution tasks on it.
             if (treeIsNew) then
                !# <include directive="mergerTreePreEvolveTask" type="functionCall" functionType="void">
                !#  <functionArgs>thisTree</functionArgs>
                include 'galacticus.tasks.evolve_tree.preEvolveTask.inc'
                !# </include>
                call mergerTreeOperator_%operate(thisTree)
                message="Evolving tree number "
             else
                message="Resuming tree number "
             end if
             ! Display a message.
             message=message//thisTree%index//" {"//thisTree%baseNode%index()//"}"
             call Galacticus_Display_Indent(message)
             
             ! Iterate evolving the tree until we can evolve no more.
             treeTimeEarliest=thisTree%earliestTime()
             outputTimeNext=Galacticus_Next_Output_Time(treeTimeEarliest,outputIndex=iOutput)
             ! For new trees, if the earliest time in the tree exactly coincides with an output
             ! time, then process the tree to that output. This ensures that we include all
             ! halos from this time in the output, even though they will be devoid of any
             ! galaxies.
             if (treeIsNew .and. iOutput > 1) then
                if (treeTimeEarliest == Galacticus_Output_Time(iOutput-1)) iOutput=iOutput-1
             end if

             ! Resumed trees must always be allowed to evolve - since they by definition were not finished (otherwise they would
             ! not have been suspended).
             if (.not.treeIsNew .and. iOutput > Galacticus_Output_Time_Count()) iOutput=Galacticus_Output_Time_Count()
             
             ! Catch cases where there is no next output time.
             if (outputTimeNext > 0.0d0) then
                treeIsFinished=.false.
             else
                iOutput      =Galacticus_Output_Time_Count()+1
                treeIsFinished=.true.
             end if           
             treeEvolveLoop : do while (iOutput <= Galacticus_Output_Time_Count())
                ! We want to find the maximum time to which we can evolve this tree. This will be the minimum of the next output
                ! time (at which we must stop and output the tree) and the next universal event time (at which we must stop and
                ! perform the event task). Find the next output time.
                evolveToTime=Galacticus_Output_Time(iOutput)
                ! Find the earliest universe event.
                !$omp critical(universeTransform)
                thisEvent               => universeWaiting%event
                evolutionIsEventLimited =  .false.
                do while (associated(thisEvent))
                   if (thisEvent%time < evolveToTime) then
                      evolveToTime           =thisEvent%time
                      evolutionIsEventLimited=.true.
                      universalEvolveToTime  =evolveToTime
                   end if
                   thisEvent => thisEvent%next
                end do
                !$omp end critical(universeTransform)
                
                ! If single trees are to be broken between multiple threads and processed in parallel, then do that here. Begin by
                ! finding evolvable branches at some earlier time.
                if (treeEvolveSingleForest) then
                   timeSectionForestBegin=thisTree%earliestTimeEvolving()
                   do forestSection=1,treeEvolveSingleForestSections
                      timeBranchSplit =  timeSectionForestBegin+(evolveToTime-timeSectionForestBegin)*dble(forestSection)/dble(treeEvolveSingleForestSections)
                      countBranch     =  0
                      currentTree     => thisTree
                      do while (associated(currentTree))
                         node => currentTree%baseNode
                         do while (associated(node))
                            if (associated(node%parent)) then
                               basic       => node       %basic()
                               basicParent => node%parent%basic()
                               if (basicParent%time() >= timeBranchSplit .and. basic%time() < timeBranchSplit) then
                                  countBranch=countBranch+1
                                  allocate(branchNew      )
                                  allocate(branchNew%branch)
                                  branchNew%branch            =  currentTree
                                  branchNew%branch%baseNode   => node
                                  branchNew       %nodeParent => node       %parent
                                  if (associated(branchList_)) then
                                     branchNew%next => branchList_
                                  else
                                     branchNew%next => null()
                                  end if
                                  branchList_ => branchNew
                               end if
                            end if
                            node => node%walkTree()
                         end do
                         currentTree => currentTree%nextTree
                      end do
                      ! If no more branches were found to process, exit.
                      if (countBranch == 0) exit
                      ! Rank trees by mass.
                      allocate(massBranch(countBranch))
                      allocate(rankBranch(countBranch))
                      branchNew    => branchList_
                      countBranch =  0
                      do while (associated(branchNew))
                         countBranch             =  countBranch                        +1
                         basic                   => branchNew  %branch%baseNode%basic()
                         massBranch(countBranch) =  basic                      %mass ()
                         branchNew               => branchNew                  %next
                      end do
                      rankBranch=Sort_Index_Do(massBranch)
                      ! Process trees.
                      iBranchAcceptedLast=0
                      !$omp parallel copyin(branchList_,countBranch,rankBranch)
                      iBranch=0
                      do while (iBranch < countBranch)
                         iBranch     =iBranch+1
                         branchAccept=.false.
                         !$omp critical (branchList_Share)
                         if (iBranch > iBranchAcceptedLast) then
                            branchAccept       =.true.
                            iBranchAcceptedLast=iBranch
                         end if
                         !$omp end critical (branchList_Share)
                         if (branchAccept) then
                            branchNew => branchList_
                            do i=1,rankBranch(countBranch+1-iBranch)-1
                               branchNew => branchNew%next
                            end do
                            branchNew%branch%baseNode%parent =>                           null ()
                            basic                            => branchNew%branch%baseNode%basic()
                            call Merger_Tree_Evolve_To(branchNew%branch,basic%time(),treeDidEvolve,suspendTree,deadlockReport)
                            !$omp critical (universeStatus)
                            if (treeDidEvolve) treesDidEvolve         =.true.
                            if (suspendTree  ) evolutionIsEventLimited=.true.
                            !$omp end critical (universeStatus)                      
                         end if
                      end do
                      !$omp end parallel
                      ! Clean up.
                      branchNew => branchList_
                      do while (associated(branchNew))
                         branchNew%branch%baseNode%parent => branchNew%nodeParent
                         branchNew%branch%baseNode        => null()
                         call branchNew%branch%destroy()
                         branchNext => branchNew%next
                         deallocate(branchNew)
                         branchNew => branchNext
                      end do
                      nullify   (branchList_)
                      deallocate(massBranch )
                      deallocate(rankBranch )
                   end do
                end if

                ! Evolve the tree to the computed time.
                call Merger_Tree_Evolve_To(thisTree,evolveToTime,treeDidEvolve,suspendTree,deadlockReport)
                !$omp critical (universeStatus)
                ! Record that evolution of the universe of trees occurred if this tree evolved and was not suspended.
                if (treeDidEvolve) treesDidEvolve=.true.
                !$omp end critical (universeStatus)                
                ! If tree was marked to be suspended, record that evolution is limited by this suspension event.
                if (suspendTree) evolutionIsEventLimited=.true.
                ! Locate trees which consist of only a base node with no progenitors. These have reached
                ! the end of their evolution, and can be removed from the forest of trees.
                previousTree => null()
                currentTree  => thisTree
                do while (associated(currentTree))
                   ! Skip empty trees.
                   if (associated(currentTree%baseNode)) then
                      baseNodeBasic => currentTree%baseNode%basic()                   
                      removeTree    =   .not.associated(currentTree%baseNode%firstChild) &
                           &           .and.                                             &
                           &            (baseNodeBasic%time() < evolveToTime)
                      if (removeTree) then
                         ! Does the node have attached satellites which are about to merge?
                         satelliteNode => currentTree%baseNode%firstSatellite
                         do while (associated(satelliteNode))
                            if (associated(satelliteNode%mergeTarget)) then
                               removeTree=.false.
                               exit
                            end if
                            satelliteNode => satelliteNode%sibling
                         end do
                         ! Does the node have attached events?
                         if (associated(currentTree%baseNode%event)) removeTree=.false.
                      end if
                   else
                      ! No need to remove already empty trees.
                      removeTree=.false.
                   end if
                   if (removeTree) then
                      message="Removing remnant tree "
                      message=message//currentTree%index//" {"//currentTree%baseNode%index()//"}"
                      call Galacticus_Display_Message(message,verbosityInfo)
                      if (.not.associated(previousTree)) then
                         nextTree    => currentTree%nextTree
                         call currentTree%destroy()
                         currentTree => nextTree
                      else
                         previousTree%nextTree => currentTree%nextTree
                         call currentTree%destroy()
                         deallocate(currentTree)
                         currentTree => previousTree%nextTree
                      end if
                   else
                      previousTree => currentTree
                      currentTree  => currentTree%nextTree
                   end if
                end do
                ! Check that tree reached required time. If it did not, we can evolve it no further.
                treeTimeEarliest=thisTree%earliestTimeEvolving()
                treeTimeLatest  =thisTree%  latestTime        ()
                if     (                                 &
                     &   treeTimeLatest   > evolveToTime &
                     &  .and.                            &
                     &   treeTimeEarliest < evolveToTime &
                     &  .and.                            &
                     &   .not.evolutionIsEventLimited    &
                     & ) then
                   if (deadlockReport) exit
                   call Galacticus_Error_Report(                                          &
                        &                       'Galacticus_Task_Evolve_Tree'           , &
                        &                       'failed to evolve tree to required time'  &
                        &                      )
                end if
                ! Determine what limited evolution.
                if (evolutionIsEventLimited) then
                   ! Tree evolution was limited by a universal event. Therefore it can evolve no further
                   ! until that event's task is performed.
                   exit
                else
                   ! Tree reached an output time, so output it. We can then continue evolving.
                   write (label,'(f7.2)') evolveToTime
                   message="Output tree data at t="//trim(label)//" Gyr"
                   call Galacticus_Display_Message(message)
                   call Galacticus_Merger_Tree_Output(thisTree,iOutput,evolveToTime,.false.)
                   iOutput=iOutput+1
                   ! If all output times have been reached, we're finished.
                   if (iOutput > Galacticus_Output_Time_Count()) then
                      treeIsFinished=.true.
                      exit
                   end if
                end if
             end do treeEvolveLoop
             ! If tree could not evolve further, but is not finished, push it to the universe stack.
             if (.not.treeIsFinished) then
                ! Suspend the tree.
                call treeSuspend(thisTree)
                ! Unindent messages.
                call Galacticus_Display_Unindent('Suspending tree')
             else
                ! Unindent messages.
                call Galacticus_Display_Unindent('Finished tree'  )                
             end if
             
          end if
          
          ! Destroy the tree.
          if (associated(thisTree)) then
             currentTree => thisTree
             do while (associated(currentTree))
                previousTree => currentTree
                currentTree  => currentTree%nextTree
                call previousTree%destroy()
                ! Deallocate the tree.
                call Memory_Usage_Record(sizeof(previousTree),addRemove=-1,memoryType=memoryTypeNodes)
                deallocate(previousTree)
             end do
             nullify(thisTree)
          end if
          
          ! Perform any post-evolution tasks on the tree.
          if (treeIsFinished) then
             !# <include directive="mergerTreePostEvolveTask" type="functionCall" functionType="void">
             include 'galacticus.tasks.evolve_tree.postEvolveTask.inc'
             !# </include>
          end if

       end if

       ! If locking threads, release ours.
       if (treeEvolveThreadLock) call galacticusMutex%post()

       ! If any trees were pushed onto the processed stack, then there must be an event to process.
       if (finished) then
          !$omp barrier
          !$omp single
          ! Check whether any tree evolution occurred. If it did not, we have a universe-level deadlock.
          if (.not.treesDidEvolve.or.deadlockReport) then
             ! If we already did the deadlock reporting pass it's now time to finish that report and exit. Otherwise, set deadlock
             ! reporting status to true and continue for one more pass through the universe.
             if (deadlockReport) then
                message="Universe appears to be deadlocked"//char(10)
                !$omp critical(universeTransform)
                treeCount=0
                if (associated(universeProcessed%trees)) then
                   do while (associated(universeProcessed%trees))
                      thisTree => universeProcessed%popTree()
                      treeCount=treeCount+1
                   end do
                   message=message//" --> There are "//treeCount//" trees pending further processing"
                else
                   message=message//" --> There are no trees pending further processing"
                end if
                !$omp end critical(universeTransform)
                call Galacticus_Display_Message(message)
                call Inter_Tree_Event_Post_Evolve()
                call Galacticus_Error_Report('Galacticus_Task_Evolve_Tree','exiting')
             else
                deadlockReport=.true.
             end if
          end if
          treesDidEvolve=.false.
          !$omp critical(universeTransform)
          if (associated(universeProcessed%trees)) then
             ! Transfer processed trees back to the waiting universe.
             universeWaiting  %trees => universeProcessed%trees
             universeProcessed%trees => null()
             ! Find the event to process.
             thisEvent => universeWaiting%event
             do while (associated(thisEvent))
                if (thisEvent%time < universalEvolveToTime) then
                   call Galacticus_Error_Report('Galacticus_Task_Evolve_Tree','a universal event exists in the past - this should not happen')
                else if (thisEvent%time == universalEvolveToTime) then
                   success=thisEvent%task(universeWaiting)
                   if (success) call universeWaiting%removeEvent(thisEvent)
                   exit
                end if
                thisEvent => thisEvent%next
             end do
             ! Mark that there is more work to do.
             finished=.false.
             call Galacticus_Display_Message('Finished universe evolution pass')
          end if
          !$omp end critical(universeTransform)
          !$omp end single copyprivate(finished)
       end if
    end do
    ! Finalize any merger tree operator.
    call mergerTreeOperator_%finalize()
    !$omp end parallel
    
    ! Close the semaphore.
    if (treeEvolveThreadLock) call galacticusMutex%close()

    ! Perform any post universe evolve tasks
    !# <include directive="universePostEvolveTask" type="functionCall" functionType="void">
    include 'galacticus.tasks.evolve_tree.universePostEvolveTask.inc'
    !# </include>

    Galacticus_Task_Evolve_Tree=.false.
    return
  end function Galacticus_Task_Evolve_Tree

  subroutine Get_Tree(iTree,skipTree,thisTree,finished)
    !% Get a tree to process.
    use Merger_Tree_Construction
    !# <include directive="mergerTreePreTreeConstructionTask" type="moduleUse">
    include 'galacticus.tasks.evolve_tree.preConstructionTask.moduleUse.inc'
    !# </include>
    implicit none
    integer            , intent(inout)          :: iTree
    logical            , intent(  out)          :: skipTree
    logical            , intent(inout)          :: finished
    type   (mergerTree), intent(  out), pointer :: thisTree

    ! Increment the tree counter.
    iTree=iTree+1
    ! Decide whether or not to skip this tree.
    skipTree=.not.(modulo(iTree-1+(iTree-1)/treeEvolveWorkerCount,treeEvolveWorkerCount) == treeEvolveWorkerNumber-1)
    ! Perform any pre-tree construction tasks.
    !# <include directive="mergerTreePreTreeConstructionTask" type="functionCall" functionType="void">
    include 'galacticus.tasks.evolve_tree.preConstructionTask.inc'
    !# </include>

    ! Get a tree.
    thisTree => Merger_Tree_Create(skipTree)
    finished=finished.or..not.associated(thisTree)
    return
  end subroutine Get_Tree

  subroutine treeSuspend(tree)
    !% Suspend processing of a tree.
    use String_Handling
    use Merger_Trees_State_Store
    use Kind_Numbers
    use ISO_Varying_String
    implicit none
    type   (mergerTree    ), pointer, intent(inout) :: tree
    type   (mergerTree    ), pointer                :: treeCurrent     , branchNext
    integer(kind_int8     )                         :: baseNodeUniqueID
    type   (varying_string)                         :: fileName
    
    ! If the tree is to be suspended to file do so now.
    if (.not.treeEvolveSuspendToRAM) then
       ! Make a copy of the unique ID of the base node.
       baseNodeUniqueID=tree%baseNode%uniqueID()
       ! Generate a suitable file name.
       fileName=treeEvolveSuspendPath//'/suspendedTree_'//baseNodeUniqueID
       ! Store the tree to file.
       call Merger_Tree_State_Store(tree,char(fileName),snapshot=.false.,append=.false.)
       ! Destroy the tree(s).
       treeCurrent => tree
       do while (associated(treeCurrent))
          branchNext => treeCurrent%nextTree
          call treeCurrent%destroy()
          treeCurrent => branchNext
       end do
       ! Set the tree index to the base node unique ID so that we can resume from the correct file.
       tree%index=baseNodeUniqueID
    end if
    !$omp critical(universeTransform)
    call universeProcessed%pushTree(tree)
    !$omp end critical(universeTransform)
    tree => null()    
    return
  end subroutine treeSuspend
  
  subroutine treeResume(tree)
    !% Resume processing of a tree.
    use Merger_Trees_State_Store
    use String_Handling
    use ISO_Varying_String
    implicit none
    type(mergerTree    ), pointer, intent(  out) :: tree
    type(varying_string)                         :: fileName

    !$omp critical(universeTransform)
    tree => universeWaiting%popTree()
    !$omp end critical(universeTransform)
    ! If the tree was suspended to file, restore it now.
    if (.not.treeEvolveSuspendToRAM.and.associated(tree)) then
       ! Generate the file name.
       fileName=treeEvolveSuspendPath//'/suspendedTree_'//tree%index
       ! Read the tree from file.
       call Merger_Tree_State_From_File(tree,char(fileName),deleteAfterRead=.true.)
    end if
    return
  end subroutine treeResume
  
end module Galacticus_Tasks_Evolve_Tree
