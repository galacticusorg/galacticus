!! Copyright 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018
!!    Andrew Benson <abenson@carnegiescience.edu>
!!
!! This file is part of Galacticus.
!!
!!    Galacticus is free software: you can redistribute it and/or modify
!!    it under the terms of the GNU General Public License as published by
!!    the Free Software Foundation, either version 3 of the License, or
!!    (at your option) any later version.
!!
!!    Galacticus is distributed in the hope that it will be useful,
!!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!!    GNU General Public License for more details.
!!
!!    You should have received a copy of the GNU General Public License
!!    along with Galacticus.  If not, see <http://www.gnu.org/licenses/>.

!+    Contributions to this file made by:  Alex Merson.

!% Contains a module which defines the stellar luminosities object.

module Stellar_Luminosities_Structure
  !% Defines the stellar luminosities object.
  use ISO_Varying_String
  implicit none
  private
  public :: stellarLuminosities               , max                             , &
       &    abs                               , operator(*)                     , &
       &    Stellar_Luminosities_Parameter_Map, Stellar_Luminosities_State_Store, &
       &    Stellar_Luminosities_State_Restore

  ! Interface to parameter mapping functions.
  interface Stellar_Luminosities_Parameter_Map
     module procedure Stellar_Luminosities_Parameter_Map_Double
  end interface Stellar_Luminosities_Parameter_Map
  
  ! Interface to max() function for stellar luminosities objects.
  interface max
     module procedure stellarLuminositiesMax
  end interface max

  ! Interface to abs() function for stellar luminosities objects.
  interface abs
     module procedure stellarLuminositiesAbs
  end interface abs

  ! Interface to multiplication operators with stellar luminosities objects as their second argument.
  interface operator(*)
     module procedure Stellar_Luminosities_Multiply_Switched
  end interface operator(*)

  type stellarLuminosities
     !% The stellar luminosities structure.
     private
     double precision, allocatable, dimension(:) :: luminosityValue
   contains
     !@ <objectMethods>
     !@   <object>stellarLuminosities</object>
     !@   <objectMethod>
     !@     <method>multiply</method>
     !@     <type>\textcolor{red}{\textless type(stellarLuminosities)\textgreater}</type>
     !@     <arguments>\doublezero\ multiplier\argin</arguments>
     !@     <description>Multiply stellar luminosities by a scalar.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>divide</method>
     !@     <type>\textcolor{red}{\textless type(stellarLuminosities)\textgreater}</type>
     !@     <arguments>\doublezero\ divisor\argin</arguments>
     !@     <description>Divide stellar luminosities by a scalar.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>add</method>
     !@     <type>\textcolor{red}{\textless type(stellarLuminosities)\textgreater}</type>
     !@     <arguments>\textcolor{red}{\textless type(stellarLuminosities)\textgreater} stellarLuminosities2\argin</arguments>
     !@     <description>Add two stellarLuminosities.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>subtract</method>
     !@     <type>\textcolor{red}{\textless type(stellarLuminosities)\textgreater}</type>
     !@     <arguments>\textcolor{red}{\textless type(stellarLuminosities)\textgreater} stellarLuminosities2\argin</arguments>
     !@     <description>Subtract one abundance from another.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>increment</method>
     !@     <type>\void</type>
     !@     <arguments>\textcolor{red}{\textless type(stellarLuminosities)\textgreater} addStellarLuminosities\argin</arguments>
     !@     <description>Increment a stellar luminosities object.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>serializeCount</method>
     !@     <type>\intzero</type>
     !@     <arguments></arguments>
     !@     <description>Return a count of the number of properties in a serialized stellar luminosities object.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>serialize</method>
     !@     <type>\void</type>
     !@     <arguments>\doubleone\ array\argout</arguments>
     !@     <description>Serialize a stellar luminosities object to an array.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>deserialize</method>
     !@     <type>\void</type>
     !@     <arguments>\doubleone\ array\argin</arguments>
     !@     <description>Deserialize a stellar luminosities object from an array.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>isZero</method>
     !@     <type>\logicalzero</type>
     !@     <arguments></arguments>
     !@     <description>Return true if a stellar luminosities object is zero.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>destroy</method>
     !@     <type>\void</type>
     !@     <arguments></arguments>
     !@     <description>Destroy a stellar luminosities object.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>reset</method>
     !@     <type>\void</type>
     !@     <arguments></arguments>
     !@     <description>Reset a stellar luminosities object.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>builder</method>
     !@     <type>\void</type>
     !@     <arguments>\textcolor{red}{\textless *type(node)\textgreater} stellarLuminositiesDefinition\argin</arguments>
     !@     <description>Build a stellar luminosities object from a provided XML description.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>dump</method>
     !@     <type>\void</type>
     !@     <arguments></arguments>
     !@     <description>Dump a stellar luminosities object.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <type>\void</type>
     !@     <method>dumpRaw</method>
     !@     <arguments>\intzero\ fileHandle\argin</arguments>
     !@     <description>Dump a stellar luminosities object to binary.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>readRaw</method>
     !@     <type>\void</type>
     !@     <arguments>\intzero\ fileHandle\argin</arguments>
     !@     <description>Read a stellar luminosities object from binary.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>setToUnity</method>
     !@     <type>\void</type>
     !@     <arguments></arguments>
     !@     <description>Set a stellar luminosities object to unity.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>luminosity</method>
     !@     <type>\doublezero</type>
     !@     <arguments>\intzero\ index\argin</arguments>
     !@     <description>Return the $i^\mathrm{th}$ luminosity.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>output</method>
     !@     <type>\void</type>
     !@     <arguments>\intzero\ integerProperty\arginout, \intzero\ integerBufferCount\arginout, \inttwo\ integerBuffer\arginout, \intzero doubleProperty\arginout, \intzero\ doubleBufferCount\arginout, \doubletwo\ doubleBuffer\arginout, \doublezero\ time\argin, \intzero\ instance\argin</arguments>
     !@     <description>Store a stellar luminosities object in the output buffers.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>luminosityOutputCount</method>
     !@     <type>\intzero</type>
     !@     <arguments>\doublezero\ time\argin</arguments>
     !@     <description>Return the number of luminosities to be output at the given time.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>outputCount</method>
     !@     <type>\void</type>
     !@     <arguments>\intzero\ integerPropertyCount\arginout, \intzero\ doublePropertyCount\arginout, \doublezero\ time\argin, \intzero\ instance\argin</arguments>
     !@     <description>Specify the count of a stellar luminosities object for output.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>outputNames</method>
     !@     <type>\void</type>
     !@     <arguments>\intzero\ integerProperty\arginout, \textcolor{red}{\textless char[*](:)\textgreater} integerPropertyNames\arginout, \textcolor{red}{\textless char[*](:)\textgreater} integerPropertyComments\arginout, \doubleone\ integerPropertyUnitsSI\arginout, \intzero\ doubleProperty\arginout, \textcolor{red}{\textless char[*](:)\textgreater} doublePropertyNames\arginout, \textcolor{red}{\textless char[*](:)\textgreater} doublePropertyComments\arginout, \doubleone\ doublePropertyUnitsSI\arginout, \doublezero\ time\argin, \intzero\ instance\argin</arguments>
     !@     <description>Specify the names of stellar luminosities object properties for output.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>luminosityCount</method>
     !@     <type>\intzero</type>
     !@     <arguments>\logicalzero\ [unmapped]</arguments>
     !@     <description>Return the total number of luminosities tracked. If {\normalfont \ttfamily unmapped} is true, then the number of luminosities prior to mapping is returned.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>setLuminosities</method>
     !@     <type>\void</type>
     !@     <arguments>\doublezero\ mass\argin,\intzero\ imfSelected\argin,\doublezero currentTime\argin,\textcolor{red}{\textless type(abundances)\textgreater} fuelAbundances\argin</arguments>
     !@     <description>Set the luminosities using a single stellar population.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>isOutput</method>
     !@     <type>\logicalzero</type>
     !@     <arguments>\intzero\ index\argin, \doublezero\ time\argin</arguments>
     !@     <description>Return true if the indexed luminosity is to be output at the given time.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>index</method>
     !@     <type>\intzero</type>
     !@     <arguments>\textcolor{red}{\textless type(varying\_string)\textgreater} name\argin</arguments>
     !@     <description>Return the index to a luminosity specified by name.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>name</method>
     !@     <type>\textcolor{red}{\textless type(varying\_string)\textgreater}</type>
     !@     <arguments>\intzero\ index\argin</arguments>
     !@     <description>Return the name of a luminosity specified by index.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>truncate</method>
     !@     <type>\void</type>
     !@     <arguments>\textcolor{red}{\textless type(stellarLuminosities)\textgreater} templateLuminosities\argin</arguments>
     !@     <description>Truncate the number of stellar luminosities stored to match that in the given {\normalfont \ttfamily templateLuminosities}.</description>
     !@   </objectMethod>
     !@ </objectMethods>
     final             ::                          Stellar_Luminosities_Destructor
     procedure         :: add                   => Stellar_Luminosities_Add
     procedure         :: subtract              => Stellar_Luminosities_Subtract
     procedure         :: multiply              => Stellar_Luminosities_Multiply
     procedure         :: divide                => Stellar_Luminosities_Divide
     generic           :: operator(+)           => add
     generic           :: operator(-)           => subtract
     generic           :: operator(*)           => multiply
     generic           :: operator(/)           => divide
     procedure         :: isZero                => Stellar_Luminosities_Is_Zero
     procedure         :: destroy               => Stellar_Luminosities_Destroy
     procedure         :: reset                 => Stellar_Luminosities_Reset
     procedure         :: builder               => Stellar_Luminosities_Builder
     procedure         :: dump                  => Stellar_Luminosities_Dump
     procedure         :: dumpRaw               => Stellar_Luminosities_Dump_Raw
     procedure         :: readRaw               => Stellar_Luminosities_Read_Raw
     procedure         :: setToUnity            => Stellar_Luminosities_Set_To_Unity
     procedure         :: luminosity            => Stellar_Luminosities_Luminosity
     procedure         :: setLuminosities       => Stellar_Luminosities_Set
     procedure, nopass :: luminosityCount       => Stellar_Luminosities_Property_Count
     procedure         :: serializeCount        => Stellar_Luminosities_Serialize_Count
     procedure         :: serialize             => Stellar_Luminosities_Serialize
     procedure         :: deserialize           => Stellar_Luminosities_Deserialize
     procedure         :: increment             => Stellar_Luminosities_Increment
     procedure         :: output                => Stellar_Luminosities_Output
     procedure, nopass :: luminosityOutputCount => Stellar_Luminosities_Output_Count_Get
     procedure         :: outputCount           => Stellar_Luminosities_Output_Count
     procedure         :: outputNames           => Stellar_Luminosities_Output_Names
     procedure, nopass :: isOutput              => Stellar_Luminosities_Is_Output
     procedure, nopass ::                          Stellar_Luminosities_Index_From_Name
     procedure, nopass ::                          Stellar_Luminosities_Index_From_Properties
     generic           :: index                 => Stellar_Luminosities_Index_From_Name      , &
          &                                        Stellar_Luminosities_Index_From_Properties
     procedure, nopass :: name                  => Stellar_Luminosities_Name
     procedure         :: truncate              => Stellar_Luminosities_Truncate
  end type stellarLuminosities

  ! Flag specifying if module has been initialized.
  logical                                                          :: luminositiesInitialized           =.false.

  ! Arrays which hold the luminosity specifications.
  integer                                                          :: luminosityCount                           , luminosityCountUnmapped
  integer                              , allocatable, dimension(:) :: luminosityFilterIndex                     , luminosityIndex               , &
       &                                                              luminosityPostprocessingChainIndex        , luminosityMap
  double precision                     , allocatable, dimension(:) :: luminosityBandRedshift                    , luminosityCosmicTime          , &
       &                                                              luminosityRedshift
  type            (varying_string     ), allocatable, dimension(:) :: luminosityFilter                          , luminosityName                , &
       &                                                              luminosityPostprocessSet                  , luminosityType                , &
       &                                                              luminosityRedshiftText

  ! Luminosity output options.
  integer                                                          :: luminosityOutputOption
  integer                              , parameter                 :: luminosityOutputOptionAll         =0      , luminosityOutputOptionFuture=1, &
       &                                                              luminosityOutputOptionPresent     =2

  ! Unit and zero stellarLuminosities objects.
  type            (stellarLuminosities), public                    :: unitStellarLuminosities                   , zeroStellarLuminosities

contains

  subroutine Stellar_Luminosities_Initialize
    !% Initialize the {\normalfont \ttfamily stellarLuminositiesStructure} object module. Determines which stellar luminosities are to be tracked.
    use, intrinsic :: ISO_C_Binding
    use Input_Parameters
    use Galacticus_Error
    use Memory_Management
    use Instruments_Filters
    use Cosmology_Functions
    use Stellar_Population_Spectra_Postprocess
    use Array_Utilities
    use Sort
    use HII_Region_Emission_Lines
    implicit none
    class           (cosmologyFunctionsClass), pointer                   :: cosmologyFunctions_
    integer                                                              :: iLuminosity               , jLuminosity
    double precision                                                     :: expansionFactor
    character       (len=10                 )                            :: redshiftLabel
    type            (varying_string         )                            :: luminosityOutputOptionText
    integer         (c_size_t               ), allocatable, dimension(:) :: luminosityTimeIndex
    
    ! Initialize the module if necessary.
    if (.not.luminositiesInitialized) then
       !$omp critical (Stellar_Luminosities_Initialize)
       if (.not.luminositiesInitialized) then
          ! Get luminosity output option.
          !# <inputParameter>
          !#   <name>luminosityOutputOption</name>
          !#   <cardinality>1</cardinality>
          !#   <defaultValue>var_str('present')</defaultValue>
          !#   <description>
          !#      Selects which luminosities will be output at each output time:
          !#      \begin{description}
          !#      \item [all] Output all luminosities;
          !#      \item [future] Output only those luminosities computed for the present output or future times;
          !#      \item [present] Output only those luminosities computed for the present output time.
          !#      \end{description}
          !#   </description>
          !#   <group>output</group>
          !#   <source>globalParameters</source>
          !#   <type>integer</type>
          !#   <variable>luminosityOutputOptionText</variable>
          !# </inputParameter>
          select case (char(luminosityOutputOptionText))
          case ("all")
             luminosityOutputOption=luminosityOutputOptionAll
          case ("future")
             luminosityOutputOption=luminosityOutputOptionFuture
          case ("present")
             luminosityOutputOption=luminosityOutputOptionPresent
          case default
             call Galacticus_Error_Report("unrecognized luminosityOutputOption"//{introspection:location})
          end select

          ! Read in the parameters which specify the luminosities to be computed.
          luminosityCount=globalParameters%count('luminosityRedshift',zeroIfNotPresent=.true.)
          luminosityCountUnmapped=luminosityCount
          if (globalParameters%count('luminosityFilter',zeroIfNotPresent=.true.) /= luminosityCount) &
               & call Galacticus_Error_Report('luminosityFilter and luminosityRedshift input arrays must have same dimension'//{introspection:location})
          if (globalParameters%count('luminosityType',zeroIfNotPresent=.true.) /= luminosityCount) &
               & call Galacticus_Error_Report('luminosityType and luminosityRedshift input arrays must have same dimension'//{introspection:location})
          if (globalParameters%isPresent('luminosityBandRedshift')) then
             if (globalParameters%count('luminosityBandRedshift',zeroIfNotPresent=.true.) /= luminosityCount) &
                  & call Galacticus_Error_Report('luminosityBandRedshift and luminosityRedshift input arrays must have same dimension'//{introspection:location})
          end if

          if (luminosityCount > 0) then
             call allocateArray(luminosityMap                     ,[luminosityCount])
             call allocateArray(luminosityRedshift                ,[luminosityCount])
             call allocateArray(luminosityBandRedshift            ,[luminosityCount])
             allocate(luminosityFilter        (luminosityCount))
             allocate(luminosityType          (luminosityCount))
             allocate(luminosityPostprocessSet(luminosityCount))
             allocate(luminosityRedshiftText  (luminosityCount))
             call Memory_Usage_Record(sizeof(luminosityFilter)+sizeof(luminosityType)+sizeof(luminosityPostprocessSet),blockCount=4)
             !# <inputParameter>
             !#   <name>luminosityRedshift</name>
             !#   <cardinality>0..*</cardinality>
             !#   <description>The redshift for which to compute each specified stellar luminosity.</description>
             !#   <source>globalParameters</source>
             !#   <type>real</type>
             !#   <variable>luminosityRedshiftText</variable>
             !# </inputParameter>
             do iLuminosity=1,size(luminosityRedshiftText)
                if (luminosityRedshiftText(iLuminosity) /= "all") then
                   redshiftLabel=char(luminosityRedshiftText(iLuminosity))
                   read (redshiftLabel,*) luminosityRedshift(iLuminosity)
                else
                   luminosityRedshift(iLuminosity)=-2.0d0
                end if
                ! Assign a mapping from initial to final array of luminosities (this is initially an identity mapping).
                luminosityMap(iLuminosity)=iLuminosity
             end do
             if (globalParameters%isPresent('luminosityBandRedshift')) then
                !# <inputParameter>
                !#   <name>luminosityBandRedshift</name>
                !#   <cardinality>0..*</cardinality>
                !#   <description>If present, force filters to be shifted to this redshift rather than that specified by {\normalfont \ttfamily [luminosityRedshift]}. Allows sampling of the SED at wavelengths corresponding to other redshifts.</description>
                !#   <source>globalParameters</source>
                !#   <type>real</type>
                !# </inputParameter>
             else                
                luminosityBandRedshift=luminosityRedshift
             end if
             !# <inputParameter>
             !#   <name>luminosityFilter</name>
             !#   <cardinality>0..*</cardinality>
             !#   <description>The filter name for each stellar luminosity to be computed.</description>
             !#   <source>globalParameters</source>
             !#   <type>string</type>
             !# </inputParameter>
             !# <inputParameter>
             !#   <name>luminosityType</name>
             !#   <cardinality>0..*</cardinality>
             !#   <description>
             !#      The luminosity type for each stellar luminosity to be computed:
             !#      \begin{description}
             !#       \item[rest] Compute luminosity in the galaxy rest frame;
             !#       \item[observed] Compute luminosity in the observer frame\footnote{The luminosity computed in this way is that in the galaxy rest
             !#                       frame using a filter blueshifted to the galaxy's redshift. This means that to compute an apparent magnitude you
             !#                       must add not only the distance modulus, but a factor of $-2.5\log_{10}(1+z)$ to account for compression of photon
             !#                       frequencies.}.
             !#      \end{description}
             !#   </description>
             !#   <source>globalParameters</source>
             !#   <type>string</type>
             !# </inputParameter>
             ! Read postprocessing set information.
             if (globalParameters%count('luminosityPostprocessSet',zeroIfNotPresent=.true.) > 0) then
                if (globalParameters%count('luminosityPostprocessSet') /= luminosityCount) &
                     & call Galacticus_Error_Report('luminosityPostprocessSet and luminosityFilter input arrays must have same dimension'//{introspection:location})
                !# <inputParameter>
                !#   <name>luminosityPostprocessSet</name>
                !#   <cardinality>0..*</cardinality>
                !#   <description>The name of the set of postprocessing algorithms to apply to this filter.</description>
                !#   <source>globalParameters</source>
                !#   <type>string</type>
                !# </inputParameter>
             else
                luminosityPostprocessSet="default"
             end if
             ! Handle luminosity definition special cases.
             call Stellar_Luminosities_Special_Cases(luminosityMap,luminosityRedshiftText,luminosityRedshift,luminosityBandRedshift,luminosityFilter,luminosityType,luminosityPostprocessSet)
             luminosityCount=size(luminosityRedshift)
             ! Allocate remaining required arrays.
             allocate(luminosityName(luminosityCount))
             call allocateArray(luminosityFilterIndex             ,[luminosityCount])
             call allocateArray(luminosityIndex                   ,[luminosityCount])
             call allocateArray(luminosityPostprocessingChainIndex,[luminosityCount])
             call allocateArray(luminosityCosmicTime              ,[luminosityCount])
             call allocateArray(luminosityTimeIndex               ,[luminosityCount])
             ! Get the default cosmology functions object.
             cosmologyFunctions_ => cosmologyFunctions()
             ! Process the list of luminosities.
             do iLuminosity=1,luminosityCount
                ! Assign a name to this luminosity.
                write (redshiftLabel,'(f7.4)')     luminosityBandRedshift  (iLuminosity)
                luminosityName       (iLuminosity)=luminosityFilter        (iLuminosity)//":"// &
                     &                             luminosityType          (iLuminosity)//":"// &
                     &                             "z"   //trim(adjustl(redshiftLabel))
                if (globalParameters%isPresent('luminosityBandRedshift')) then
                   write (redshiftLabel,'(f7.4)')  luminosityRedshift      (iLuminosity)
                   luminosityName    (iLuminosity)=luminosityName          (iLuminosity)//":"// &
                        &                          "zOut"//trim(adjustl(redshiftLabel))
                end if
                if (luminosityPostprocessSet(iLuminosity) /= "default") &
                     & luminosityName(iLuminosity)=luminosityName          (iLuminosity)//":"// &
                     &                             luminosityPostprocessSet(iLuminosity)
                ! Check for duplicated luminosities.
                if (iLuminosity > 1) then
                   do jLuminosity=1,iLuminosity-1
                      if (luminosityName(iLuminosity) == luminosityName(jLuminosity)) &
                           & call Galacticus_Error_Report('luminosity '//luminosityName(iLuminosity)//' appears more than once in the input parameter file'//{introspection:location})
                   end do
                end if
                ! Assign an index for this luminosity.
                luminosityIndex(iLuminosity)=iLuminosity
                ! Get the index of the specified filter.
                luminosityFilterIndex(iLuminosity)=Filter_Get_Index(luminosityFilter(iLuminosity))
                ! Set the reference time (i.e. cosmological time corresponding to the specified redshift) for this filter.
                expansionFactor                  =cosmologyFunctions_%expansionFactorFromRedshift(luminosityRedshift(iLuminosity))
                luminosityCosmicTime(iLuminosity)=cosmologyFunctions_%cosmicTime                 (expansionFactor                )
                ! Set the filter redshifting factor. This is equal to the requested redshift if an observed frame was specified, otherwise
                ! it is set to zero to indicate a rest-frame filter.
                select case(char(luminosityType(iLuminosity)))
                case ("rest")
                   luminosityBandRedshift(iLuminosity)=0.0d0
                case ("observed")
                   ! Do nothing, we already have the correct redshift.
                case default
                   call Galacticus_Error_Report('unrecognized filter type - must be "rest" or "observed"'//{introspection:location})
                end select
                ! Find the index for the postprocessing chain to be applied to this filter.
                luminosityPostprocessingChainIndex(iLuminosity)=Stellar_Population_Spectrum_Postprocess_Index(luminosityPostprocessSet(iLuminosity))
             end do
             ! Sort the luminosities such that the latest luminosities are stored first.
             luminosityTimeIndex=Array_Reverse(Sort_Index_Do(luminosityCosmicTime))
             call Sort_By_Index(luminosityFilterIndex             ,luminosityTimeIndex)
             call Sort_By_Index(luminosityPostprocessingChainIndex,luminosityTimeIndex)
             call Sort_By_Index(luminosityCosmicTime              ,luminosityTimeIndex)
             call Sort_By_Index(luminosityName                    ,luminosityTimeIndex)
             call Sort_By_Index(luminosityRedshift                ,luminosityTimeIndex)
             call Sort_By_Index(luminosityBandRedshift            ,luminosityTimeIndex)             
             call Sort_By_Index(luminosityFilter                  ,luminosityTimeIndex)             
             call Sort_By_Index(luminosityType                    ,luminosityTimeIndex)             
             call Sort_By_Index(luminosityPostprocessSet          ,luminosityTimeIndex)             
             ! Allocate unit and zero stellar abundance objects.
             call allocateArray(unitStellarLuminosities%luminosityValue,[luminosityCount])
             call allocateArray(zeroStellarLuminosities%luminosityValue,[luminosityCount])
             unitStellarLuminosities%luminosityValue=1.0d0
             zeroStellarLuminosities%luminosityValue=0.0d0
          end if
          luminositiesInitialized=.true.
       end if
       !$omp end critical (Stellar_Luminosities_Initialize)
    end if
    return
  end subroutine Stellar_Luminosities_Initialize

  subroutine Stellar_Luminosities_Destructor(self)
    !% Destructor for a {\normalfont \ttfamily stellarLuminosities} object.
    use Memory_Management
    implicit none
    type(stellarLuminosities), intent(inout) :: self

    if (allocated(self%luminosityValue)) call deallocateArray(self%luminosityValue)
    return
  end subroutine Stellar_Luminosities_Destructor

  subroutine Stellar_Luminosities_Destroy(self)
    !% Destroy an stellarLuminosities object.
    use Memory_Management
    implicit none
    class(stellarLuminosities), intent(inout) :: self

    if (allocated(self%luminosityValue)) call deallocateArray(self%luminosityValue)
    return
  end subroutine Stellar_Luminosities_Destroy

  subroutine Stellar_Luminosities_Builder(self,stellarLuminositiesDefinition)
    !% Build a {\normalfont \ttfamily stellarLuminosities} object from the given XML {\normalfont \ttfamily stellarLuminositiesDefinition}.
    use FoX_DOM
    use Galacticus_Error
    implicit none
    class  (stellarLuminosities), intent(inout)          :: self
    type   (node               ), intent(in   ), pointer :: stellarLuminositiesDefinition
    type   (node               )               , pointer :: luminosity
    type   (nodeList           )               , pointer :: luminosityList
    integer                                              :: i

    ! Get the luminosities.
    luminosityList => getElementsByTagName(stellarLuminositiesDefinition,'luminosity')
    if (luminosityCount > 0) then
       do i=0,luminosityCount-1
          luminosity => item(luminosityList,i)
          call extractDataContent(luminosity,self%luminosityValue(i))
       end do
    end if
    return
  end subroutine Stellar_Luminosities_Builder

  subroutine Stellar_Luminosities_Dump(self)
    !% Dump a stellar luminosities object.
    use Galacticus_Display
    implicit none
    class    (stellarLuminosities), intent(in   ) :: self
    integer                                       :: i
    character(len=12             )                :: label
    type     (varying_string     )                :: message

    ! Ensure module is initialized.
    call Stellar_Luminosities_Initialize()
    ! Dump the contents.
    if (luminosityCount > 0) then
       do i=1,luminosityCount
          if (i <= size(self%luminosityValue)) then
             write (label,'(e12.6)') self%luminosityValue(i)
          else
             label="pruned"
          end if
          message=luminosityName(i)//':          '//label
          call Galacticus_Display_Message(message)
       end do
    end if
    return
  end subroutine Stellar_Luminosities_Dump

  subroutine Stellar_Luminosities_Dump_Raw(self,fileHandle)
    !% Dump an stellarLuminosities object to binary.
    implicit none
    class  (stellarLuminosities), intent(in   ) :: self
    integer                     , intent(in   ) :: fileHandle

    ! Ensure module is initialized.
    call Stellar_Luminosities_Initialize()
    ! Dump the content.
    if (luminosityCount > 0) then
       write (fileHandle) size(self%luminosityValue)
       write (fileHandle) self%luminosityValue
    end if
    return
  end subroutine Stellar_Luminosities_Dump_Raw

  subroutine Stellar_Luminosities_Read_Raw(self,fileHandle)
    !% Read an stellarLuminosities object from binary.
    use Memory_Management
    implicit none
    class  (stellarLuminosities), intent(inout) :: self
    integer                     , intent(in   ) :: fileHandle
    integer                                     :: luminosityActiveCount
    
    ! Ensure module is initialized.
    call Stellar_Luminosities_Initialize()
    ! Read the content.
    if (luminosityCount > 0) then
       call Stellar_Luminosities_Create(self)
       read (fileHandle) luminosityActiveCount
       call deallocateArray(self%luminosityValue                        )
       call allocateArray  (self%luminosityValue,[luminosityActiveCount])
       read (fileHandle) self%luminosityValue
    end if
    return
  end subroutine Stellar_Luminosities_Read_Raw

  subroutine Stellar_Luminosities_Reset(self)
    !% Reset an stellarLuminosities object.
    implicit none
    class(stellarLuminosities), intent(inout) :: self

    ! Ensure module is initialized.
    call Stellar_Luminosities_Initialize()
    ! Ensure object is initialized.
    call Stellar_Luminosities_Create(self)
    ! Zero all properties.
    if (luminosityCount > 0) self%luminosityValue=0.0d0
    return
  end subroutine Stellar_Luminosities_Reset

  subroutine Stellar_Luminosities_Set_To_Unity(self)
    !% Set an stellarLuminosities object to unity.
    implicit none
    class(stellarLuminosities), intent(inout) :: self

    ! Ensure module is initialized.
    call Stellar_Luminosities_Initialize()
    ! Ensure object is initialized.
    call Stellar_Luminosities_Create(self)
    ! Set values to unity.
    if (luminosityCount > 0) self%luminosityValue=1.0d0
    return
  end subroutine Stellar_Luminosities_Set_To_Unity

  logical function Stellar_Luminosities_Is_Zero(self)
    !% Test whether an stellarLuminosities object is zero.
    implicit none
    class(stellarLuminosities), intent(in   ) :: self

    ! Ensure module is initialized.
    call Stellar_Luminosities_Initialize()
    ! Detect if all stellar luminosities are zero.
    Stellar_Luminosities_Is_Zero=.true.
    if (luminosityCount > 0 .and. allocated(self%luminosityValue)) then
       if (any(self%luminosityValue /= 0.0d0)) Stellar_Luminosities_Is_Zero=.false.
    end if
    return
  end function Stellar_Luminosities_Is_Zero

  double precision function Stellar_Luminosities_Luminosity(self,index)
    !% Return the requested luminosity from a {\normalfont \ttfamily stellarLuminosities} object.
    use Galacticus_Error
    implicit none
    class  (stellarLuminosities), intent(inout) :: self
    integer                     , intent(in   ) :: index

    ! Ensure module is initialized.
    call Stellar_Luminosities_Initialize()
    ! Return the requested luminosity.
    if (allocated(self%luminosityValue)) then
       if (index > 0 .and. index <= size(self%luminosityValue)) then
          Stellar_Luminosities_Luminosity=self%luminosityValue(index)
       else
          Stellar_Luminosities_Luminosity=0.0d0
          call Galacticus_Error_Report('index out of range'//{introspection:location})
       end if
    else
       Stellar_Luminosities_Luminosity=0.0d0
    end if
    return
  end function Stellar_Luminosities_Luminosity

  integer function stellarLuminositiesCountMaximum(luminosities1,luminosities2)
    implicit none
    type   (stellarLuminosities), intent(in   ) :: luminosities1, luminosities2

    if (allocated(luminosities1%luminosityValue).or.allocated(luminosities2%luminosityValue)) then
       stellarLuminositiesCountMaximum=0
       if (allocated(luminosities1%luminosityValue)) stellarLuminositiesCountMaximum=max(stellarLuminositiesCountMaximum,size(luminosities1%luminosityValue))
       if (allocated(luminosities2%luminosityValue)) stellarLuminositiesCountMaximum=max(stellarLuminositiesCountMaximum,size(luminosities2%luminosityValue))
    else
       stellarLuminositiesCountMaximum=luminosityCount
    end if
    return
  end function stellarLuminositiesCountMaximum
  
  function stellarLuminositiesMax(luminosities1,luminosities2)
    !% Return an element-by-element {\normalfont \ttfamily max()} on two stellar luminosity objects.
    implicit none
    type   (stellarLuminosities)                :: stellarLuminositiesMax
    type   (stellarLuminosities), intent(in   ) :: luminosities1         , luminosities2
    integer                                     :: luminosityCountActual

    if (luminosityCount > 0) then
       luminosityCountActual=stellarLuminositiesCountMaximum(luminosities1,luminosities2)
       stellarLuminositiesMax%luminosityValue=spread(-huge(0.0d0),1,luminosityCountActual)
       if (allocated(luminosities1%luminosityValue))                                              &
            & stellarLuminositiesMax     %luminosityValue(1:size(luminosities1%luminosityValue))= &
            &  max(                                                                               &
            &      stellarLuminositiesMax%luminosityValue(1:size(luminosities1%luminosityValue)), &
            &      luminosities1         %luminosityValue(1:size(luminosities1%luminosityValue))  &
            &     )
       if (allocated(luminosities2%luminosityValue))                                              &
            & stellarLuminositiesMax     %luminosityValue(1:size(luminosities2%luminosityValue))= &
            &  max(                                                                               &
            &      stellarLuminositiesMax%luminosityValue(1:size(luminosities2%luminosityValue)), &
            &      luminosities2         %luminosityValue(1:size(luminosities2%luminosityValue))  &
            &     )
    end if
    return
  end function stellarLuminositiesMax

  function stellarLuminositiesAbs(luminosities)
    !% Return an element-by-element {\normalfont \ttfamily abs()} on a stellar luminosity object.
    implicit none
    type(stellarLuminosities)                :: stellarLuminositiesAbs
    type(stellarLuminosities), intent(in   ) :: luminosities

    if (luminosityCount > 0) stellarLuminositiesAbs%luminosityValue=abs(luminosities%luminosityValue)
    return
  end function stellarLuminositiesAbs

  function Stellar_Luminosities_Add(luminosities1,luminosities2)
    !% Add two stellar luminosities objects.
    implicit none
    type   (stellarLuminosities)                          :: Stellar_Luminosities_Add
    class  (stellarLuminosities), intent(in   )           :: luminosities1
    class  (stellarLuminosities), intent(in   ), optional :: luminosities2
    integer                                               :: luminosityCountActual

    ! Ensure module is initialized.
    call Stellar_Luminosities_Initialize()
    if (luminosityCount > 0) then
       if (present(luminosities2)) then
          luminosityCountActual=stellarLuminositiesCountMaximum(luminosities1,luminosities2)
          Stellar_Luminosities_Add%luminosityValue=spread(0.0d0,1,luminosityCountActual)
          if (allocated(luminosities1%luminosityValue))                                                 &
               & Stellar_Luminosities_Add      %luminosityValue(1:size(luminosities1%luminosityValue))= &
               &      +Stellar_Luminosities_Add%luminosityValue(1:size(luminosities1%luminosityValue))  &
               &      +luminosities1           %luminosityValue(1:size(luminosities1%luminosityValue))
          if (allocated(luminosities2%luminosityValue))                                                 &
               & Stellar_Luminosities_Add      %luminosityValue(1:size(luminosities2%luminosityValue))= &
               &      +Stellar_Luminosities_Add%luminosityValue(1:size(luminosities2%luminosityValue))  &
               &      +luminosities2           %luminosityValue(1:size(luminosities2%luminosityValue))
       else
          Stellar_Luminosities_Add%luminosityValue=+luminosities1%luminosityValue
       end if
    end if
    return
  end function Stellar_Luminosities_Add

  subroutine Stellar_Luminosities_Increment(self,increment)
    !% Increment a stellar luminosities object.
    implicit none
    class  (stellarLuminosities), intent(inout) :: self
    class  (stellarLuminosities), intent(in   ) :: increment
    integer                                     :: luminosityCountActual

    ! Ensure module is initialized.
    call Stellar_Luminosities_Initialize()
    ! Increment.
    if (luminosityCount > 0) then
       luminosityCountActual=luminosityCount
       if (allocated(self     %luminosityValue)) luminosityCountActual=min(luminosityCountActual,size(self     %luminosityValue))
       if (allocated(increment%luminosityValue)) luminosityCountActual=min(luminosityCountActual,size(increment%luminosityValue))
       self%luminosityValue(1:luminosityCountActual)=+self     %luminosityValue(1:luminosityCountActual) &
            &                                        +increment%luminosityValue(1:luminosityCountActual)
    end if
    return
  end subroutine Stellar_Luminosities_Increment

  function Stellar_Luminosities_Subtract(luminosities1,luminosities2)
    !% Subtract two stellar luminosities objects.
    implicit none
    type   (stellarLuminosities)                          :: Stellar_Luminosities_Subtract
    class  (stellarLuminosities), intent(in   )           :: luminosities1
    class  (stellarLuminosities), intent(in   ), optional :: luminosities2
    integer                                               :: luminosityCountActual

    ! Ensure module is initialized.
    call Stellar_Luminosities_Initialize()
    if (luminosityCount > 0) then
       if (present(luminosities2)) then
          luminosityCountActual=stellarLuminositiesCountMaximum(luminosities1,luminosities2)
          Stellar_Luminosities_Subtract%luminosityValue=spread(0.0d0,1,luminosityCountActual)
          if (allocated(luminosities1%luminosityValue))                                                      &
               & Stellar_Luminosities_Subtract      %luminosityValue(1:size(luminosities1%luminosityValue))= &
               &      +Stellar_Luminosities_Subtract%luminosityValue(1:size(luminosities1%luminosityValue))  &
               &      +luminosities1                %luminosityValue(1:size(luminosities1%luminosityValue))
          if (allocated(luminosities2%luminosityValue))                                                      &
               & Stellar_Luminosities_Subtract      %luminosityValue(1:size(luminosities2%luminosityValue))= &
               &      +Stellar_Luminosities_Subtract%luminosityValue(1:size(luminosities2%luminosityValue))  &
               &      -luminosities2                %luminosityValue(1:size(luminosities2%luminosityValue))
       else
          Stellar_Luminosities_Subtract%luminosityValue=-luminosities1%luminosityValue
       end if
    end if
    return
  end function Stellar_Luminosities_Subtract

  function Stellar_Luminosities_Multiply(stellarLuminosities1,multiplier)
    !% Multiply a stellar luminosities object by a scalar.
    implicit none
    type            (stellarLuminosities)                :: Stellar_Luminosities_Multiply
    class           (stellarLuminosities), intent(in   ) :: stellarLuminosities1
    double precision                     , intent(in   ) :: multiplier

    ! Ensure module is initialized.
    call Stellar_Luminosities_Initialize()
    if (luminosityCount > 0) Stellar_Luminosities_Multiply%luminosityValue=stellarLuminosities1%luminosityValue*multiplier
    return
  end function Stellar_Luminosities_Multiply

  function Stellar_Luminosities_Multiply_Switched(multiplier,stellarLuminosities1)
    !% Multiply a stellar luminosities object by a scalar.
    implicit none
    type            (stellarLuminosities)                :: Stellar_Luminosities_Multiply_Switched
    class           (stellarLuminosities), intent(in   ) :: stellarLuminosities1
    double precision                     , intent(in   ) :: multiplier

    ! Ensure module is initialized.
    call Stellar_Luminosities_Initialize()
    if (luminosityCount > 0) Stellar_Luminosities_Multiply_Switched%luminosityValue=stellarLuminosities1%luminosityValue*multiplier
    return
  end function Stellar_Luminosities_Multiply_Switched

  function Stellar_Luminosities_Divide(stellarLuminosities1,divisor)
    !% Divide a stellar luminosities object by a scalar.
    implicit none
    type            (stellarLuminosities)                :: Stellar_Luminosities_Divide
    class           (stellarLuminosities), intent(in   ) :: stellarLuminosities1
    double precision                     , intent(in   ) :: divisor

    ! Ensure module is initialized.
    call Stellar_Luminosities_Initialize()
    if (luminosityCount > 0) Stellar_Luminosities_Divide%luminosityValue=stellarLuminosities1%luminosityValue/divisor
    return
  end function Stellar_Luminosities_Divide

  integer function Stellar_Luminosities_Property_Count(unmapped)
    !% Return the number of properties required to track stellar luminosities.
    implicit none
    logical, intent(in   ), optional :: unmapped

    ! Ensure module is initialized.
    call Stellar_Luminosities_Initialize()
    ! Return the relevant count.
    if (present(unmapped).and.unmapped) then
       Stellar_Luminosities_Property_Count=luminosityCountUnmapped
    else
       Stellar_Luminosities_Property_Count=luminosityCount
    end if
    return
  end function Stellar_Luminosities_Property_Count

  integer function Stellar_Luminosities_Serialize_Count(self)
    !% Return the number of properties required to track stellar luminosities.
    implicit none
    class(stellarLuminosities), intent(in   ) :: self

    if (allocated(self%luminosityValue)) then
       Stellar_Luminosities_Serialize_Count=size(self%luminosityValue)
    else
       Stellar_Luminosities_Serialize_Count=luminosityCount
    end if
    return
  end function Stellar_Luminosities_Serialize_Count

  function Stellar_Luminosities_Name(index)
    !% Return a name for the specified entry in the stellar luminosities structure.
    use Galacticus_Error
    implicit none
    type   (varying_string)                :: Stellar_Luminosities_Name
    integer                , intent(in   ) :: index

    ! Ensure module is initialized.
    call Stellar_Luminosities_Initialize()
    ! Check for index in range.
    if (index > 0 .and. index <= luminosityCount) then
       Stellar_Luminosities_Name=trim(luminosityName(index))
    else
       call Galacticus_Error_Report('index out of range'//{introspection:location})
    end if
    return
  end function Stellar_Luminosities_Name

  subroutine Stellar_Luminosities_Create(self)
    !% Ensure that the {\normalfont \ttfamily luminosity} array in a {\normalfont \ttfamily stellarLuminosities} is allocated.
    use Memory_Management
    implicit none
    type(stellarLuminosities), intent(inout) :: self

    if (.not.allocated(self%luminosityValue)) call allocateArray(self%luminosityValue,[luminosityCount])
    return
  end subroutine Stellar_Luminosities_Create

  subroutine Stellar_Luminosities_Deserialize(self,stellarLuminositiesArray)
    !% Pack stellar luminosities from an array into a {\normalfont \ttfamily stellarLuminosities} structure.
    implicit none
    class           (stellarLuminosities)              , intent(inout) :: self
    double precision                     , dimension(:), intent(in   ) :: stellarLuminositiesArray

    ! Ensure module is initialized.
    call Stellar_Luminosities_Initialize()
    select type (self)
    type is (stellarLuminosities)
       ! Ensure luminosities array exists.
       call Stellar_Luminosities_Create(self)
       ! Extract luminosity values from array.
       self%luminosityValue=stellarLuminositiesArray(1:size(self%luminosityValue))
    end select
    return
  end subroutine Stellar_Luminosities_Deserialize

  subroutine Stellar_Luminosities_Serialize(self,stellarLuminositiesArray)
    !% Unpack stellar luminosities from a {\normalfont \ttfamily stellarLuminosities} structure into an array.
    implicit none
    double precision                     , dimension(:), intent(  out) :: stellarLuminositiesArray(:)
    class           (stellarLuminosities)              , intent(in   ) :: self

    ! Ensure module is initialized.
    call Stellar_Luminosities_Initialize()
    ! Place luminosities into array.
    if (allocated(self%luminosityValue)) then
       stellarLuminositiesArray(1:size(self%luminosityValue))=self%luminosityValue
    else
       stellarLuminositiesArray(1:luminosityCount           )=0.0d0
    end if
    return
  end subroutine Stellar_Luminosities_Serialize

  subroutine Stellar_Luminosities_Output(self,integerProperty,integerBufferCount,integerBuffer,doubleProperty,doubleBufferCount&
       &,doubleBuffer,time,outputInstance)
    !% Store a {\normalfont \ttfamily stellarLuminosities} object in the output buffers.
    use Kind_Numbers
    use Memory_Management
    use Multi_Counters
    implicit none
    class           (stellarLuminosities)                , intent(inout) :: self
    double precision                                     , intent(in   ) :: time
    integer                                              , intent(inout) :: doubleBufferCount, doubleProperty, integerBufferCount, &
         &                                                                  integerProperty
    integer         (kind=kind_int8     ), dimension(:,:), intent(inout) :: integerBuffer
    double precision                     , dimension(:,:), intent(inout) :: doubleBuffer
    type            (multiCounter       )                , intent(in   ) :: outputInstance
    double precision                     , dimension(:  ), allocatable   :: luminosityTmp
    integer                                                              :: i                , luminosityRemainingCount
    !GCC$ attributes unused :: integerProperty, integerBufferCount, integerBuffer
    
    ! Ensure module is initialized.
    call Stellar_Luminosities_Initialize()
    if (luminosityCount > 0) then
       do i=1,luminosityCount
          if (Stellar_Luminosities_Is_Output(i,time)) then
             doubleBuffer(doubleBufferCount,doubleProperty+1:doubleProperty+1)=self%luminosityValue(i)
             doubleProperty=doubleProperty+1
          end if
       end do
       ! Test if we can prune luminosities.
       if (outputInstance%isFinal()) then
          select case (luminosityOutputOption)
          case (luminosityOutputOptionFuture,luminosityOutputOptionPresent)
             ! Luminosities from this and earlier outputs no longer needed, so prune them. This is somewhat inefficient if there are
             ! luminosities computed which do not correspond to any output. They will never be pruned and so will continue to use
             ! memory and be evolved along with the galaxy. In principle such luminosities could be needed internally so we do not
             ! remove them.
             call Move_Alloc(self%luminosityValue,luminosityTmp)
             luminosityRemainingCount=size(luminosityTmp)
             do i=1,luminosityCount
                if (Stellar_Luminosities_Is_Output(i,time,luminosityOutputOptionPresent)) &
                     & luminosityRemainingCount=luminosityRemainingCount-1
             end do
             call allocateArray(self%luminosityValue,[luminosityRemainingCount])
             self%luminosityValue=luminosityTmp(1:luminosityRemainingCount)
             call deallocateArray(luminosityTmp)
          end select
       end if
    end if
    return
  end subroutine Stellar_Luminosities_Output

  subroutine Stellar_Luminosities_Output_Count(self,integerPropertyCount,doublePropertyCount,time)
    !% Increment the output count to account for a {\normalfont \ttfamily stellarLuminosities} object.
    implicit none
    class           (stellarLuminosities), intent(in   ) :: self
    integer                              , intent(inout) :: doublePropertyCount, integerPropertyCount
    double precision                     , intent(in   ) :: time
    !GCC$ attributes unused :: self, integerPropertyCount
    
    ! Ensure module is initialized.
    call Stellar_Luminosities_Initialize()
    doublePropertyCount=doublePropertyCount+Stellar_Luminosities_Output_Count_Get(time)
    return
  end subroutine Stellar_Luminosities_Output_Count

  integer function Stellar_Luminosities_Output_Count_Get(time)
    !% Compute the number of luminosities to be output at a given time.
    implicit none
    double precision, intent(in   ) :: time
    integer                         :: i

    ! Ensure module is initialized.
    call Stellar_Luminosities_Initialize()
    Stellar_Luminosities_Output_Count_Get=0
    do i=1,luminosityCount
       if (Stellar_Luminosities_Is_Output(i,time)) Stellar_Luminosities_Output_Count_Get=Stellar_Luminosities_Output_Count_Get+1
    end do
    return
  end function Stellar_Luminosities_Output_Count_Get

  subroutine Stellar_Luminosities_Output_Names(self,integerProperty,integerPropertyNames,integerPropertyComments,integerPropertyUnitsSI&
       &,doubleProperty,doublePropertyNames,doublePropertyComments,doublePropertyUnitsSI,time,prefix,comment,unitsInSI)
    !% Assign names to output buffers for a {\normalfont \ttfamily stellarLuminosities} object.
    implicit none
    class           (stellarLuminosities)              , intent(in   ) :: self
    double precision                                   , intent(in   ) :: time
    integer                                            , intent(inout) :: doubleProperty         , integerProperty
    character       (len=*              ), dimension(:), intent(inout) :: doublePropertyComments , doublePropertyNames   , &
         &                                                                integerPropertyComments, integerPropertyNames
    double precision                     , dimension(:), intent(inout) :: doublePropertyUnitsSI  , integerPropertyUnitsSI
    character       (len=*              )              , intent(in   ) :: comment                , prefix
    double precision                                   , intent(in   ) :: unitsInSI
    integer                                                            :: i
    !GCC$ attributes unused :: self, integerProperty, integerPropertyComments, integerPropertyNames, integerPropertyUnitsSI, 
    
    ! Ensure module is initialized.
    call Stellar_Luminosities_Initialize()
    if (luminosityCount > 0) then
       do i=1,luminosityCount
          if (Stellar_Luminosities_Is_Output(i,time)) then
             doubleProperty=doubleProperty+1
             doublePropertyNames   (doubleProperty)=trim(prefix )// ':'//trim(luminosityName(i))
             doublePropertyComments(doubleProperty)=trim(comment)//' ['//trim(luminosityName(i))//']'
             doublePropertyUnitsSI (doubleProperty)=unitsInSI
          end if
       end do
    end if
    return
  end subroutine Stellar_Luminosities_Output_Names

  logical function Stellar_Luminosities_Is_Output(luminosityIndex,time,outputOption)
    !% Return true or false depending on whether {\normalfont \ttfamily luminosityIndex} should be output at {\normalfont \ttfamily time}.
    use Galacticus_Error
    implicit none
    integer         , intent(in   )           :: luminosityIndex
    double precision, intent(in   )           :: time
    integer         , intent(in   ), optional :: outputOption
    double precision, parameter               :: timeTolerance  =1.0d-3
    integer                                   :: outputOptionActual

    ! Ensure module is initialized.
    call Stellar_Luminosities_Initialize()
    ! Determine output option to use.
    if (present(outputOption)) then
       outputOptionActual=outputOption
    else
       outputOptionActual=luminosityOutputOption
    end if
    select case (outputOptionActual)
    case (luminosityOutputOptionAll)
       Stellar_Luminosities_Is_Output=.true.
    case (luminosityOutputOptionFuture)
       Stellar_Luminosities_Is_Output=(     luminosityCosmicTime(luminosityIndex)       >= time*(1.0d0-timeTolerance))
    case (luminosityOutputOptionPresent)
       Stellar_Luminosities_Is_Output=(abs(luminosityCosmicTime(luminosityIndex)-time) <= time*       timeTolerance )
    case default
       Stellar_Luminosities_Is_Output=.false.
       call Galacticus_Error_Report('unknown luminosity output option'//{introspection:location})
    end select
    return
  end function Stellar_Luminosities_Is_Output

  subroutine Stellar_Luminosities_Set(self,mass,imfSelected,time,abundancesStellar)
    !% Set the luminosity in each band for a single stellar population of given {\normalfont \ttfamily mass} with the specified {\normalfont \ttfamily abundancesStellar} and
    !% which formed at cosmological {\normalfont \ttfamily time} with IMF specified by {\normalfont \ttfamily imfSelected}.
    use Abundances_Structure
    use Stellar_Population_Luminosities
    implicit none
    class           (stellarLuminosities)                             :: self
    integer                              , intent(in   )              :: imfSelected
    double precision                     , intent(in   )              :: mass             , time
    type            (abundances         ), intent(in   )              :: abundancesStellar
    double precision                     , dimension(:) , allocatable :: ages             , massToLightRatio

    ! Ensure module is initialized.
    call Stellar_Luminosities_Initialize()
    
    ! Return if no luminosities are tracked.
    if (luminosityCount == 0) return

    ! Allocate workspace.
    allocate(ages            (luminosityCount))
    allocate(massToLightRatio(luminosityCount))
    
    ! Get the ages that this stellar population will have at the various output times.
    ages=luminosityCosmicTime-time

    ! Get the luminosities for each requested band.
    massToLightRatio=Stellar_Population_Luminosity(                                    &
         &                                         luminosityIndex                   , &
         &                                         luminosityFilterIndex             , &
         &                                         luminosityPostprocessingChainIndex, &
         &                                         imfSelected                       , &
         &                                         abundancesStellar                 , &
         &                                         ages                              , &
         &                                         luminosityBandRedshift              &
         &                                        )
    call Stellar_Luminosities_Create(self)
    self%luminosityValue=mass*massToLightRatio(1:size(self%luminosityValue))
    return
  end subroutine Stellar_Luminosities_Set

  integer function Stellar_Luminosities_Index_From_Name(name)
    !% Return the index of and specified entry in the luminosity list given its name.
    use Galacticus_Error
    implicit none
    type   (varying_string), intent(in   ) :: name
    integer                                :: i

    call Stellar_Luminosities_Initialize()
    Stellar_Luminosities_Index_From_Name=-1
    do i=1,luminosityCount
       if (name == luminosityName(i)) then
          Stellar_Luminosities_Index_From_Name=i
          return
       end if
    end do
    call Galacticus_Error_Report('unmatched name'//{introspection:location})
    return
  end function Stellar_Luminosities_Index_From_Name

  integer function Stellar_Luminosities_Index_From_Properties(filterName,filterType,redshift,redshiftBand,postprocessChain)
    !% Return the index of and specified entry in the luminosity list given its properties.
    use Galacticus_Error
    use Numerical_Comparison
    use ISO_Varying_String
    use String_Handling
    implicit none
    character       (len=*         ), intent(in   )           :: filterName      , filterType
    double precision                , intent(in   )           :: redshift
    double precision                , intent(in   ), optional :: redshiftBand
    character       (len=*         ), intent(in   ), optional :: postprocessChain
    integer                                                   :: i
    character       (len=7         )                          :: label
    type            (varying_string)                          :: message

    call Stellar_Luminosities_Initialize()
    Stellar_Luminosities_Index_From_Properties=-1
    do i=1,luminosityCount
       if     (                                                                                             &
            &                  filterName       == luminosityFilter        (i)                              &
            &  .and.                                                                                        &
            &                  filterType       == luminosityType          (i)                              &
            &  .and.                                                                                        &
            &     Values_Agree(redshift    ,       luminosityRedshift      (i),relTol=1.0d-6,absTol=1.0d-6) &
            &  .and.                                                                                        &
            &   (                                                                                           &
            &     .not.present(redshiftBand    )                                                            &
            &    .or.                                                                                       &
            &     Values_Agree(redshiftBand,       luminosityBandRedshift  (i),relTol=1.0d-6,absTol=1.0d-6) &
            &   )                                                                                           &
            &  .and.                                                                                        &
            &   (                                                                                           &
            &     .not.present(postprocessChain)                                                            &
            &    .or.                                                                                       &
            &                  postprocessChain == luminosityPostprocessSet(i)                              &
            &   )                                                                                           &
            & ) then
          Stellar_Luminosities_Index_From_Properties=i
          return
       end if
    end do
    write (label,'(f7.4)') redshift
    message='unmatched properties ['//filterName//' : '//filterType//' : '//label
    if (present(redshiftBand)) then
       write (label,'(f7.4)') redshiftBand
       message=message//' : '//label
    end if
    message=message//']'
    do i=1,luminosityCount
       message=message//char(10)//i//" of "//luminosityCount
       message=message//" : "//luminosityFilter(i)
       message=message//" : "//luminosityType  (i)
       write (label,'(f6.3)') luminosityRedshift(i)
       message=message//" : "//trim(adjustl(label))
       if (present(redshiftBand)) then
          write (label,'(f6.3)') luminosityBandRedshift   (i)
          message=message//" : "//label
       end if
       if (present(postprocessChain)) then
          message=message//" : "//luminosityPostprocessSet(i)
       end if
    end do
    call Galacticus_Error_Report(message//{introspection:location})
    return
  end function Stellar_Luminosities_Index_From_Properties
  
  subroutine Stellar_Luminosities_SED_Top_Hat_Step(wavelengthCentral,filterWidth,wavelengthMinimum,wavelengthMaximum,observedWidth,redshift,stellarPopulationSpectra_,imfIndex)
    !% Given a top hat filter central wavelength and filter width, determine the position and width of the next top hat filter in the array.
    use Stellar_Population_Spectra
    implicit none 
    double precision                               , intent(inout)          :: wavelengthCentral        , filterWidth
    double precision                               , intent(in   )          :: wavelengthMinimum        , wavelengthMaximum    , observedWidth, &
         &                                                                     redshift
    class           (stellarPopulationSpectraClass), intent(in   ), pointer :: stellarPopulationSpectra_
    double precision                                                        :: restWavelengthMinimum    , restWavelengthMaximum, restWidth    , &
         &                                                                     wavelengthLowerEdge      , tabulatedWidth 
    integer                                        , intent(in   )          :: imfIndex           
    ! Determine rest-frame wavelength extent
    restWavelengthMinimum = wavelengthMinimum/(1.0d0+redshift)
    restWavelengthMaximum = wavelengthMaximum/(1.0d0+redshift)
    restWidth = observedWidth/(1.0d0+redshift)    
    ! Move to lower edge of next filter
    wavelengthLowerEdge = wavelengthCentral + filterWidth/2.0d0
    ! Get wavelength interval in SPS models at lower edge wavelength
    tabulatedWidth = stellarPopulationSpectra_%wavelengthInterval(imfIndex,wavelengthLowerEdge)
    ! Determine where the new filter is: (i) inside the observed wavelength range, (ii) inside the rest wavelength range, 
    ! or (iii) inbetween the observed and rest wavelength ranges.    
    if(wavelengthLowerEdge.lt.restWavelengthMaximum)then
       ! Option (i): still inside rest-frame wavelength range.
       if(tabulatedWidth.gt.restWidth) filterWidth = tabulatedWidth
       wavelengthCentral = wavelengthLowerEdge + filterWidth/2.0d0
    elseif(wavelengthLowerEdge.gt.wavelengthMinimum)then
       ! Option (ii): inside observed-frame wavelength range.
       filterWidth = observedWidth
       if(tabulatedWidth.gt.observedWidth) filterWidth = tabulatedWidth
       wavelengthCentral = wavelengthLowerEdge + filterWidth/2.0d0
    else
       ! Option (iii): between rest-frame and observed-frame wavelength ranges.
       wavelengthCentral = wavelengthMinimum
       filterWidth = observedWidth
       tabulatedWidth = stellarPopulationSpectra_%wavelengthInterval(imfIndex,wavelengthCentral)
       if(tabulatedWidth.gt.observedWidth) filterWidth = tabulatedWidth
       ! If the gap between the rest-frame and observed-frame ranges is small, check to avoid overlap of filters.
       if(wavelengthCentral-filterWidth/2.0d0.lt.wavelengthLowerEdge)then
          ! Overlap possible. Adjust filter position.                                                                                                                                                           
          tabulatedWidth = stellarPopulationSpectra_%wavelengthInterval(imfIndex,wavelengthLowerEdge)
          filterWidth = observedWidth
          if(tabulatedWidth.gt.observedWidth) filterWidth = tabulatedWidth
          wavelengthCentral = wavelengthLowerEdge + filterWidth/2.0d0
       end if
    end if
  end subroutine Stellar_Luminosities_SED_Top_Hat_Step
  
  subroutine Stellar_Luminosities_Special_Cases(luminosityMap,luminosityRedshiftText,luminosityRedshift,luminosityBandRedshift,luminosityFilter,luminosityType,luminosityPostprocessSet)
    !% Modify the input list of luminosities for special cases.
    use, intrinsic :: ISO_C_Binding
    use Galacticus_Output_Times
    use Cosmology_Functions
    use Memory_Management
    use String_Handling
    use HII_Region_Emission_Lines
    use Star_Formation_IMF
    use Stellar_Population_Spectra
    implicit none
    integer                                        , intent(inout), allocatable, dimension(:) :: luminosityMap
    type            (varying_string               ), intent(inout), allocatable, dimension(:) :: luminosityRedshiftText   , luminosityFilter           , &
         &                                                                                       luminosityType           , luminosityPostprocessSet
    double precision                               , intent(inout), allocatable, dimension(:) :: luminosityRedshift       , luminosityBandRedshift
    integer         (c_size_t                     )                                           :: j                        , outputCount                , &
         &                                                                                       i                        , newFilterCount             , &
                                                                                                 k
    integer                                                       , allocatable, dimension(:) :: luminosityMapTmp
    type            (varying_string               )               , allocatable, dimension(:) :: luminosityRedshiftTextTmp, luminosityFilterTmp        , &
         &                                                                                       luminosityTypeTmp        , luminosityPostprocessSetTmp
    type            (varying_string               )                            , dimension(5) :: specialFilterWords
    double precision                                              , allocatable, dimension(:) :: luminosityRedshiftTmp    , luminosityBandRedshiftTmp
    class           (stellarPopulationSpectraClass), pointer                                  :: stellarPopulationSpectra_
    class           (cosmologyFunctionsClass      ), pointer                                  :: cosmologyFunctions_
    character       (len=32                       )                                           :: redshiftLabel            , word                     , &
         &                                                                                       wavelengthCentralLabel   , resolutionLabel          , &
         &                                                                                       imfLabel
    character       (len=256                      )                                           :: newFilterName            , lineName
    double precision                                                                          :: outputRedshift           , resolution               , &
         &                                                                                       wavelengthMinimum        , wavelengthMaximum        , &
         &                                                                                       restWavelengthMinimum    , restWavelengthMaximum    , &
         &                                                                                       wavelengthRatio          , wavelengthCentral        , &
         &                                                                                       observedWidth            , restWidth                , &
         &                                                                                       tabulatedWidth           , filterWidth
    integer                                                                                   :: imfIndex
    ! Get cosmology functions.
    cosmologyFunctions_ => cosmologyFunctions()
    ! Get number of output redshifts.
    outputCount=Galacticus_Output_Time_Count()
    ! Iterate over all luminosities.
    i=1
    do while (i <= size(luminosityRedshiftText))
       ! Check for special cases.
       if (luminosityRedshiftText(i) == "all") then
          ! Resize the arrays.
          call Stellar_Luminosities_Expand_Filter_Set( &
               & i                          ,          &
               & outputCount                ,          &
               & luminosityMap              ,          &
               & luminosityRedshiftText     ,          &
               & luminosityFilter           ,          &
               & luminosityType             ,          &
               & luminosityPostprocessSet   ,          &
               & luminosityRedshift         ,          &
               & luminosityBandRedshift     ,          &
               & luminosityMapTmp           ,          &
               & luminosityRedshiftTextTmp  ,          &
               & luminosityFilterTmp        ,          &
               & luminosityTypeTmp          ,          &
               & luminosityPostprocessSetTmp,          &
               & luminosityRedshiftTmp      ,          &
               & luminosityBandRedshiftTmp             &
               &                                     )
          ! Modify new filters.
          do j=1,outputCount
             outputRedshift=Galacticus_Output_Redshift(j)
             write (redshiftLabel,*) outputRedshift
             luminosityRedshiftText   (j+i-1)=redshiftLabel
             luminosityRedshift       (j+i-1)=outputRedshift
             if (luminosityBandRedshiftTmp  (i) <= -2.0d0) then
                luminosityBandRedshift(j+i-1)=outputRedshift
             else
                luminosityBandRedshift(j+i-1)=luminosityBandRedshiftTmp  (i)
             end if
          end do
          deallocate        (luminosityRedshiftTextTmp  )
          deallocate        (luminosityFilterTmp        )
          deallocate        (luminosityTypeTmp          )
          deallocate        (luminosityPostprocessSetTmp)     
          call deallocateArray(luminosityMapTmp           )
          call deallocateArray(luminosityRedshiftTmp      )
          call deallocateArray(luminosityBandRedshiftTmp  )
       end if
       ! Alias for filters required for emission line calculations.
       if (luminosityFilter(i) == "emissionLineFilters") then
          call Stellar_Luminosities_Expand_Filter_Set( &
               & i                          ,          &
               & 2_c_size_t                 ,          &
               & luminosityMap              ,          &
               & luminosityRedshiftText     ,          &
               & luminosityFilter           ,          &
               & luminosityType             ,          &
               & luminosityPostprocessSet   ,          &
               & luminosityRedshift         ,          &
               & luminosityBandRedshift     ,          &
               & luminosityMapTmp           ,          &
               & luminosityRedshiftTextTmp  ,          &
               & luminosityFilterTmp        ,          &
               & luminosityTypeTmp          ,          &
               & luminosityPostprocessSetTmp,          &
               & luminosityRedshiftTmp      ,          &
               & luminosityBandRedshiftTmp             &
               &                                     )
             ! Create new filters.
             luminosityRedshiftText   (i:i+2)=luminosityRedshiftTextTmp  (i)
             luminosityRedshift       (i:i+2)=luminosityRedshiftTmp      (i)
             luminosityBandRedshift   (i:i+2)=luminosityBandRedshiftTmp  (i)
             luminosityPostprocessSet (i:i+2)=luminosityPostprocessSetTmp(i)
             luminosityFilter         (i:i+2)=[var_str("Lyc" ),var_str("HeliumContinuum"),var_str("OxygenContinuum")]
             luminosityType           (i:i+2)=[        "rest" ,        "rest"            ,        "rest"            ]
       end if
       ! Arrays of top-hat filters.
       if (extract(luminosityFilter(i),1,27) == "fixedResolutionTopHatArray_") then
          call String_Split_Words(specialFilterWords,char(luminosityFilter(i)),separator="_")
          word=char(specialFilterWords(2))
          read (word,*) wavelengthMinimum
          word=char(specialFilterWords(3))
          read (word,*) wavelengthMaximum
          word=char(specialFilterWords(4))
          read (word,*) resolution
          ! Determine the ratio of central wavelengths for successive filters.
          wavelengthRatio=                                &
               &  (sqrt(4.0d0*resolution**2+1.0d0)+1.0d0) &
               & /(sqrt(4.0d0*resolution**2+1.0d0)-1.0d0)
          newFilterCount=0
          wavelengthCentral=wavelengthMinimum/((sqrt(4.0d0*resolution**2+1.0d0)-1.0d0)/2.0d0/resolution)
          do while (wavelengthCentral < wavelengthMaximum)
             newFilterCount=newFilterCount+1
             wavelengthCentral=wavelengthCentral*wavelengthRatio
          end do
          ! Resize the arrays.
          call Stellar_Luminosities_Expand_Filter_Set( &
               & i                          ,          &
               & newFilterCount             ,          &
               & luminosityMap              ,          &
               & luminosityRedshiftText     ,          &
               & luminosityFilter           ,          &
               & luminosityType             ,          &
               & luminosityPostprocessSet   ,          &
               & luminosityRedshift         ,          &
               & luminosityBandRedshift     ,          &
               & luminosityMapTmp           ,          &
               & luminosityRedshiftTextTmp  ,          &
               & luminosityFilterTmp        ,          &
               & luminosityTypeTmp          ,          &
               & luminosityPostprocessSetTmp,          &
               & luminosityRedshiftTmp      ,          &
               & luminosityBandRedshiftTmp             &
               &                                     )
          ! Compute central wavelength of the initial filter.
          j=0
          wavelengthCentral=wavelengthMinimum/((sqrt(4.0d0*resolution**2+1.0d0)-1.0d0)/2.0d0/resolution)
          do while (wavelengthCentral < wavelengthMaximum)
             j=j+1
             ! Compute the appropriate filter name.
             write (wavelengthCentralLabel,'(f11.3)') wavelengthCentral
             write (       resolutionLabel,'(f10.2)') resolution
             write (newFilterName,'(a,a,a,a)') "fixedResolutionTopHat_",trim(adjustl(wavelengthCentralLabel)),"_",trim(adjustl(resolutionLabel))
             ! Create new filter.
             luminosityRedshiftText   (j+i-1)=luminosityRedshiftTextTmp  (i)
             luminosityRedshift       (j+i-1)=luminosityRedshiftTmp      (i)
             luminosityBandRedshift   (j+i-1)=luminosityBandRedshiftTmp  (i)
             luminosityFilter         (j+i-1)=trim(newFilterName)
             luminosityType           (j+i-1)=luminosityTypeTmp          (i)
             luminosityPostprocessSet (j+i-1)=luminosityPostprocessSetTmp(i)
             ! Increase the central wavelength.
             wavelengthCentral=wavelengthCentral*wavelengthRatio
          end do
          deallocate        (luminosityRedshiftTextTmp  )
          deallocate        (luminosityFilterTmp        )
          deallocate        (luminosityTypeTmp          )
          deallocate        (luminosityPostprocessSetTmp)     
          call deallocateArray(luminosityMapTmp           )
          call deallocateArray(luminosityRedshiftTmp      )
          call deallocateArray(luminosityBandRedshiftTmp  )
       end if
       ! Arrays of top-hat filters for SEDs
       if (extract(luminosityFilter(i),1,30) == "adaptiveResolutionTopHatArray_") then
          call String_Split_Words(specialFilterWords,char(luminosityFilter(i)),separator="_")
          imfLabel=char(specialFilterWords(2))
          word=char(specialFilterWords(3))
          read (word,*) wavelengthMinimum
          word=char(specialFilterWords(4))
          read (word,*) wavelengthMaximum
          word=char(specialFilterWords(5))
          read (word,*) observedWidth
          ! Set rest wavelength limits and rest wavelength width
          restWavelengthMinimum = wavelengthMinimum/(1.0d0+luminosityRedshift(i))
          restWavelengthMaximum = wavelengthMaximum/(1.0d0+luminosityRedshift(i))
          restWidth = observedWidth/(1.0d0+luminosityRedshift(i))
          ! Extract IMF and list of SPS wavelengths.
          imfIndex = IMF_Index(imfLabel)
          stellarPopulationSpectra_ => stellarPopulationSpectra()
          ! Count number of filters that need to be added.
          newFilterCount = 0
          wavelengthCentral = restWavelengthMinimum
          tabulatedWidth = stellarPopulationSpectra_%wavelengthInterval(imfIndex,wavelengthCentral)
          filterWidth = restWidth
          if(tabulatedWidth.gt.restWidth) filterWidth = tabulatedWidth
          do while (wavelengthCentral < wavelengthMaximum)
             if(wavelengthCentral.lt.wavelengthMaximum) newFilterCount=newFilterCount+1             
             call Stellar_Luminosities_SED_Top_Hat_Step(wavelengthCentral,filterWidth,&
                  wavelengthMinimum,wavelengthMaximum,observedWidth,luminosityRedshift(i),&
                  stellarPopulationSpectra_,imfIndex)
          end do
          ! Resize the arrays.
          call Stellar_Luminosities_Expand_Filter_Set( &
               & i                          ,          &
               & newFilterCount             ,          &
               & luminosityMap              ,          &
               & luminosityRedshiftText     ,          &
               & luminosityFilter           ,          &
               & luminosityType             ,          &
               & luminosityPostprocessSet   ,          &
               & luminosityRedshift         ,          &
               & luminosityBandRedshift     ,          &
               & luminosityMapTmp           ,          &
               & luminosityRedshiftTextTmp  ,          &
               & luminosityFilterTmp        ,          &
               & luminosityTypeTmp          ,          &
               & luminosityPostprocessSetTmp,          &
               & luminosityRedshiftTmp      ,          &
               & luminosityBandRedshiftTmp             &
               &                                     )
          ! Compute central wavelength of the initial filter.
          j=0
          wavelengthCentral = restWavelengthMinimum
          filterWidth = restWidth
          tabulatedWidth = stellarPopulationSpectra_%wavelengthInterval(imfIndex,wavelengthCentral)
          filterWidth = restWidth
          if(tabulatedWidth.gt.restWidth) filterWidth = tabulatedWidth   
          do while (wavelengthCentral < wavelengthMaximum)        
             if(wavelengthCentral.lt.wavelengthMaximum) then
                j=j+1
                ! Compute the appropriate filter name.
                write (wavelengthCentralLabel,'(f11.3)') wavelengthCentral
                write (       resolutionLabel,'(f10.2)') filterWidth
                write (newFilterName,'(a,a,a,a)') "adaptiveResolutionTopHat_",trim(adjustl(wavelengthCentralLabel)),"_",trim(adjustl(resolutionLabel))
                ! Create new filter.
                luminosityRedshiftText   (j+i-1)=luminosityRedshiftTextTmp  (i)
                luminosityRedshift       (j+i-1)=luminosityRedshiftTmp      (i)
                luminosityBandRedshift   (j+i-1)=luminosityBandRedshiftTmp  (i)
                luminosityFilter         (j+i-1)=trim(newFilterName)
                luminosityType           (j+i-1)=luminosityTypeTmp          (i)
                luminosityPostprocessSet (j+i-1)=luminosityPostprocessSetTmp(i)
             end if
             ! Compute central wavelength and width of next top hat filter
             call Stellar_Luminosities_SED_Top_Hat_Step(wavelengthCentral,filterWidth,&
                  wavelengthMinimum,wavelengthMaximum,observedWidth,luminosityRedshift(i),&
                  stellarPopulationSpectra_,imfIndex)
          end do
          deallocate        (luminosityRedshiftTextTmp  )
          deallocate        (luminosityFilterTmp        )
          deallocate        (luminosityTypeTmp          )
          deallocate        (luminosityPostprocessSetTmp)     
          call deallocateArray(luminosityMapTmp           )
          call deallocateArray(luminosityRedshiftTmp      )
          call deallocateArray(luminosityBandRedshiftTmp  )
       end if
       ! Arrays of top-hat filters for equivalent width calculations
       if (extract(luminosityFilter(i),1,26) == "emissionLineContinuumPair_") then
          call String_Split_Words(specialFilterWords,char(luminosityFilter(i)),separator="_")
          lineName=char(specialFilterWords(2))
          ! Determine emission line wavelength         
          wavelengthCentral=emissionLineWavelength(lineName)
          ! Read resolution
          word=char(specialFilterWords(3))
          read (word,*) resolution
          ! Determine minimum and maximum wavelengths to draw filters between
          wavelengthRatio=                                &
               &  (sqrt(4.0d0*resolution**2+1.0d0)+1.0d0) &
               & /(sqrt(4.0d0*resolution**2+1.0d0)-1.0d0)                  
          wavelengthMinimum = wavelengthCentral*(sqrt(4.0d0*resolution**2+1.0d0)-1.0d0)/2.0d0/resolution
          wavelengthMinimum = wavelengthMinimum/wavelengthRatio
          wavelengthMaximum = wavelengthCentral*(sqrt(4.0d0*resolution**2+1.0d0)+1.0d0)/2.0d0/resolution
          wavelengthMaximum = wavelengthMaximum*wavelengthRatio
          ! Determine the ratio of central wavelengths for successive filters.
          newFilterCount=0
          wavelengthCentral=wavelengthMinimum/((sqrt(4.0d0*resolution**2+1.0d0)-1.0d0)/2.0d0/resolution)
          wavelengthCentral = wavelengthCentral/wavelengthRatio
          do k=1,3,1
             if (k == 1 .or. k == 3) newFilterCount=newFilterCount+1
             wavelengthCentral=wavelengthCentral*wavelengthRatio
          end do
          ! Resize the arrays.
          call Stellar_Luminosities_Expand_Filter_Set( &
               & i                          ,          &
               & newFilterCount             ,          &
               & luminosityMap              ,          &
               & luminosityRedshiftText     ,          &
               & luminosityFilter           ,          &
               & luminosityType             ,          &
               & luminosityPostprocessSet   ,          &
               & luminosityRedshift         ,          &
               & luminosityBandRedshift     ,          &
               & luminosityMapTmp           ,          &
               & luminosityRedshiftTextTmp  ,          &
               & luminosityFilterTmp        ,          &
               & luminosityTypeTmp          ,          &
               & luminosityPostprocessSetTmp,          &
               & luminosityRedshiftTmp      ,          &
               & luminosityBandRedshiftTmp             &
               &                                     )
          ! Compute central wavelength of the initial filter.
          j=0
          wavelengthCentral=wavelengthMinimum/((sqrt(4.0d0*resolution**2+1.0d0)-1.0d0)/2.0d0/resolution)
          !wavelengthCentral = wavelengthCentral/wavelengthRatio
          do k = 1,3,1
             ! Compute the appropriate filter name.
             write (wavelengthCentralLabel,'(f11.3)') wavelengthCentral
             write (       resolutionLabel,'(f10.2)') resolution
             write (newFilterName,'(a,a,a,a,a,a)') "emissionLineContinuumBracketed_",trim(adjustl(lineName)),&
                  "_",trim(adjustl(wavelengthCentralLabel)),"_",trim(adjustl(resolutionLabel))             
             ! Create new filter.
             if (k == 1 .or. k == 3) then
                j=j+1
                luminosityRedshiftText   (j+i-1)=luminosityRedshiftTextTmp  (i)
                luminosityRedshift       (j+i-1)=luminosityRedshiftTmp      (i)
                luminosityBandRedshift   (j+i-1)=luminosityBandRedshiftTmp  (i)
                luminosityFilter         (j+i-1)=trim(newFilterName)
                luminosityType           (j+i-1)=luminosityTypeTmp          (i)
                luminosityPostprocessSet (j+i-1)=luminosityPostprocessSetTmp(i)
             end if
             ! Increase the central wavelength.
             wavelengthCentral=wavelengthCentral*wavelengthRatio
          end do
          deallocate        (luminosityRedshiftTextTmp  )
          deallocate        (luminosityFilterTmp        )
          deallocate        (luminosityTypeTmp          )
          deallocate        (luminosityPostprocessSetTmp)     
          call deallocateArray(luminosityMapTmp           )
          call deallocateArray(luminosityRedshiftTmp      )
          call deallocateArray(luminosityBandRedshiftTmp  )
       end if
       ! Next luminosity.      
       i=i+1       
    end do
    return
  end subroutine Stellar_Luminosities_Special_Cases

  subroutine Stellar_Luminosities_Expand_Filter_Set( &
       & expandFrom                 ,                &
       & expandCount                ,                &
       & luminosityMap              ,                &
       & luminosityRedshiftText     ,                &
       & luminosityFilter           ,                &
       & luminosityType             ,                &
       & luminosityPostprocessSet   ,                &
       & luminosityRedshift         ,                &
       & luminosityBandRedshift     ,                &
       & luminosityMapTmp           ,                &
       & luminosityRedshiftTextTmp  ,                &
       & luminosityFilterTmp        ,                &
       & luminosityTypeTmp          ,                &
       & luminosityPostprocessSetTmp,                &
       & luminosityRedshiftTmp      ,                &
       & luminosityBandRedshiftTmp                   &
       &                                           )
    !% Expand the filter set by removing the filter at index {\normalfont \ttfamily expandFrom} by adding {\normalfont \ttfamily expandCount} replicas of the filter at that point.
    use, intrinsic :: ISO_C_Binding
    use Memory_Management
    implicit none
    integer         (c_size_t      ), intent(in   )                            :: expandFrom               , expandCount
    integer                         , intent(inout), allocatable, dimension(:) :: luminosityMap
    type            (varying_string), intent(inout), allocatable, dimension(:) :: luminosityRedshiftText   , luminosityFilter           , &
         &                                                                        luminosityType           , luminosityPostprocessSet
    double precision                , intent(inout), allocatable, dimension(:) :: luminosityRedshift       , luminosityBandRedshift
    integer                         , intent(inout), allocatable, dimension(:) :: luminosityMapTmp
    type            (varying_string), intent(inout), allocatable, dimension(:) :: luminosityRedshiftTextTmp, luminosityFilterTmp        , &
         &                                                                        luminosityTypeTmp        , luminosityPostprocessSetTmp
    double precision                , intent(inout), allocatable, dimension(:) :: luminosityRedshiftTmp    , luminosityBandRedshiftTmp
    integer                                                                    :: luminosityCount

    luminosityCount=size(luminosityMap)
    call Move_Alloc (luminosityMap           ,luminosityMapTmp           )
    call Move_Alloc (luminosityRedshiftText  ,luminosityRedshiftTextTmp  )
    call Move_Alloc (luminosityRedshift      ,luminosityRedshiftTmp      )
    call Move_Alloc (luminosityBandRedshift  ,luminosityBandRedshiftTmp  )
    call Move_Alloc (luminosityFilter        ,luminosityFilterTmp        )
    call Move_Alloc (luminosityType          ,luminosityTypeTmp          )
    call Move_Alloc (luminosityPostprocessSet,luminosityPostprocessSetTmp)
    allocate        (luminosityRedshiftText   (size(luminosityRedshiftTextTmp  )+expandCount-1))
    allocate        (luminosityFilter         (size(luminosityFilterTmp        )+expandCount-1))
    allocate        (luminosityType           (size(luminosityTypeTmp          )+expandCount-1))
    allocate        (luminosityPostprocessSet (size(luminosityPostprocessSetTmp)+expandCount-1))
    call allocateArray(luminosityMap           ,[size(luminosityRedshiftTmp      )+expandCount-1])
    call allocateArray(luminosityRedshift      ,[size(luminosityRedshiftTmp      )+expandCount-1])
    call allocateArray(luminosityBandRedshift  ,[size(luminosityBandRedshiftTmp  )+expandCount-1])
    if (expandFrom > 1              ) then
       luminosityMap           (1            :expandFrom                          -1)=luminosityMapTmp           (1  :expandFrom-1            )
       luminosityRedshiftText  (1            :expandFrom                          -1)=luminosityRedshiftTextTmp  (1  :expandFrom-1            )
       luminosityRedshift      (1            :expandFrom                          -1)=luminosityRedshiftTmp      (1  :expandFrom-1            )
       luminosityBandRedshift  (1            :expandFrom                          -1)=luminosityBandRedshiftTmp  (1  :expandFrom-1            )
       luminosityFilter        (1            :expandFrom                          -1)=luminosityFilterTmp        (1  :expandFrom-1            )
       luminosityType          (1            :expandFrom                          -1)=luminosityTypeTmp          (1  :expandFrom-1            )
       luminosityPostprocessSet(1            :expandFrom                          -1)=luminosityPostprocessSetTmp(1  :expandFrom-1            )
    end if
    if (expandFrom < luminosityCount) then
       luminosityMap           (expandFrom+expandCount:luminosityCount+expandCount-1)=luminosityMapTmp           (expandFrom+1:luminosityCount)
       luminosityRedshiftText  (expandFrom+expandCount:luminosityCount+expandCount-1)=luminosityRedshiftTextTmp  (expandFrom+1:luminosityCount)
       luminosityRedshift      (expandFrom+expandCount:luminosityCount+expandCount-1)=luminosityRedshiftTmp      (expandFrom+1:luminosityCount)
       luminosityBandRedshift  (expandFrom+expandCount:luminosityCount+expandCount-1)=luminosityBandRedshiftTmp  (expandFrom+1:luminosityCount)
       luminosityFilter        (expandFrom+expandCount:luminosityCount+expandCount-1)=luminosityFilterTmp        (expandFrom+1:luminosityCount)
       luminosityType          (expandFrom+expandCount:luminosityCount+expandCount-1)=luminosityTypeTmp          (expandFrom+1:luminosityCount)
       luminosityPostprocessSet(expandFrom+expandCount:luminosityCount+expandCount-1)=luminosityPostprocessSetTmp(expandFrom+1:luminosityCount)
    end if
    luminosityMap              (expandFrom            :expandFrom     +expandCount-1)=luminosityMapTmp           (expandFrom                  )
    luminosityRedshiftText     (expandFrom            :expandFrom     +expandCount-1)=luminosityRedshiftTextTmp  (expandFrom                  )
    luminosityRedshift         (expandFrom            :expandFrom     +expandCount-1)=luminosityRedshiftTmp      (expandFrom                  )
    luminosityBandRedshift     (expandFrom            :expandFrom     +expandCount-1)=luminosityBandRedshiftTmp  (expandFrom                  )
    luminosityFilter           (expandFrom            :expandFrom     +expandCount-1)=luminosityFilterTmp        (expandFrom                  )
    luminosityType             (expandFrom            :expandFrom     +expandCount-1)=luminosityTypeTmp          (expandFrom                  )
    luminosityPostprocessSet   (expandFrom            :expandFrom     +expandCount-1)=luminosityPostprocessSetTmp(expandFrom                  )
    return
  end subroutine Stellar_Luminosities_Expand_Filter_Set

  subroutine Stellar_Luminosities_Truncate(self,templateLuminosities)
    !% Truncate (or pad) the stellar luminosities to match the number in the given {\normalfont \ttfamily templateLuminosities}.
    implicit none
    class           (stellarLuminosities), intent(inout)               :: self
    type            (stellarLuminosities), intent(in   )               :: templateLuminosities
    double precision                     , allocatable  , dimension(:) :: luminositiesTmp
    integer                                                            :: templateCount       , selfCount, &
         &                                                                minCount
    
    if (allocated(templateLuminosities%luminosityValue)) then
       templateCount=size(templateLuminosities%luminosityValue)
       if (allocated(self%luminosityValue)) then
          ! Our luminosities are allocated. Check size.
          selfCount=size(self%luminosityValue)
          if (selfCount /= templateCount) then
             ! Size does not match template. Reallocate and pad as necessary.
             minCount=min(templateCount,selfCount)
             call Move_Alloc(self%luminosityValue,luminositiesTmp)
             allocate(self%luminosityValue(templateCount))
             self%luminosityValue(1:minCount)=luminositiesTmp(1:minCount)
             if (templateCount > selfCount) self%luminosityValue(selfCount+1:templateCount)=0.0d0
             deallocate(luminositiesTmp)
          end if
       else
          ! Our luminosities are not allocated. Allocate and set to zero.
          allocate(self%luminosityValue(templateCount))
          self%luminosityValue=0.0d0
       end if
    else if (allocated(self%luminosityValue)) then
       ! Template luminosities are not allocated, simply deallocate our luminosities to match.
       deallocate(self%luminosityValue)
    end if
    return
  end subroutine Stellar_Luminosities_Truncate

  subroutine Stellar_Luminosities_Parameter_Map_Double(parameters)
    !% Map an array of luminosity-related input parameters into a new array accounting for special case processing.
    use Memory_Management
    implicit none
    double precision, intent(inout), allocatable, dimension(:) :: parameters
    double precision               , allocatable, dimension(:) :: parametersMapped
    integer                                                    :: i
    
    ! Ensure module is initialized.
    call Stellar_Luminosities_Initialize()
    ! Allocate new array.
    call allocateArray(parametersMapped,[luminosityCount])
    ! Map from the old array.
    do i=1,luminosityCount
       parametersMapped(i)=parameters(luminosityMap(i))
    end do
    ! Copy the new array.
    call deallocateArray(parameters)
    call Move_Alloc(parametersMapped,parameters)
    return
  end subroutine Stellar_Luminosities_Parameter_Map_Double
  
  !# <galacticusStateStoreTask>
  !#  <unitName>Stellar_Luminosities_State_Store</unitName>
  !# </galacticusStateStoreTask>
  subroutine Stellar_Luminosities_State_Store(stateFile,fgslStateFile,stateOperationID)
    !% Write the luminosities state to file.
    use, intrinsic :: ISO_C_Binding
    use            :: Galacticus_Display
    use            :: FGSL
    use            :: String_Handling
    use            :: ISO_Varying_String
    implicit none
    integer           , intent(in   ) :: stateFile
    integer(c_size_t ), intent(in   ) :: stateOperationID
    type   (fgsl_file), intent(in   ) :: fgslStateFile
    integer                           :: i
    !GCC$ attributes unused :: fgslStateFile, stateOperationID

    call Galacticus_Display_Indent  (var_str('storing state for "stellar luminosities" [position: ')//FTell(stateFile)//']',verbosity=verbosityWorking)
    write (stateFile) luminositiesInitialized
    if (luminositiesInitialized) then
       call Galacticus_Display_Message(var_str('storing "luminosityCount" [position: ')//FTell(stateFile)//']',verbosity=verbosityWorking)
       write (stateFile) luminosityCount
       call Galacticus_Display_Message(var_str('storing luminosities [position: ')//FTell(stateFile)//']',verbosity=verbosityWorking)
       write (stateFile) luminosityIndex,luminosityCosmicTime,luminosityRedshift,luminosityBandRedshift
       do i=1,luminosityCount
          call Galacticus_Display_Message(var_str('storing luminosity ')//i//' of '//luminosityCount//' [position: '//FTell(stateFile)//']',verbosity=verbosityWorking)
          call luminosityName          (i)%stateStore(stateFile)
          call luminosityType          (i)%stateStore(stateFile)
          call luminosityFilter        (i)%stateStore(stateFile)
          call luminosityPostprocessSet(i)%stateStore(stateFile)
       end do
    end if
    call Galacticus_Display_Unindent(var_str('done [position: ')//FTell(stateFile)//']'                                    ,verbosity=verbosityWorking)
   return
  end subroutine Stellar_Luminosities_State_Store

  !# <galacticusStateRetrieveTask>
  !#  <unitName>Stellar_Luminosities_State_Restore</unitName>
  !# </galacticusStateRetrieveTask>
  subroutine Stellar_Luminosities_State_Restore(stateFile,fgslStateFile,stateOperationID)
    !% Retrieve the luminosities state from the file.
    use, intrinsic :: ISO_C_Binding
    use            :: Galacticus_Display
    use            :: Instruments_Filters
    use            :: Stellar_Population_Spectra_Postprocess
    use            :: FGSL
    use            :: String_Handling
    use            :: ISO_Varying_String
    implicit none
    integer           , intent(in   ) :: stateFile
    integer(c_size_t ), intent(in   ) :: stateOperationID
    type   (fgsl_file), intent(in   ) :: fgslStateFile
    integer                           :: i
    !GCC$ attributes unused :: fgslStateFile, stateOperationID

    call Galacticus_Display_Indent  (var_str('restoring state for "stellar luminosities" [position: ')//FTell(stateFile)//']',verbosity=verbosityWorking)
    read (stateFile) luminositiesInitialized
    if (allocated(luminosityFilterIndex                  )) deallocate(luminosityFilterIndex                  )
    if (allocated(luminosityIndex                        )) deallocate(luminosityIndex                        )
    if (allocated(luminosityPostprocessingChainIndex     )) deallocate(luminosityPostprocessingChainIndex     )
    if (allocated(luminosityCosmicTime                   )) deallocate(luminosityCosmicTime                   )
    if (allocated(luminosityRedshift                     )) deallocate(luminosityRedshift                     )
    if (allocated(luminosityBandRedshift                 )) deallocate(luminosityBandRedshift                 )
    if (allocated(luminosityName                         )) deallocate(luminosityName                         )
    if (allocated(luminosityType                         )) deallocate(luminosityType                         )
    if (allocated(luminosityFilter                       )) deallocate(luminosityFilter                       )
    if (allocated(luminosityPostprocessSet               )) deallocate(luminosityPostprocessSet               )
    if (allocated(unitStellarLuminosities%luminosityValue)) deallocate(unitStellarLuminosities%luminosityValue)
    if (allocated(zeroStellarLuminosities%luminosityValue)) deallocate(zeroStellarLuminosities%luminosityValue)
    if (luminositiesInitialized) then
       call Galacticus_Display_Message(var_str('restoring "luminosityCount" [position: ')//FTell(stateFile)//']',verbosity=verbosityWorking)
       read (stateFile) luminosityCount
       allocate(luminosityFilterIndex                  (luminosityCount))
       allocate(luminosityIndex                        (luminosityCount))
       allocate(luminosityPostprocessingChainIndex     (luminosityCount))
       allocate(luminosityCosmicTime                   (luminosityCount))
       allocate(luminosityRedshift                     (luminosityCount))
       allocate(luminosityBandRedshift                 (luminosityCount))
       allocate(luminosityName                         (luminosityCount))
       allocate(luminosityType                         (luminosityCount))
       allocate(luminosityFilter                       (luminosityCount))
       allocate(luminosityPostprocessSet               (luminosityCount))
       allocate(unitStellarLuminosities%luminosityValue(luminosityCount))
       allocate(zeroStellarLuminosities%luminosityValue(luminosityCount))
       unitStellarLuminosities%luminosityValue=1.0d0
       zeroStellarLuminosities%luminosityValue=0.0d0
       call Galacticus_Display_Message(var_str('restoring luminosities [position: ')//FTell(stateFile)//']',verbosity=verbosityWorking)
       read (stateFile) luminosityIndex,luminosityCosmicTime,luminosityRedshift,luminosityBandRedshift
       do i=1,luminosityCount
          call Galacticus_Display_Message(var_str('restoring luminosity ')//i//' of '//luminosityCount//' [position: '//FTell(stateFile)//']',verbosity=verbosityWorking)
          call luminosityName          (i)%stateRestore(stateFile)
          call luminosityType          (i)%stateRestore(stateFile)
          call luminosityFilter        (i)%stateRestore(stateFile)
          call luminosityPostprocessSet(i)%stateRestore(stateFile)
          luminosityFilterIndex             (i)=Filter_Get_Index                             (luminosityFilter        (i))
          luminosityPostprocessingChainIndex(i)=Stellar_Population_Spectrum_Postprocess_Index(luminosityPostprocessSet(i))
       end do
    end if
    call Galacticus_Display_Unindent(var_str('done [position: ')//FTell(stateFile)//']'                                      ,verbosity=verbosityWorking)
    return
  end subroutine Stellar_Luminosities_State_Restore

end module Stellar_Luminosities_Structure
