!! Copyright 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017
!!    Andrew Benson <abenson@carnegiescience.edu>
!!
!! This file is part of Galacticus.
!!
!!    Galacticus is free software: you can redistribute it and/or modify
!!    it under the terms of the GNU General Public License as published by
!!    the Free Software Foundation, either version 3 of the License, or
!!    (at your option) any later version.
!!
!!    Galacticus is distributed in the hope that it will be useful,
!!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!!    GNU General Public License for more details.
!!
!!    You should have received a copy of the GNU General Public License
!!    along with Galacticus.  If not, see <http://www.gnu.org/licenses/>.

!% Contains a module which implements calculations of branching probabilties in generalized Press-Schechter theory.

module Generalized_Press_Schechter_Branching
  !% Implements calculations of branching probabilties in generalized Press-Schechter theory.
  use Cosmological_Mass_Variance
  use Numerical_Constants_Math
  implicit none
  private
  public :: Generalized_Press_Schechter_Branching_Initialize

  ! Parent halo shared variables.
  double precision            :: parentDTimeDDeltaCritical                                   , parentDelta    , &
       &                         parentHaloMass                                              , parentSigma    , &
       &                         parentSigmaSquared                                          , parentTime     , &
       &                         probabilityMinimumMass                                      , probabilitySeek
  !$omp threadprivate(parentHaloMass,parentTime,parentDTimeDDeltaCritical,parentSigma,parentSigmaSquared,parentDelta,probabilitySeek,probabilityMinimumMass)
  ! Accuracy parameter to ensure that steps in critical overdensity do not become too large.
  double precision            :: generalizedPressSchechterDeltaStepMaximum

  ! Minimum mass to which subresolution fractions will be integrated.
  double precision            :: generalizedPressSchechterMinimumMass

  ! Precomputed numerical factors.
  double precision, parameter :: sqrtTwoOverPi                                =sqrt(2.0d0/Pi)

  ! Branching probability integrand integration tolerance.
  double precision, parameter :: branchingProbabilityIntegrandToleraceRelative=1.0d-2

  ! The maximum sigma that we expect to find.
  double precision            :: sigmaMaximum

  ! Record of whether we have tested the excursion set routines.
  logical                     :: excursionSetsTested                          =.false.

  ! Control for inclusion of smooth accretion rates.
  logical                     :: generalizedPressSchechterSmoothAccretion

  ! Record of issued warnings.
  logical                     :: subresolutionFractionIntegrandFailureWarned  =.false.

contains

  !# <treeBranchingMethod>
  !#  <unitName>Generalized_Press_Schechter_Branching_Initialize</unitName>
  !# </treeBranchingMethod>
  subroutine Generalized_Press_Schechter_Branching_Initialize(treeBranchingMethod,Tree_Branching_Probability_Bound,Tree_Branching_Probability&
       &,Tree_Subresolution_Fraction,Tree_Branch_Mass,Tree_Maximum_Step)
    !% Initialize the generalized Press-Schechter branching routines.
    use Input_Parameters
    use ISO_Varying_String
    implicit none
    type     (varying_string  ), intent(in   )          :: treeBranchingMethod
    procedure(Generalized_Press_Schechter_Branching_Probability_Bound), intent(inout), pointer :: Tree_Branching_Probability_Bound
    procedure(Generalized_Press_Schechter_Branching_Probability), intent(inout), pointer :: Tree_Branching_Probability
    procedure(Generalized_Press_Schechter_Subresolution_Fraction), intent(inout), pointer :: Tree_Subresolution_Fraction
    procedure(Generalized_Press_Schechter_Branch_Mass), intent(inout), pointer :: Tree_Branch_Mass
    procedure(Generalized_Press_Schechter_Branching_Maximum_Step), intent(inout), pointer :: Tree_Maximum_Step

    if (treeBranchingMethod == 'generalizedPress-Schechter') then
       Tree_Branching_Probability_Bound => Generalized_Press_Schechter_Branching_Probability_Bound
       Tree_Branching_Probability       => Generalized_Press_Schechter_Branching_Probability
       Tree_Subresolution_Fraction      => Generalized_Press_Schechter_Subresolution_Fraction
       Tree_Branch_Mass                 => Generalized_Press_Schechter_Branch_Mass
       Tree_Maximum_Step                => Generalized_Press_Schechter_Branching_Maximum_Step
       !# <inputParameter>
       !#   <name>generalizedPressSchechterDeltaStepMaximum</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>0.1d0</defaultValue>
       !#   <description>Limits the step in $\delta_{\mathrm crit}$ when constructing merger trees using the generalized Press-Schechter branching algorithm.</description>
       !#   <source>globalParameters</source>
       !#   <type>real</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>generalizedPressSchechterMinimumMass</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>1.0d6</defaultValue>
       !#   <description>The minimum mass to used in computing subresolution accretion rates when constructing merger trees using the generalized Press-Schechter branching algorithm.</description>
       !#   <source>globalParameters</source>
       !#   <type>real</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>generalizedPressSchechterSmoothAccretion</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>.true.</defaultValue>
       !#   <description>Specifies whether or not to include smooth accretion in subresolution accretion rates when constructing merger trees using the generalized Press-Schechter branching algorithm.</description>
       !#   <source>globalParameters</source>
       !#   <type>boolean</type>
       !# </inputParameter>
    end if
    return
  end subroutine Generalized_Press_Schechter_Branching_Initialize

  subroutine Excursion_Sets_Maximum_Sigma_Test()
    !% Make a call to excursion set routines with the maximum $\sigma$ that we will use to ensure that they can handle it.
    use Excursion_Sets_First_Crossings
    use Cosmology_Functions
    implicit none
    class           (cosmologyFunctionsClass       ), pointer :: cosmologyFunctions_
    class           (cosmologicalMassVarianceClass ), pointer :: cosmologicalMassVariance_
    class           (excursionSetFirstCrossingClass), pointer :: excursionSetFirstCrossing_
    double precision                                          :: presentTime               , testResult, &
         &                                                       varianceMaximum
    
    if (.not.excursionSetsTested) then
       !$omp critical (Excursion_Sets_Maximum_Sigma_Test)
       if (.not.excursionSetsTested) then
          ! Get required objects.
          cosmologyFunctions_        => cosmologyFunctions       ()
          cosmologicalMassVariance_  => cosmologicalMassVariance ()
          excursionSetFirstCrossing_ => excursionSetFirstCrossing()
          presentTime    =cosmologyFunctions_      %cosmicTime  (1.0d0                               )
          sigmaMaximum   =cosmologicalMassVariance_%rootVariance(generalizedPressSchechterMinimumMass)
          varianceMaximum=sigmaMaximum**2
          testResult     =excursionSetFirstCrossing_%probability(                      varianceMaximum,presentTime)
          testResult     =excursionSetFirstCrossing_%rate       (0.5d0*varianceMaximum,varianceMaximum,presentTime)
          excursionSetsTested=.true.
       end if
       !$omp end critical (Excursion_Sets_Maximum_Sigma_Test)
    end if
    return
  end subroutine Excursion_Sets_Maximum_Sigma_Test

  double precision function Generalized_Press_Schechter_Branch_Mass(haloMass,deltaCritical,massResolution,probability,randomNumberGenerator)
    !% Determine the mass of one of the halos to which the given halo branches, given the branching probability,
    !% {\normalfont \ttfamily probability}. Typically, {\normalfont \ttfamily probabilityFraction} is found by multiplying {\tt
    !% Generalized\_Press\_Schechter\_Branching\_Probability()} by a random variable drawn in the interval 0--1 if a halo
    !% branches. This routine then finds the progenitor mass corresponding to this value.
    use Pseudo_Random
    use ISO_Varying_String
    use Root_Finder
    use Galacticus_Display
    use Galacticus_Error
    implicit none
    double precision                               , intent(in   ) :: deltaCritical                   , haloMass                , &
         &                                                            massResolution                  , probability
    type            (pseudoRandom                 ), intent(inout) :: randomNumberGenerator
    class           (cosmologicalMassVarianceClass), pointer       :: cosmologicalMassVariance_
    double precision                               , parameter     :: toleranceAbsolute        =0.0d0 , toleranceRelative=1.0d-9
    double precision                               , parameter     :: smallProbabilityFraction =1.0d-3
    type            (varying_string               )                :: message
    character       (len=26                       )                :: label
    type            (rootFinder                   ), save          :: finder
    !$omp threadprivate(finder)
    !GCC$ attributes unused :: randomNumberGenerator
    
    ! Get required objects.
    cosmologicalMassVariance_ => cosmologicalMassVariance()
    ! Ensure excursion set calculations have sufficient range in sigma.
    call Excursion_Sets_Maximum_Sigma_Test()
    ! Initialize global variables.
    parentHaloMass        =                                       haloMass
    parentSigma           =cosmologicalMassVariance_%rootVariance(haloMass)
    parentDelta           =deltaCritical
    probabilityMinimumMass=massResolution
    probabilitySeek       =probability
    call Compute_Common_Factors
    ! Initialize our root finder.
    if (.not.finder%isInitialized()) then
       call finder%rootFunction(Generalized_Press_Schechter_Branch_Mass_Root)
       call finder%tolerance   (toleranceAbsolute,toleranceRelative         )
    end if
    ! Check that the root is bracketed.
    if     (                                                                &
         &     Generalized_Press_Schechter_Branch_Mass_Root(massResolution) &
         &    *Generalized_Press_Schechter_Branch_Mass_Root(0.5d0*haloMass) &
         &  >=                                                              &
         &    0.0d0                                                         &
         & ) then
       ! Warn about this situation.
       if (Galacticus_Verbosity_Level() >= verbosityWarn) then
          message="halo branching mass root is not bracketed in Generalized_Press_Schechter_Branch_Mass()"
          call Galacticus_Display_Message(message,verbosityWarn)
          write (label,'(e12.6,a1,e12.6)') massResolution,":",Generalized_Press_Schechter_Branch_Mass_Root(massResolution)
          message=" => massMinimum:rootFunction(massMinimum) = "//trim(label)
          call Galacticus_Display_Message(message,verbosityWarn)
          write (label,'(e12.6,a1,e12.6)') 0.5d0*haloMass,":",Generalized_Press_Schechter_Branch_Mass_Root(0.5d0*haloMass)
          message=" => massMaximum:rootFunction(massMaximum) = "//trim(label)
          call Galacticus_Display_Message(message,verbosityWarn)
          write (label,'(e12.6)') probability
          message=" =>                           probability = "//trim(label)
          call Galacticus_Display_Message(message,verbosityWarn)
       end if
       ! If the root function is positive at half of the parent halo mass then we have a binary split.
       if (Generalized_Press_Schechter_Branch_Mass_Root(0.5d0*haloMass) >= 0.0d0) then
          ! Check that we are sufficiently close to zero. If we're not, it might indicate a problem.
          if     (                                                                                     &
               &   Generalized_Press_Schechter_Branch_Mass_Root(0.5d0*haloMass)                        &
               &  >                                                                                    &
               &   probability*smallProbabilityFraction                                                &
               & ) call Galacticus_Error_Report(                                                       &
               &                                "Generalized_Press_Schechter_Branch_Mass()"          , &
               &                                "numerical accuracy lost in root finding calculation"  &
               &                               )
          ! Return a binary split mass.
          Generalized_Press_Schechter_Branch_Mass=0.5d0*haloMass
          return
       end if
    end if
    ! Find the branch mass.
    Generalized_Press_Schechter_Branch_Mass=finder%find(rootRange=[massResolution,0.5d0*haloMass])
    return
  end function Generalized_Press_Schechter_Branch_Mass

  double precision function Generalized_Press_Schechter_Branch_Mass_Root(massMaximum)
    use Numerical_Integration
    implicit none
    double precision                            , intent(in   ) :: massMaximum
    type            (fgsl_function             )                :: integrandFunction
    type            (fgsl_integration_workspace)                :: integrationWorkspace

    Generalized_Press_Schechter_Branch_Mass_Root=probabilitySeek-Integrate(probabilityMinimumMass,massMaximum &
         &,Branching_Probability_Integrand_Generalized,integrandFunction,integrationWorkspace,toleranceAbsolute&
         &=0.0d0 ,toleranceRelative=branchingProbabilityIntegrandToleraceRelative,integrationRule=FGSL_Integ_Gauss15)
    call Integrate_Done(integrandFunction,integrationWorkspace)
    return
  end function Generalized_Press_Schechter_Branch_Mass_Root

  double precision function Generalized_Press_Schechter_Branching_Maximum_Step(haloMass,deltaCritical,massResolution)
    !% Return the maximum allowed step in $\delta_{\mathrm crit}$ that a halo of mass {\normalfont \ttfamily haloMass} at time {\tt
    !% deltaCritical} should be allowed to take.
    implicit none
    double precision, intent(in   ) :: deltaCritical, haloMass, massResolution
    !GCC$ attributes unused :: deltaCritical, haloMass, massResolution
    
    Generalized_Press_Schechter_Branching_Maximum_Step=generalizedPressSchechterDeltaStepMaximum
    return
  end function Generalized_Press_Schechter_Branching_Maximum_Step

  double precision function Generalized_Press_Schechter_Branching_Probability_Bound(haloMass,deltaCritical,massResolution,bound)
    !% Return bounds onthe probability per unit change in $\delta_{\mathrm crit}$ that a halo of mass {\normalfont \ttfamily haloMass} at time {\tt
    !% deltaCritical} will undergo a branching to progenitors with mass greater than {\normalfont \ttfamily massResolution}.
    implicit none
    double precision, intent(in   ) :: deltaCritical, haloMass, massResolution
    integer         , intent(in   ) :: bound
    !GCC$ attributes unused :: bound
    
    Generalized_Press_Schechter_Branching_Probability_Bound=Generalized_Press_Schechter_Branching_Probability(haloMass,deltaCritical,massResolution)
    return
  end function Generalized_Press_Schechter_Branching_Probability_Bound

  double precision function Generalized_Press_Schechter_Branching_Probability(haloMass,deltaCritical,massResolution)
    !% Return the probability per unit change in $\delta_{\mathrm crit}$ that a halo of mass {\normalfont \ttfamily haloMass} at time {\tt
    !% deltaCritical} will undergo a branching to progenitors with mass greater than {\normalfont \ttfamily massResolution}.
    use Numerical_Integration
    implicit none
    double precision                               , intent(in   ) :: deltaCritical            , haloMass   , massResolution
    class           (cosmologicalMassVarianceClass), pointer       :: cosmologicalMassVariance_
    type            (fgsl_function                )                :: integrandFunction
    type            (fgsl_integration_workspace   )                :: integrationWorkspace
    double precision                                               :: massMaximum              , massMinimum

    call Excursion_Sets_Maximum_Sigma_Test()
    ! Get sigma and delta_critical for the parent halo.
    if (haloMass>2.0d0*massResolution) then
       cosmologicalMassVariance_ => cosmologicalMassVariance()
       parentHaloMass           =                                       haloMass
       parentSigma              =cosmologicalMassVariance_%rootVariance(haloMass)
       parentDelta              =deltaCritical
       call Compute_Common_Factors
       massMinimum=massResolution
       massMaximum=0.5d0*parentHaloMass
       Generalized_Press_Schechter_Branching_Probability=Integrate(massMinimum,massMaximum,Branching_Probability_Integrand_Generalized &
            &,integrandFunction,integrationWorkspace,toleranceAbsolute=0.0d0,toleranceRelative=branchingProbabilityIntegrandToleraceRelative&
            &,integrationRule=FGSL_Integ_Gauss15)
       call Integrate_Done(integrandFunction,integrationWorkspace)
    else
       Generalized_Press_Schechter_Branching_Probability=0.0d0
    end if
    return
  end function Generalized_Press_Schechter_Branching_Probability

  double precision function Generalized_Press_Schechter_Subresolution_Fraction(haloMass,deltaCritical,massResolution)
    !% Return the fraction of mass accreted in subresolution halos, i.e. those below {\normalfont \ttfamily massResolution}, per unit change in
    !% $\delta_{\mathrm crit}$ for a halo of mass {\normalfont \ttfamily haloMass} at time {\normalfont \ttfamily deltaCritical}. The integral is computed numerically.
    use Numerical_Integration
    use Excursion_Sets_First_Crossings
    use Merger_Tree_Branching_Modifiers
    use Galacticus_Error
    use ISO_Varying_String
    use Galacticus_Display
    implicit none
    double precision                                , intent(in   ) :: deltaCritical                                 , haloMass       , &
         &                                                             massResolution
    class           (cosmologicalMassVarianceClass ), pointer       :: cosmologicalMassVariance_
    class           (excursionSetFirstCrossingClass), pointer       :: excursionSetFirstCrossing_
    double precision                                , save          :: massResolutionPrevious                 =-1.0d0, resolutionSigma
    !$omp threadprivate(resolutionSigma,massResolutionPrevious)
    double precision                                , parameter     :: resolutionSigmaOverParentSigmaTolerance=1.0d-3
    double precision                                                :: massMaximum                                   , massMinimum    , &
         &                                                             resolutionSigmaOverParentSigma
    type            (fgsl_function                 )                :: integrandFunction
    type            (fgsl_integration_workspace    )                :: integrationWorkspace
    integer                                                         :: errorStatus
    type            (varying_string                )                :: message

    call Excursion_Sets_Maximum_Sigma_Test()
    ! Get required objects.
    cosmologicalMassVariance_  => cosmologicalMassVariance ()
    excursionSetFirstCrossing_ => excursionSetFirstCrossing()
   ! Get sigma and delta_critical for the parent halo.
    parentHaloMass           =                                       haloMass
    parentSigma              =cosmologicalMassVariance_%rootVariance(haloMass)
    parentDelta              =deltaCritical
    call Compute_Common_Factors

    ! If requested, compute the rate of smooth accretion.
    if (generalizedPressSchechterSmoothAccretion) then
       Generalized_Press_Schechter_Subresolution_Fraction=abs(parentDTimeDDeltaCritical)*Merger_Tree_Branching_Modifier(parentDelta&
            &,sigmaMaximum,parentSigma)*excursionSetFirstCrossing_%rateNonCrossing(parentSigmaSquared,parentTime)
    else
       Generalized_Press_Schechter_Subresolution_Fraction=0.0d0
    end if

    if (massResolution /= massResolutionPrevious) then
       resolutionSigma       =cosmologicalMassVariance_%rootVariance(massResolution)
       massResolutionPrevious=massResolution
    end if
    resolutionSigmaOverParentSigma=resolutionSigma/parentSigma
    if (resolutionSigmaOverParentSigma >= 1.0d0) then
       massMinimum=generalizedPressSchechterMinimumMass
       massMaximum=massResolution
       Generalized_Press_Schechter_Subresolution_Fraction=Generalized_Press_Schechter_Subresolution_Fraction&
            &+Integrate(massMinimum,massMaximum,Subresolution_Fraction_Integrand_Generalized,integrandFunction&
            &,integrationWorkspace,toleranceAbsolute=0.0d0,toleranceRelative=1.0d-3 ,integrationRule=FGSL_Integ_Gauss15&
            &,errorStatus=errorStatus)
       call Integrate_Done(integrandFunction,integrationWorkspace)
       if (errorStatus /= errorStatusSuccess) then
          if (resolutionSigmaOverParentSigma < 1.0d0+resolutionSigmaOverParentSigmaTolerance) then
             Generalized_Press_Schechter_Subresolution_Fraction=-1.0d0
          else
             ! Attempt the integral again with lower tolerance. Issue a warnings if this is the first time this has happened.
             if (.not.subresolutionFractionIntegrandFailureWarned) then
                !$omp critical(Generalized_Press_Schechter_Subresolution_Fraction_Warn)
                if (.not.subresolutionFractionIntegrandFailureWarned) then
                   message='WARNING: Integration of the subresolution fraction in the generalized Press-Schechter branching probability module failed.'//char(10)//'Will try again with lower tolerance. This warning will not be issued again.'//{introspection:location}
                   call Galacticus_Warn(message)
                   subresolutionFractionIntegrandFailureWarned=.true.
                end if
                !$omp end critical(Generalized_Press_Schechter_Subresolution_Fraction_Warn)
             end if
             Generalized_Press_Schechter_Subresolution_Fraction=Generalized_Press_Schechter_Subresolution_Fraction &
                  &+Integrate(massMinimum,massMaximum,Subresolution_Fraction_Integrand_Generalized&
                  &,integrandFunction ,integrationWorkspace,toleranceAbsolute=0.0d0,toleranceRelative=1.0d-2 ,integrationRule&
                  &=FGSL_Integ_Gauss15)
          end if
       end if
    else
       Generalized_Press_Schechter_Subresolution_Fraction=-1.0d0
    end if
    return
  end function Generalized_Press_Schechter_Subresolution_Fraction

  double precision function Branching_Probability_Integrand_Generalized(childHaloMass)
    !% Integrand for the branching probability.
    implicit none
    double precision                               , intent(in   ) :: childHaloMass
    class           (cosmologicalMassVarianceClass), pointer       :: cosmologicalMassVariance_
    double precision                                               :: childAlpha               , childSigma

    cosmologicalMassVariance_ => cosmologicalMassVariance()
    call cosmologicalMassVariance_%rootVarianceAndLogarithmicGradient(childHaloMass,childSigma,childAlpha)
    Branching_Probability_Integrand_Generalized=Progenitor_Mass_Function(childHaloMass,childSigma,childAlpha)
    return
  end function Branching_Probability_Integrand_Generalized

  double precision function Subresolution_Fraction_Integrand_Generalized(childHaloMass)
    !% Integrand for the subresolution fraction.
    implicit none
    double precision                               , intent(in   ) :: childHaloMass
    class           (cosmologicalMassVarianceClass), pointer       :: cosmologicalMassVariance_
    double precision                                               :: childAlpha               , childSigma

    if (childHaloMass>0.0d0) then
    cosmologicalMassVariance_ => cosmologicalMassVariance()
       call cosmologicalMassVariance_%rootVarianceAndLogarithmicGradient(childHaloMass,childSigma,childAlpha)
       Subresolution_Fraction_Integrand_Generalized=Progenitor_Mass_Function(childHaloMass,childSigma,childAlpha)*(childHaloMass&
            &/parentHaloMass)
    else
       Subresolution_Fraction_Integrand_Generalized=0.0d0
    end if
    return
  end function Subresolution_Fraction_Integrand_Generalized

  double precision function Progenitor_Mass_Function(childHaloMass,childSigma,childAlpha)
    !% Progenitor mass function from Press-Schechter.
    implicit none
    double precision, intent(in   ) :: childAlpha, childHaloMass, childSigma

    Progenitor_Mass_Function=(parentHaloMass/childHaloMass**2)*Merging_Rate(childSigma,childAlpha)
    return
  end function Progenitor_Mass_Function

  double precision function Merging_Rate(childSigma,childAlpha)
    !% Computes the merging rate of dark matter halos in the generalized Press-Schechter algorithm. This ``merging rate'' is specifically defined as
    !% \begin{equation}
    !% {{\mathrm d}^2 f \over {\mathrm d} \ln M_{\mathrm child} {\mathrm d} \delta_{\mathrm c}} = 2 \sigma^2(M_{\mathrm child}) \left.{{\mathrm d} \ln \sigma \over {\mathrm d} \ln M}\right|_{M=M_{\mathrm child}} {{\mathrm d}t\over {\mathrm d}\delta_{\mathrm c}} {{\mathrm d}f_{12}\over {\mathrm d}t},
    !% \end{equation}
    !% where ${\mathrm d} f_{12}/{\mathrm d}t$ is the excursion set barrier crossing probabilty per unit time for the effective barrier
    !% $B^\prime(S_{\mathrm child}|S_{\mathrm parent},t)\equiv B(S_{\mathrm child},t-\delta t)-B(S_{\mathrm parent},t)$ in the limit $\delta t
    !% \rightarrow 0$.
    use Merger_Tree_Branching_Modifiers
    use Excursion_Sets_First_Crossings
    implicit none
    double precision                                , intent(in   ) :: childAlpha                , childSigma
    class           (excursionSetFirstCrossingClass), pointer       :: excursionSetFirstCrossing_
    double precision                                                :: childSigmaSquared

    excursionSetFirstCrossing_ => excursionSetFirstCrossing()
    childSigmaSquared=childSigma**2
    Merging_Rate=-2.0d0*excursionSetFirstCrossing_%rate(parentSigmaSquared,childSigmaSquared,parentTime)*childSigmaSquared&
         &*abs(childAlpha)*parentDTimeDDeltaCritical*Merger_Tree_Branching_Modifier(parentDelta,childSigma,parentSigma)
    return
  end function Merging_Rate

  subroutine Compute_Common_Factors
    !% Precomputes some useful factors that are used in the generalized Press-Schechter branching integrals.
    use Critical_Overdensities
    implicit none
    class(criticalOverdensityClass), pointer :: criticalOverdensity_

    criticalOverdensity_     =>       criticalOverdensity                (                               )
    parentSigmaSquared       =                                            parentSigma                     **2
    parentTime               =        criticalOverdensity_%timeOfCollapse(parentDelta,     parentHaloMass)
    parentDTimeDDeltaCritical=  1.0d0/criticalOverdensity_%gradientTime  (parentTime ,mass=parentHaloMass)
    return
  end subroutine Compute_Common_Factors

end module Generalized_Press_Schechter_Branching
