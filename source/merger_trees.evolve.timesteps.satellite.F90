!! Copyright 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018
!!    Andrew Benson <abenson@carnegiescience.edu>
!!
!! This file is part of Galacticus.
!!
!!    Galacticus is free software: you can redistribute it and/or modify
!!    it under the terms of the GNU General Public License as published by
!!    the Free Software Foundation, either version 3 of the License, or
!!    (at your option) any later version.
!!
!!    Galacticus is distributed in the hope that it will be useful,
!!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!!    GNU General Public License for more details.
!!
!!    You should have received a copy of the GNU General Public License
!!    along with Galacticus.  If not, see <http://www.gnu.org/licenses/>.

  !# <mergerTreeEvolveTimestep name="mergerTreeEvolveTimestepSatellite" defaultThreadPrivate="yes">
  !#  <description>A merger tree evolution timestepping class which limits the step to the next satellite merger.</description>
  !# </mergerTreeEvolveTimestep>
  type, extends(mergerTreeEvolveTimestepClass) :: mergerTreeEvolveTimestepSatellite
     !% Implementation of an output times class which reads a satellite of output times from a parameter.
     private
     double precision :: timeOffsetMaximumAbsolute, timeOffsetMaximumRelative
     logical          :: limitTimesteps
   contains
     procedure :: timeEvolveTo => satelliteTimeEvolveTo
  end type mergerTreeEvolveTimestepSatellite

  interface mergerTreeEvolveTimestepSatellite
     !% Constructors for the {\normalfont \ttfamily satellite} merger tree evolution timestep class.
     module procedure satelliteConstructorParameters
     module procedure satelliteConstructorInternal
  end interface mergerTreeEvolveTimestepSatellite

contains

  function satelliteConstructorParameters(parameters) result(self)
    !% Constructor for the {\normalfont \ttfamily satellite} merger tree evolution timestep class which takes a parameter set as input.
    use Input_Parameters
    implicit none
    type            (mergerTreeEvolveTimestepSatellite)                :: self
    type            (inputParameters                  ), intent(inout) :: parameters
    double precision                                                   :: timeOffsetMaximumAbsolute, timeOffsetMaximumRelative
    
    !# <inputParameter>
    !#   <name>timeOffsetMaximumAbsolute</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>0.010d0</defaultValue>
    !#   <description>The maximum absolute time difference (in Gyr) allowed between merging pairs of galaxies.</description>
    !#   <group>timeStepping</group>
    !#   <source>parameters</source>
    !#   <type>real</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>timeOffsetMaximumRelative</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>0.001d0</defaultValue>
    !#   <description>The maximum time difference (relative to the cosmic time at the merger epoch) allowed between merging pairs of galaxies.</description>
    !#   <group>timeStepping</group>
    !#   <source>parameters</source>
    !#   <type>real</type>
    !# </inputParameter>
    self=mergerTreeEvolveTimestepSatellite(timeOffsetMaximumAbsolute,timeOffsetMaximumRelative)
    !# <inputParametersValidate source="parameters"/>
    return
  end function satelliteConstructorParameters

  function satelliteConstructorInternal(timeOffsetMaximumAbsolute,timeOffsetMaximumRelative) result(self)
    !% Constructor for the {\normalfont \ttfamily satellite} merger tree evolution timestep class which takes a parameter set as input.

    implicit none
    type            (mergerTreeEvolveTimestepSatellite)                :: self
    double precision                                   , intent(in   ) :: timeOffsetMaximumAbsolute, timeOffsetMaximumRelative
    !# <constructorAssign variables="timeOffsetMaximumAbsolute, timeOffsetMaximumRelative"/>

    self%limitTimesteps=defaultSatelliteComponent%mergeTimeIsGettable()
    return
  end function satelliteConstructorInternal

  double precision function satelliteTimeEvolveTo(self,node,task,taskSelf,report,lockNode,lockType)
    !% Determine a suitable timestep for {\normalfont \ttfamily node} such that it does not exceed the time of the next satellite merger.
    use Evolve_To_Time_Reports
    use ISO_Varying_String
    implicit none
    class           (mergerTreeEvolveTimestepSatellite), intent(inout), target  :: self
    type            (treeNode                         ), intent(inout), target  :: node
    procedure       (timestepTask                     ), intent(  out), pointer :: task
    class           (*                                ), intent(  out), pointer :: taskSelf
    logical                                            , intent(in   )          :: report
    type            (treeNode                         ), intent(  out), pointer :: lockNode
    type            (varying_string                   ), intent(  out)          :: lockType
    type            (treeNode                         )               , pointer :: nodeHost
    class           (nodeComponentBasic               )               , pointer :: basicHost             , basic
    class           (nodeComponentSatellite           )               , pointer :: satellite
    double precision                                                            :: mergeTargetTimeMinimum, mergeTargetTimeOffsetMaximum, &
         &                                                                         timeUntilMerging

    ! By default set a huge timestep so that this class has no effect,
    satelliteTimeEvolveTo =  huge(0.0d0)
    task                  => null(     )
    taskSelf              => null(     )
    lockNode              => null(     )
    lockType              =  ""
    ! If not limiting timesteps return.
    if (.not.self%limitTimesteps) return
    ! Find the time of merging.
    satellite        => node     %satellite()
    timeUntilMerging =  satellite%mergeTime()
    ! If time is negative, implies this is not a satellite, so return.
    if (timeUntilMerging < 0.0d0) return
    ! Compute the minimum time to which the node we will merge with must have been evolved before merging is allowed.
    basic => node%basic()
    mergeTargetTimeOffsetMaximum=min(&
         &                           +self%timeOffsetMaximumAbsolute, &
         &                           +self%timeOffsetMaximumRelative  &
         &                           *(                               &
         &                             +basic%time            ()      &
         &                             +      timeUntilMerging        &
         &                            )                               &
         &                          )
    mergeTargetTimeMinimum=basic%time()+timeUntilMerging-mergeTargetTimeOffsetMaximum
    ! Find the node to merge with.
    nodeHost  => node    %mergesWith()
    basicHost => nodeHost%basic     ()
    if (basicHost%time() < mergeTargetTimeMinimum .and. associated(nodeHost%parent)) then
       ! Do not set an end of timestep task in this case - we want to wait for the merge target to catch up before triggering a
       ! merger.
       satelliteTimeEvolveTo =  max(timeUntilMerging-0.5d0*mergeTargetTimeOffsetMaximum,0.0d0)+basic%time()
       lockNode              => nodeHost
       lockType              =  "satellite (host)"
       if (report) call Evolve_To_Time_Report("satellite (host): ",satelliteTimeEvolveTo)
    else
       ! Set return value if our timestep is smaller than current one.
       lockNode              => nodeHost
       lockType              =  "satellite (self)"
       satelliteTimeEvolveTo =  timeUntilMerging+basic%time()
       ! Trigger a merger event only if the target node has no children. If it has children, we need to wait for them to be
       ! evolved before merging.
       if (.not.associated(nodeHost%firstChild)) then
          task     => satelliteMergerProcess
          taskSelf => self
       end if
    end if
    if (report) call Evolve_To_Time_Report("satellite (self): ",satelliteTimeEvolveTo,nodeHost%index())
    return
  end function satelliteTimeEvolveTo

  subroutine satelliteMergerProcess(self,tree,node,deadlockStatus)
    !% Process a satellite node which has undergone a merger with its host node.
    use Merger_Trees_Evolve_Deadlock_Status
    use ISO_Varying_String
    use String_Handling
    use Galacticus_Display
    !# <include directive="satelliteMergerTask" type="moduleUse">
    include 'merger_trees.evolve.timesteps.satellite.moduleUse.inc'
    !# </include>
    implicit none
    class  (*             ), intent(inout)          :: self
    type   (mergerTree    ), intent(in   )          :: tree
    type   (treeNode      ), intent(inout), pointer :: node
    integer                , intent(inout)          :: deadlockStatus
    type   (treeNode      )               , pointer :: mergee        , mergeeNext
    type   (varying_string)                         :: message
    !GCC$ attributes unused :: self, tree
    
    ! Report if necessary.
    if (Galacticus_Verbosity_Level() >= verbosityInfo) then
       message='Satellite node ['
       message=message//node%index()//'] is being merged'
       call Galacticus_Display_Message(message)
    end if
    ! Allow arbitrary functions to process the merger.
    !# <include directive="satelliteMergerTask" type="functionCall" functionType="void">
    !#  <functionArgs>node</functionArgs>
    include 'merger_trees.evolve.timesteps.satellite.inc'
    !# </include>
    ! Any mergees of the merging node must become mergees of its merge target.
    mergee => node%firstMergee
    do while (associated(mergee))
       mergeeNext => mergee%siblingMergee
       call mergee%removeFromMergee()
       mergee%siblingMergee             => node      %mergeTarget%firstMergee
       node  %mergeTarget  %firstMergee => mergee
       mergee%mergeTarget               => node      %mergeTarget
       mergee                           => mergeeNext
    end do
    ! Finally remove the satellite node from the host and merge targets and destroy it.
    call node%removeFromHost  ()
    call node%removeFromMergee()
    call node%destroy         ()
    deallocate(node)
    node => null()
    ! The tree was changed, so mark that it is not deadlocked.
    deadlockStatus=deadlockStatusIsNotDeadlocked
    return
  end subroutine satelliteMergerProcess
