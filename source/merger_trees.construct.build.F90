!! Copyright 2009, 2010, 2011, 2012, 2013, 2014, 2015 Andrew Benson <abenson@obs.carnegiescience.edu>
!!
!! This file is part of Galacticus.
!!
!!    Galacticus is free software: you can redistribute it and/or modify
!!    it under the terms of the GNU General Public License as published by
!!    the Free Software Foundation, either version 3 of the License, or
!!    (at your option) any later version.
!!
!!    Galacticus is distributed in the hope that it will be useful,
!!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!!    GNU General Public License for more details.
!!
!!    You should have received a copy of the GNU General Public License
!!    along with Galacticus.  If not, see <http://www.gnu.org/licenses/>.

!% Contains a module which implements building of merger trees after drawing masses at random from a mass function.

module Merger_Tree_Build
  !% Implements building of merger trees after drawing masses at random from a mass function.
  use Galacticus_Nodes
  use ISO_Varying_String
  implicit none
  private
  public :: Merger_Tree_Build_Initialize

  ! Variables giving the mass range and sampling frequency for mass function sampling.
  double precision                                                          :: mergerTreeBuildHaloMassMaximum               , mergerTreeBuildHaloMassMinimum          , &
       &                                                                       mergerTreeBuildTreesBaseRedshift             , mergerTreeBuildTreesBaseTime            , &
       &                                                                       mergerTreeBuildTreesPerDecade
  integer                                                                   :: mergerTreeBuildTreesBeginAtTree
  type            (varying_string              )                            :: mergerTreeBuildTreeMassesFile                , mergerTreeBuildTreesHaloMassDistribution

  ! Direction in which to process trees.
  logical                                                                   :: mergerTreeBuildTreesProcessDescending

  ! Array of halo masses to use.
  integer                                                                   :: nextTreeIndex                                , treeCount
  double precision                              , allocatable, dimension(:) :: treeHaloMass                                 , treeWeight

contains

  !# <mergerTreeConstructMethod>
  !#  <unitName>Merger_Tree_Build_Initialize</unitName>
  !# </mergerTreeConstructMethod>
  subroutine Merger_Tree_Build_Initialize(mergerTreeConstructMethod,Merger_Tree_Construct)
    !% Initializes the merger tree building module.
    use, intrinsic :: ISO_C_Binding
    use Input_Parameters
    use Memory_Management
    use Cosmology_Functions
    use FGSL
    use Quasi_Random
    use Pseudo_Random
    use Halo_Mass_Function
    use Merger_Trees_Mass_Function_Sampling_Modifiers
    use Sort
    use Galacticus_Error
    use Galacticus_Display
    use Numerical_Ranges
    use Numerical_Integration
    use Numerical_Interpolation
    use FoX_dom
    use IO_HDF5
    use IO_XML
    use Table_Labels
    !# <include directive="mergerTreeBuildMethod" type="moduleUse">
    include 'merger_trees.build.modules.inc'
    !# </include>
    implicit none
    type            (varying_string                   )             , intent(in   )          :: mergerTreeConstructMethod
    procedure       (Merger_Tree_Build_Do             )             , intent(inout), pointer :: Merger_Tree_Construct
    type            (Node                             )                            , pointer :: doc
    class           (cosmologyFunctionsClass          )                            , pointer :: cosmologyFunctionsDefault
    class           (massFunctionSamplingModifierClass)                            , pointer :: massFunctionSamplingModifier_
    integer                                            , parameter                           :: massFunctionSamplePerDecade  =100
    double precision                                   , parameter                           :: toleranceAbsolute            =1.0d-12, toleranceRelative                 =1.0d-3
    double precision                                   , allocatable, dimension(:)           :: massFunctionSampleLogMass            , massFunctionSampleLogMassMonotonic       , &
         &                                                                                      massFunctionSampleProbability
    logical                                                                                  :: computeTreeWeights
    integer                                                                                  :: ioErr                                , jSample                                  , &
         &                                                                                      massFunctionSampleCount              , iSample                                  , &
         &                                                                                      iTree                                , iTreeFirst                               , &
         &                                                                                      iTreeLast
    type            (fgsl_qrng                        )                                      :: quasiSequenceObject
    type            (fgsl_rng                         )                                      :: pseudoSequenceObject
    logical                                                                                  :: quasiSequenceReset           =.true. , pseudoSequenceReset               =.true.
    double precision                                                                         :: expansionFactor                      , massFunctionSampleLogPrevious            , &
         &                                                                                      massMaximum                          , massMinimum                              , &
         &                                                                                      probability
    type            (fgsl_function                    )                                      :: integrandFunction
    type            (fgsl_integration_workspace       )                                      :: integrationWorkspace
    type            (fgsl_interp                      )                                      :: interpolationObject
    type            (fgsl_interp_accel                )                                      :: interpolationAccelerator
    type            (c_ptr                            )                                      :: parameterPointer
    logical                                                                                  :: integrandReset               =.true. , interpolationReset                =.true.
    type            (hdf5Object                       )                                      :: treeFile

    ! Check if our method is to be used.
    if (mergerTreeConstructMethod == 'build') then
       ! Assign pointer to our merger tree construction subroutine.
       Merger_Tree_Construct => Merger_Tree_Build_Do
       ! Read parameters for halo mass sampling.
       !@ <inputParameter>
       !@   <name>mergerTreeBuildHaloMassMinimum</name>
       !@   <defaultValue>$10^{10}$</defaultValue>
       !@   <attachedTo>module</attachedTo>
       !@   <description>
       !@     The minimum mass of merger tree base halos to consider when building merger trees, in units of $M_\odot$.
       !@   </description>
       !@   <type>real</type>
       !@   <cardinality>1</cardinality>
       !@ </inputParameter>
       call Get_Input_Parameter('mergerTreeBuildHaloMassMinimum'  ,mergerTreeBuildHaloMassMinimum  ,defaultValue=1.0d10)
       !@ <inputParameter>
       !@   <name>mergerTreeBuildHaloMassMaximum</name>
       !@   <defaultValue>$10^{15}$</defaultValue>
       !@   <attachedTo>module</attachedTo>
       !@   <description>
       !@     The maximum mass of merger tree base halos to consider when building merger trees, in units of $M_\odot$.
       !@   </description>
       !@   <type>real</type>
       !@   <cardinality>1</cardinality>
       !@ </inputParameter>
       call Get_Input_Parameter('mergerTreeBuildHaloMassMaximum'  ,mergerTreeBuildHaloMassMaximum  ,defaultValue=1.0d15)
       !@ <inputParameter>
       !@   <name>mergerTreeBuildTreesPerDecade</name>
       !@   <defaultValue>10</defaultValue>
       !@   <attachedTo>module</attachedTo>
       !@   <description>
       !@     The number of merger trees to build per decade of base halo mass.
       !@   </description>
       !@   <type>integer</type>
       !@   <cardinality>1</cardinality>
       !@ </inputParameter>
       call Get_Input_Parameter('mergerTreeBuildTreesPerDecade'   ,mergerTreeBuildTreesPerDecade   ,defaultValue=10.0d0)
       !@ <inputParameter>
       !@   <name>mergerTreeBuildTreesBaseRedshift</name>
       !@   <defaultValue>0</defaultValue>
       !@   <attachedTo>module</attachedTo>
       !@   <description>
       !@     The redshift at which to plant the base node when building merger trees.
       !@   </description>
       !@   <type>real</type>
       !@   <cardinality>1</cardinality>
       !@ </inputParameter>
       call Get_Input_Parameter('mergerTreeBuildTreesBaseRedshift',mergerTreeBuildTreesBaseRedshift,defaultValue=0.0d0 )
       !@ <inputParameter>
       !@   <name>mergerTreeBuildTreesBeginAtTree</name>
       !@   <defaultValue>1 (if processing trees in ascending order), or equal to the number of trees (otherwise)</defaultValue>
       !@   <attachedTo>module</attachedTo>
       !@   <description>
       !@     The index (in order of increasing base halo mass) of the tree at which to begin when building merger trees.
       !@   </description>
       !@   <type>integer</type>
       !@   <cardinality>1</cardinality>
       !@ </inputParameter>
       call Get_Input_Parameter('mergerTreeBuildTreesBeginAtTree' ,mergerTreeBuildTreesBeginAtTree ,defaultValue=0     )
       !@ <inputParameter>
       !@   <name>mergerTreeBuildTreesHaloMassDistribution</name>
       !@   <defaultValue>uniform</defaultValue>
       !@   <attachedTo>module</attachedTo>
       !@   <description>
       !@     The method to be used to construct a distribution of base halo masses.
       !@   </description>
       !@   <type>string</type>
       !@   <cardinality>1</cardinality>
       !@ </inputParameter>
       call Get_Input_Parameter('mergerTreeBuildTreesHaloMassDistribution',mergerTreeBuildTreesHaloMassDistribution,defaultValue="uniform")
       !@ <inputParameter>
       !@   <name>mergerTreeBuildTreesProcessDescending</name>
       !@   <defaultValue>true</defaultValue>
       !@   <attachedTo>module</attachedTo>
       !@   <description>
       !@     If true, causes merger trees to be processed in order of decreasing mass.
       !@   </description>
       !@   <type>boolean</type>
       !@   <cardinality>1</cardinality>
       !@ </inputParameter>
       call Get_Input_Parameter('mergerTreeBuildTreesProcessDescending',mergerTreeBuildTreesProcessDescending,defaultValue=.true.)
       !@ <inputParameter>
       !@   <name>mergerTreeBuildTreeMassesFile</name>
       !@   <defaultValue>null</defaultValue>
       !@   <description>
       !@     Specifies the name of a file from which to read the masses of merger tree root halos when building merger trees.
       !@   </description>
       !@   <type>string</type>
       !@   <cardinality>1</cardinality>
       !@ </inputParameter>
       call Get_Input_Parameter('mergerTreeBuildTreeMassesFile',mergerTreeBuildTreeMassesFile,defaultValue='null')

       ! Validate input.
       if (mergerTreeBuildHaloMassMaximum >= 1.0d16)                                                                            &
            & call Galacticus_Display_Message(                                                                                  &
            &                                 '[mergerTreeBuildHaloMassMaximum] > 10¹⁶ - this seems very large and may lead '// &
            &                                 'to failures in merger tree construction'                                      ,  &
            &                                 verbosityWarn                                                                     &
            &                                )
       if (mergerTreeBuildHaloMassMaximum <= mergerTreeBuildHaloMassMinimum)                                                  &
            & call Galacticus_Error_Report(                                                                                   &
            &                              'Merger_Tree_Build_Initialize'                                                   , &
            &                              '[mergerTreeBuildHaloMassMaximum] > [mergerTreeBuildHaloMassMinimum] is required'  &
            &                             )
       ! Get the default cosmology functions object.
       cosmologyFunctionsDefault => cosmologyFunctions()
       ! Find the cosmic time at which the trees are based.
       expansionFactor=cosmologyFunctionsDefault%expansionFactorFromRedshift(mergerTreeBuildTreesBaseRedshift)
       mergerTreeBuildTreesBaseTime=cosmologyFunctionsDefault%cosmicTime(expansionFactor)

       ! Generate a randomly sampled set of halo masses.
       treeCount=max(2,int(log10(mergerTreeBuildHaloMassMaximum/mergerTreeBuildHaloMassMinimum)*mergerTreeBuildTreesPerDecade))

       ! Determine how to compute the tree root masses.
       computeTreeWeights=.true.
       select case (char(mergerTreeBuildTreesHaloMassDistribution))
       case ("quasi","random","uniform")
          ! Generate a randomly sampled set of halo masses.
          treeCount=max(2,int(log10(mergerTreeBuildHaloMassMaximum/mergerTreeBuildHaloMassMinimum)*mergerTreeBuildTreesPerDecade))
          call Alloc_Array(treeHaloMass,[treeCount])
          call Alloc_Array(treeWeight  ,[treeCount])

          ! Create a distribution of halo masses.
          select case (char(mergerTreeBuildTreesHaloMassDistribution))
          case ("quasi")
             ! Use a quasi-random sequence to generate halo masses.
             do iTree=1,treeCount
                treeHaloMass(iTree)=Quasi_Random_Get(quasiSequenceObject,reset=quasiSequenceReset)
             end do
             call Quasi_Random_Free(quasiSequenceObject)
             call Sort_Do(treeHaloMass)
          case ("random")
             ! Use a pseudo-random sequence to generate halo masses.
             do iTree=1,treeCount
                treeHaloMass(iTree)=Pseudo_Random_Get(pseudoSequenceObject,reset=pseudoSequenceReset)
             end do
             call Pseudo_Random_Free(pseudoSequenceObject)
             call Sort_Do(treeHaloMass)
          case ("uniform")
             ! Use a uniform distribution in logarithm of halo mass.
             treeHaloMass=Make_Range(0.0d0,1.0d0,treeCount,rangeType=rangeTypeLinear)
          case default
             call Galacticus_Error_Report('Merger_Tree_Build_Initialize','unknown halo mass distribution option')
          end select
          ! Create a cumulative probability for sampling halo masses.
          massFunctionSampleCount=max(2,int(log10(mergerTreeBuildHaloMassMaximum/mergerTreeBuildHaloMassMinimum)*massFunctionSamplePerDecade))
          call Alloc_Array(massFunctionSampleLogMass         ,[massFunctionSampleCount])
          call Alloc_Array(massFunctionSampleLogMassMonotonic,[massFunctionSampleCount])
          call Alloc_Array(massFunctionSampleProbability     ,[massFunctionSampleCount])
          massFunctionSampleLogMass=Make_Range(log10(mergerTreeBuildHaloMassMinimum),log10(mergerTreeBuildHaloMassMaximum),massFunctionSampleCount,rangeType=rangeTypeLinear)
          massFunctionSampleLogPrevious=log10(mergerTreeBuildHaloMassMinimum)
          jSample=0
          do iSample=1,massFunctionSampleCount
             if (massFunctionSampleLogMass(iSample) > massFunctionSampleLogPrevious) then
                probability=Integrate(massFunctionSampleLogPrevious&
                     &,massFunctionSampleLogMass(iSample),Mass_Function_Sampling_Integrand,parameterPointer,integrandFunction &
                     &,integrationWorkspace,toleranceAbsolute=toleranceAbsolute,toleranceRelative=toleranceRelative,reset=integrandReset)
             else
                probability=0.0d0
             end if
             if     (                                                       &
                  &     iSample == 1                                        &
                  &  .or.                                                   &
                  &   (                                                     &
                  &     jSample >  0                                        &
                  &    .and.                                                &
                  &      massFunctionSampleProbability(jSample)+probability &
                  &     >                                                   &
                  &      massFunctionSampleProbability(jSample)             &
                  &   )                                                     &
                  & ) then
                jSample=jSample+1
                massFunctionSampleProbability     (jSample)=probability
                massFunctionSampleLogMassMonotonic(jSample)=massFunctionSampleLogMass(iSample)
                if (jSample > 1) massFunctionSampleProbability(jSample)=massFunctionSampleProbability(jSample)+massFunctionSampleProbability(jSample-1)
             end if
             massFunctionSampleLogPrevious=massFunctionSampleLogMass(iSample)
          end do
          call Integrate_Done(integrandFunction,integrationWorkspace)
          massFunctionSampleCount=jSample
          if (massFunctionSampleCount < 2) call Galacticus_Error_Report('Merger_Tree_Build_Initialize','tabulated mass function sampling density has fewer than 2 non-zero points')
          ! Normalize the cumulative probability distribution.
          massFunctionSampleProbability=massFunctionSampleProbability/massFunctionSampleProbability(massFunctionSampleCount)
          ! Compute the corresponding halo masses by interpolation in the cumulative probability distribution function.
          do iTree=1,treeCount
             treeHaloMass(iTree)=Interpolate(massFunctionSampleProbability(1:massFunctionSampleCount)&
                  &,massFunctionSampleLogMassMonotonic(1:massFunctionSampleCount),interpolationObject,interpolationAccelerator&
                  &,treeHaloMass(iTree) ,reset=interpolationReset,extrapolationType=extrapolationTypeFix)
          end do
          treeHaloMass=10.0d0**treeHaloMass
          call Interpolate_Done(interpolationObject,interpolationAccelerator,interpolationReset)
          call Dealloc_Array(massFunctionSampleLogMass         )
          call Dealloc_Array(massFunctionSampleProbability     )
          call Dealloc_Array(massFunctionSampleLogMassMonotonic)
          ! Allow modification of the halo mass sample.
          massFunctionSamplingModifier_ => massFunctionSamplingModifier()
          call massFunctionSamplingModifier_%modify(treeHaloMass,mergerTreeBuildTreesBaseTime)
          call Sort_Do(treeHaloMass)
          treeCount=size(treeHaloMass)
          call Alloc_Array(treeWeight,[treeCount])
       case ("read")
          ! Read masses from a file.
          ! Detect file type.
          if (extract(mergerTreeBuildTreeMassesFile,len(mergerTreeBuildTreeMassesFile)-3,len(mergerTreeBuildTreeMassesFile)) == ".xml") then
             !$omp critical (FoX_DOM_Access)
             doc => parseFile(char(mergerTreeBuildTreeMassesFile),iostat=ioErr)
             if (ioErr /= 0) call Galacticus_Error_Report('Merger_Tree_Build_Initialize','unable to read or parse merger tree root mass file')
             ! Read all tree masses.
             call XML_Array_Read(doc,"treeRootMass",treeHaloMass)
             ! Allocate array for tree weights.
             treeCount=size(treeHaloMass)
             call Alloc_Array(treeWeight,[treeCount])
             ! Extract tree weights if available.
             if (XML_Path_Exists(doc,"treeWeight")) then
                computeTreeWeights=.false.
                call XML_Array_Read_Static(doc,"treeWeight",treeWeight)
             end if
             ! Finished - destroy the XML document.
             call destroy(doc)
             !$omp end critical (FoX_DOM_Access)
          else if (extract(mergerTreeBuildTreeMassesFile,len(mergerTreeBuildTreeMassesFile)-4,len(mergerTreeBuildTreeMassesFile)) == ".hdf5") then
             !$omp critical (HDF5_Access)
             call treeFile%openFile(char(mergerTreeBuildTreeMassesFile),overWrite=.false.,readOnly=.true.)
             call treeFile%readDataset('treeRootMass',treeHaloMass)
             treeCount=size(treeHaloMass)
             if (treeFile%hasDataset('treeWeight')) then
                call treeFile%readDataset('treeWeight',treeWeight)
                computeTreeWeights=.false.
             else
                call Alloc_Array(treeWeight,shape(treeHaloMass))
                computeTreeWeights=.true.
             end if
             call treeFile%close()
             !$omp end critical (HDF5_Access)
          else
             call Galacticus_Error_Report('Merger_Tree_Build_Initialize','unknown file type for halo masses')
          end if
       case default
          call Galacticus_Error_Report('Merger_Tree_Build_Initialize','unknown halo mass distribution option')
       end select
       ! Compute the weight (number of trees per unit volume) for each tree.
       if (computeTreeWeights) then
          iTreeFirst=0
          do while (iTreeFirst < treeCount)
             iTreeFirst=iTreeFirst+1
             ! Find the last tree with the same mass.
             iTreeLast=iTreeFirst
             if (iTreeLast < treeCount) then
                do while (treeHaloMass(iTreeLast+1) == treeHaloMass(iTreeFirst))
                   iTreeLast=iTreeLast+1
                   if (iTreeLast == treeCount) exit
                end do
             end if
             ! Get the minimum mass of the interval occupied by this tree.
             if (iTreeFirst == 1) then
                if (char(mergerTreeBuildTreesHaloMassDistribution) == "read") then
                   massMinimum=treeHaloMass(iTreeFirst)*sqrt(treeHaloMass(iTreeFirst)/treeHaloMass(iTreeFirst+1))
                else
                   massMinimum=min(mergerTreeBuildHaloMassMinimum,treeHaloMass(iTreeFirst))
                end if
             else
                massMinimum=sqrt(treeHaloMass(iTreeFirst)*treeHaloMass(iTreeFirst-1))
             end if
             ! Get the maximum mass of the interval occupied by this tree.
             if (iTreeLast == treeCount) then
                if (char(mergerTreeBuildTreesHaloMassDistribution) == "read") then
                   massMaximum=treeHaloMass(iTreeLast)*sqrt(treeHaloMass(iTreeLast)/treeHaloMass(iTreeLast-1))
                else
                   massMaximum=max(mergerTreeBuildHaloMassMaximum,treeHaloMass(iTreeLast))
                end if
             else
                massMaximum=sqrt(treeHaloMass(iTreeLast)*treeHaloMass(iTreeLast+1))
             end if
             ! For distributions of masses, adjust the masses at the end points so that they are at the
             ! geometric mean of their range.
             if     (                                                          &
                  &   (iTreeFirst == 1 .or.  iTreeLast == treeCount)           &
                  &  .and..not.                                                &
                  &   (iTreeFirst == 1 .and. iTreeLast == treeCount)           &
                  &  .and.                                                     &
                  &   char(mergerTreeBuildTreesHaloMassDistribution) /= "read" &
                  & ) treeHaloMass(iTreeFirst:iTreeLast)=sqrt(massMinimum*massMaximum)
             ! Get the integral of the halo mass function over this range.
             treeWeight(iTreeFirst:iTreeLast)=Halo_Mass_Function_Integrated(mergerTreeBuildTreesBaseTime,MassMinimum,MassMaximum)/dble(iTreeLast-iTreeFirst+1)
             ! Update to the last tree processed.
             iTreeFirst=iTreeLast
          end do
       end if
       ! Determine the index of the tree at which to begin.
       if (mergerTreeBuildTreesProcessDescending) then
          if (mergerTreeBuildTreesBeginAtTree == 0) mergerTreeBuildTreesBeginAtTree=treeCount
          nextTreeIndex=treeCount+1-mergerTreeBuildTreesBeginAtTree
       else
          if (mergerTreeBuildTreesBeginAtTree == 0) mergerTreeBuildTreesBeginAtTree=1
          nextTreeIndex=            mergerTreeBuildTreesBeginAtTree
       end if
    end if
    return
  end subroutine Merger_Tree_Build_Initialize

  function Mass_Function_Sampling_Integrand(logMass,parameterPointer) bind(c)
    !% The integrand over the mass function sampling density function.
    use, intrinsic :: ISO_C_Binding
    use Merger_Trees_Mass_Function_Sampling
    implicit none
    real(kind=c_double)        :: Mass_Function_Sampling_Integrand
    real(kind=c_double), value :: logMass
    type(c_ptr        ), value :: parameterPointer

    Mass_Function_Sampling_Integrand=Merger_Tree_Construct_Mass_Function_Sampling(10.0d0**logMass,mergerTreeBuildTreesBaseTime,mergerTreeBuildHaloMassMinimum,mergerTreeBuildHaloMassMaximum)
    return
  end function Mass_Function_Sampling_Integrand

  subroutine Merger_Tree_Build_Do(thisTree,skipTree)
    !% Build a merger tree.
    use Galacticus_State
    use Kind_Numbers
    use String_Handling
    use Merger_Trees_Builders
    implicit none
    type   (mergerTree            ), intent(inout), target :: thisTree
    logical                        , intent(in   )         :: skipTree
    class  (nodeComponentBasic    ), pointer               :: baseNodeBasicComponent
    class  (mergerTreeBuilderClass), pointer               :: mergerTreeBuilder_
    integer(kind=kind_int8        ), parameter             :: baseNodeIndex         =1
    integer(kind=kind_int8        )                        :: thisTreeIndex
    type   (varying_string        )                        :: message

    ! Get a base halo mass and initialize. Do this within an OpenMP critical section so that threads don't try to get the same
    ! tree.
    !$omp critical (Merger_Tree_Build_Do)
    if (nextTreeIndex <= treeCount) then
       ! Retrieve stored internal state if possible.
       call Galacticus_State_Retrieve
       ! Take a snapshot of the internal state and store it.
       call Galacticus_State_Snapshot
       message='Storing state for tree #'
       message=message//nextTreeIndex
       call Galacticus_State_Store(message)
       ! Determine the index of the tree to process.
       select case (mergerTreeBuildTreesProcessDescending)
       case(.false.)
          ! Processing trees in ascending order, to just use nextTreeIndex as the index of the tree to process.
          thisTreeIndex=nextTreeIndex
       case(.true. )
          ! Processing trees in descending order, so begin from the final index and work back.
          thisTreeIndex=treeCount+1-nextTreeIndex
       end select
       ! Give the tree an index.
       thisTree%index=thisTreeIndex
       ! Create the base node.
       thisTree%baseNode => treeNode(baseNodeIndex,thisTree)
       ! Assign a weight to the tree.
       thisTree%volumeWeight=treeWeight(thisTreeIndex)
       ! Get the basic component of the base node.
       baseNodeBasicComponent => thisTree%baseNode%basic(autoCreate=.true.)
       ! Assign a mass to it.
       call baseNodeBasicComponent%massSet(treeHaloMass(thisTreeIndex) )
       ! Assign a time.
       call baseNodeBasicComponent%timeSet(mergerTreeBuildTreesBaseTime)
       ! Increment the tree index counter.
       nextTreeIndex=nextTreeIndex+1
    end if
    !$omp end critical (Merger_Tree_Build_Do)
    ! If we got a tree, we can now process it (in parallel if running under OpenMP).
    if (associated(thisTree%baseNode).and..not.skipTree) then
       ! Call routine to actually build the tree.
       mergerTreeBuilder_ => mergerTreeBuilder()
       call mergerTreeBuilder_%build(thisTree)
    end if
    return
  end subroutine Merger_Tree_Build_Do

end module Merger_Tree_Build
