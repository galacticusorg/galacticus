!! Copyright 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017
!!    Andrew Benson <abenson@carnegiescience.edu>
!!
!! This file is part of Galacticus.
!!
!!    Galacticus is free software: you can redistribute it and/or modify
!!    it under the terms of the GNU General Public License as published by
!!    the Free Software Foundation, either version 3 of the License, or
!!    (at your option) any later version.
!!
!!    Galacticus is distributed in the hope that it will be useful,
!!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!!    GNU General Public License for more details.
!!
!!    You should have received a copy of the GNU General Public License
!!    along with Galacticus.  If not, see <http://www.gnu.org/licenses/>.

!% Defines methods for a Gaussian regression likelihood function.

function likelihoodGaussianRegressionConstructor(simulatorLikelihoodDefinition,emulatorRebuildCount,polynomialOrder,sigmaBuffer,logLikelihoodBuffer,logLikelihoodErrorTolerance,reportCount,emulateOutliers,dumpEmulator,dummyEmulator,configFileName)
  !% Constructor for Gaussian regression likelihood class.
  use FoX_DOM
  implicit none
  type            (likelihoodGaussianRegression)                          :: likelihoodGaussianRegressionConstructor
  type            (node                        ), intent(in   ), pointer  :: simulatorLikelihoodDefinition
  integer                                       , intent(in   )           :: emulatorRebuildCount                   , polynomialOrder    , &
       &                                                                     reportCount
  double precision                              , intent(in   )           :: sigmaBuffer                            , logLikelihoodBuffer, &
       &                                                                     logLikelihoodErrorTolerance
  logical                                       , intent(in   )           :: emulateOutliers                        , dummyEmulator
  character       (len=*                       ), intent(in   )           :: dumpEmulator
  type            (varying_string              ), intent(in   ), optional :: configFileName
  
  ! Set emulator properties.
  likelihoodGaussianRegressionConstructor%simulatorLikelihoodFunction => likelihoodNew(simulatorLikelihoodDefinition,configFileName)
  likelihoodGaussianRegressionConstructor%emulatorRebuildCount        =  emulatorRebuildCount
  likelihoodGaussianRegressionConstructor%polynomialOrder             =  polynomialOrder
  likelihoodGaussianRegressionConstructor%sigmaBuffer                 =  sigmaBuffer
  likelihoodGaussianRegressionConstructor%logLikelihoodBuffer         =  logLikelihoodBuffer
  likelihoodGaussianRegressionConstructor%logLikelihoodErrorTolerance =  logLikelihoodErrorTolerance
  likelihoodGaussianRegressionConstructor%reportCount                 =  reportCount
  likelihoodGaussianRegressionConstructor%emulateOutliers             =  emulateOutliers
  likelihoodGaussianRegressionConstructor%dummyEmulator               =  dummyEmulator
  likelihoodGaussianRegressionConstructor%dumpEmulatorFileRoot        =  trim(dumpEmulator)
  likelihoodGaussianRegressionConstructor%dumpEmulatorCount           =  0
  likelihoodGaussianRegressionConstructor%dumpEmulator                =  (likelihoodGaussianRegressionConstructor%dumpEmulatorFileRoot /= "")
  ! Initialize state and counters.
  likelihoodGaussianRegressionConstructor%initialized                 =  .false.
  likelihoodGaussianRegressionConstructor%isGood                      =  .false.
  likelihoodGaussianRegressionConstructor%accumulatedStateCount       =  0
  likelihoodGaussianRegressionConstructor%simulationCount             =  0
  likelihoodGaussianRegressionConstructor%evaluationCount             =  0
  likelihoodGaussianRegressionConstructor%emulatorCheckCount          =  0
  likelihoodGaussianRegressionConstructor%emulatorFailCount           =  0
  return
end function likelihoodGaussianRegressionConstructor

subroutine likelihoodGaussianRegressionDestructor(self)
  !% Destructor for Gaussian regression likelihood class.
  implicit none
  type(likelihoodGaussianRegression), intent(inout) :: self
    
  deallocate(self%simulatorLikelihoodFunction)
  call FGSL_Matrix_Free     (self%regressionMatrixLU)
  call FGSL_Permutation_Free(self%permutations      )
  return
end subroutine likelihoodGaussianRegressionDestructor

double precision function likelihoodGaussianRegressionEvaluate(self,simulationState,parameterMappings,simulationConvergence,temperature,logLikelihoodCurrent,logPriorCurrent,logPriorProposed,timeEvaluate,logLikelihoodVariance)
  !% Return the log-likelihood for a Gaussian regression likelihood function.
  use, intrinsic :: ISO_C_Binding
  use Constraints_State
  use Constraints_Convergence
  use Constraints_Constants
  use Memory_Management
  use MPI_Utilities
  use Galacticus_Display
  use Galacticus_Error
  use Error_Functions
  use String_Handling
  use Dates_and_Times
  implicit none
  class           (likelihoodGaussianRegression  ), intent(inout)                   :: self
  class           (state                         ), intent(inout)                   :: simulationState
  type            (mappingList                   ), intent(in   ), dimension(:)     :: parameterMappings
  class           (convergence                   ), intent(inout)                   :: simulationConvergence
  double precision                                , intent(in   )                   :: temperature                               , logLikelihoodCurrent  , &
       &                                                                               logPriorCurrent                           , logPriorProposed
  real                                            , intent(inout)                   :: timeEvaluate
  double precision                                , intent(  out), optional         :: logLikelihoodVariance
  double precision                                , allocatable  , dimension(:,:,:) :: states
  double precision                                , allocatable  , dimension(  :,:) :: likelihoods                               , workspace2D
  double precision                                , allocatable  , dimension(    :) :: likelihoodsCombined                       , workspace              , &
       &                                                                               likelihoodsFitted                         , separations            , &
       &                                                                               semiVariances
  integer                                         , allocatable  , dimension(    :) :: stateCount
  double precision                                , parameter                       :: emulatorFailureSignificance        =  3.0d+0
  double precision                                , parameter                       :: emulatorFailureSignificanceAbsolute=  1.0d-3
  double precision                                , parameter                       :: emulatorFailureLimit               =  5.0d+0
  integer                                         , parameter                       :: checksTotalMinimum                 =100
  type            (polynomialIterator            )                                  :: iterator1                                   , iterator2
  type            (vector                        )                                  :: likelihoodSums                              , coefficients
  type            (matrix                        )                                  :: stateSums
  integer         (kind=FGSL_Int                 )                                  :: decompositionSign                           , status
  integer                                                                           :: accumulatedStateCount                       , i                    , &
       &                                                                               j                                           , k                    , &
       &                                                                               evaluationsTotal                            , simulationsTotal     , &
       &                                                                               stateCountAccept                            , stateCountAcceptChain, &
       &                                                                               determinantSign                             , checksTotal          , &
       &                                                                               failuresTotal                               , fileUnit             , &
       &                                                                               correlationLength                           , l
  double precision                                                                  :: separation                                  , likelihoodError      , & 
       &                                                                               likelihoodEmulated                          , failureRateExpected
  logical                                                                           :: likelihoodIsSimulated
  character       (len=8                         )                                  :: label
  type            (varying_string                )                                  :: message                            , fileName

  ! Report on emulation efficiency.
  if (mod(self%evaluationCount,self%reportCount) == 0 .and. self%evaluationCount > 0 .and. Galacticus_Verbosity_Level() >= verbosityInfo) then
     evaluationsTotal=mpiSelf%sum(self%evaluationCount)
     simulationsTotal=mpiSelf%sum(self%simulationCount)
     if (mpiSelf%isMaster()) then
        write (label,'(i8)') simulationsTotal
        message='Simulated/Emulated '//trim(adjustl(label))//'/'
        write (label,'(i8)') evaluationsTotal-simulationsTotal
        message=message//trim(adjustl(label))//' of '
        write (label,'(i8)') evaluationsTotal
        message=message//trim(adjustl(label))//' states ('
        write (label,'(f6.2)') 100.0d0*dble(simulationsTotal)/dble(evaluationsTotal)
        message=message//trim(adjustl(label))//'/'
        write (label,'(f6.2)') 100.0d0*dble(evaluationsTotal-simulationsTotal)/dble(evaluationsTotal)
        message=message//trim(adjustl(label))//'%)'
        call Galacticus_Display_Message(message)
     end if
  end if
  ! Rebuild emulator if necessary.
  allocate(stateCount(0:mpiSelf%count()-1))
  stateCount                           =0
  stateCount           (mpiSelf%rank())=self   %accumulatedStateCount
  stateCount                           =mpiSelf%sum                  (stateCount)
  accumulatedStateCount                =        sum                  (stateCount)
  select type (simulationState)
  class is (stateCorrelation)
     correlationLength=simulationState%correlationLength()
  class default
     correlationLength=1
  end select
  if (accumulatedStateCount >= self%emulatorRebuildCount .and. (any(stateCount == self%emulatorRebuildCount) .or. .not.self%initialized) .and. correlationLength > 0) then
     if (mpiSelf%isMaster()) then
        call Galacticus_Display_Indent('Rebuilding Gaussian process emulator ['//char(Formatted_Date_and_Time())//']')
        call flush(0)
     end if
     ! Initialize Gaussian regression workspace.
     if (.not.self%initialized) then
        ! Determine the size of the regression matrix.
        self%regressionMatrixSize=self%emulatorRebuildCount+1
        ! Count number of terms in the N-dimensional polynomial
        self%polynomialCoefficientCount=0
        do i=0,self%polynomialOrder
           self%polynomialCoefficientCount=                                  &
                &  self%polynomialCoefficientCount                           &
                & +polynomialCoefficientCount(i,simulationState%dimension())
        end do
        if (self%polynomialCoefficientCount > self%emulatorRebuildCount) then
           message='number of points used in emulator ['
           message=message                                              // &
                &  self%emulatorRebuildCount                            // &
                &  '] is too few to constrain global trend polynomial ['// &
                &  self%polynomialCoefficientCount                      // &
                &  ']'
           call Galacticus_Error_Report('likelihoodGaussianRegressionEvaluate',message)
        end if
        call allocateArray(self%polynomialCoefficient,    [self%polynomialCoefficientCount                                ] )
        call allocateArray(self%likelihoodSums       ,    [self%polynomialCoefficientCount                                ] )
        call allocateArray(self%stateSums            ,    [self%polynomialCoefficientCount,self%polynomialCoefficientCount] )
        call allocateArray(self%coefficients         ,    [self%polynomialCoefficientCount                                ] )
        call allocateArray(self%regressionMatrix     ,int([self%regressionMatrixSize      ,self%regressionMatrixSize      ]))
        call allocateArray(self%stateOffset          ,int([self%regressionMatrixSize                                      ]))
        call allocateArray(self%weight               ,int([self%regressionMatrixSize                                      ]))
        call allocateArray(self%likelihoodResiduals  ,    [self%emulatorRebuildCount                                      ] )
        call allocateArray(self%statesCombined       ,    [simulationState%dimension()    ,self%emulatorRebuildCount      ] )
        call allocateArray(self%stateScales          ,    [simulationState%dimension()                                    ] )
        call allocateArray(self%stateMeans           ,    [simulationState%dimension()                                    ] )
        self%initialized=.true.
     end if
     ! Gather the simulator state and likelihood from other chains.
     if (mpiSelf%isMaster()) call Galacticus_Display_Message('gathering states ['//char(Formatted_Date_and_Time())//']')
     allocate(states     (simulationState%dimension(),self%emulatorRebuildCount,0:mpiSelf%count()-1))
     allocate(likelihoods(                            self%emulatorRebuildCount,0:mpiSelf%count()-1))
     states                    =mpiSelf%gather(self%simulationState    )
     likelihoods               =mpiSelf%gather(self%simulatorLikelihood)
     stateCount                =0
     stateCount(mpiSelf%rank())=self   %accumulatedStateCount
     stateCount                =mpiSelf%sum   (stateCount              )
     ! Allocate workspace arrays.
     allocate(likelihoodsCombined( self%emulatorRebuildCount                                 ))
     allocate(likelihoodsFitted  ( self%emulatorRebuildCount                                 ))
     allocate(workspace          ( self%emulatorRebuildCount                                 ))
     allocate(workspace2D        ( self%emulatorRebuildCount, self%polynomialCoefficientCount))
     allocate(separations        ((self%emulatorRebuildCount*(self%emulatorRebuildCount-1))/2))
     allocate(semiVariances      ((self%emulatorRebuildCount*(self%emulatorRebuildCount-1))/2))
     ! Extract likelihoods and states. We may have more states stored than we actually need. The following algorithm combines
     ! states from chains such that we balance the states used across chains as much as possible. That is, we find the minimum
     ! number of states available from all chains and take that number of states from each chain. If more states are needed, we
     ! find the minimum number of remaining states available from all chains and take that number of states from each chain. The
     ! process is repeated until we have accumulated enough states.
     if (mpiSelf%isMaster()) call Galacticus_Display_Message('extracting states ['//char(Formatted_Date_and_Time())//']')
     j=0
     do while (j < self%emulatorRebuildCount)
        stateCountAccept=min(minval(stateCount,mask=stateCount > 0),max(self%emulatorRebuildCount/mpiSelf%count(),1))
        do i=0,mpiSelf%count()-1
           stateCountAcceptChain=min(stateCountAccept,self%emulatorRebuildCount-j,stateCount(i))
           k=stateCount(i)
           l=0
           do while (l < stateCountAcceptChain .and. k > 0)              
              j                       =j                 +1
              l                       =l                 +1
              likelihoodsCombined(  j)=likelihoods(  k,i)
              self%statesCombined(:,j)=states     (:,k,i)
              if (k < stateCount(i)) states(:,k:stateCount(i)-1,i)=states(:,k+1:stateCount(i),i)
              stateCount         (  i)=stateCount (    i)-1              
              k                       =k                 -correlationLength
           end do
        end do        
     end do
     ! Deallocate workspace.
     deallocate(likelihoods)
     deallocate(stateCount )
     deallocate(states     )
     ! Evaluate mean state.
     self%stateMeans=sum(self%statesCombined,dim=2)/size(self%statesCombined,dim=2)
     ! Subtract means from states.
     do i=1,size(self%statesCombined,dim=2)
        self%statesCombined(:,i)=self%statesCombined(:,i)-self%stateMeans
     end do
     ! Evaluate sums needed in fitting polynomial trend model.
     if (mpiSelf%isMaster()) call Galacticus_Display_Message('fitting global trends (step #1) ['//char(Formatted_Date_and_Time())//']')
     iterator1=polynomialIterator(self%polynomialOrder,simulationState%dimension())
     iterator2=polynomialIterator(self%polynomialOrder,simulationState%dimension())
     ! Pre-compute products over states.
     do while (iterator1%iterate())
        workspace2D(:,iterator1%counter())=1.0d0
        do j=1,iterator1%currentOrder()
           workspace2D(:,iterator1%counter())=workspace2D(:,iterator1%counter())*self%statesCombined(iterator1%index(j),:)
        end do
     end do
     call iterator1%reset()
     if (mpiSelf%isMaster()) call Galacticus_Display_Message('fitting global trends (step #2) ['//char(Formatted_Date_and_Time())//']')
     ! Compute sums over states.
     do while (iterator1%iterate())        
        self%likelihoodSums(iterator1%counter())=sum(workspace2D(:,iterator1%counter())*likelihoodsCombined)
        call iterator2%reset()
        do while (iterator2%iterate())
           self%stateSums(iterator1%counter(),iterator2%counter())=sum(workspace2D(:,iterator1%counter())*workspace2D(:,iterator2%counter()))
        end do
     end do
     if (mpiSelf%isMaster()) call Galacticus_Display_Message('fitting global trends (step #3) ['//char(Formatted_Date_and_Time())//']')
     ! Assign vector and matrix in our linear system.
     likelihoodSums   =self%likelihoodSums
     stateSums        =self%stateSums
     ! Solve for regression coefficients.
     coefficients     =stateSums%linearSystemSolve(likelihoodSums)
     self%coefficients=coefficients
     ! Compute fitted likelihoods.
     if (mpiSelf%isMaster()) call Galacticus_Display_Message('fitting global trends (step #4) ['//char(Formatted_Date_and_Time())//']')
     likelihoodsFitted=0.0d0
     call iterator1%reset()
     do while (iterator1%iterate())    
        workspace=self%coefficients(iterator1%counter())
        do j=1,iterator1%currentOrder()
           workspace=workspace*self%statesCombined(iterator1%index(j),:)
        end do
        likelihoodsFitted=likelihoodsFitted+workspace
     end do
     self%likelihoodResiduals=likelihoodsCombined-likelihoodsFitted
     ! Determine suitable scales for each dimension.
     self%stateScales=maxval(self%statesCombined,dim=2)-minval(self%statesCombined,dim=2)
     ! Compute the variogram.
     if (mpiSelf%isMaster()) call Galacticus_Display_Message('computing variogram ['//char(Formatted_Date_and_Time())//']')
     k=0
     do i=1,self%emulatorRebuildCount-1
        do j=i+1,self%emulatorRebuildCount
           k=k+1
           separations  (k)=likelihoodGaussianRegressionSeparation(self,self%statesCombined(:,i),self%statesCombined(:,j))
           semiVariances(k)= 0.5d0                         &
                &           *(                             &
                &             +self%likelihoodResiduals(i) &
                &             -self%likelihoodResiduals(j) &
                &            )**2
        end do
     end do
     ! Fit the variogram model.
     if (mpiSelf%isMaster()) call Galacticus_Display_Message('fitting variogram ['//char(Formatted_Date_and_Time())//']')
     call likelihoodGaussianRegressionFitVariogram(self,separations,semiVariances)
     ! Compute regression matrix.
     k=0
     if (self%dumpEmulator) then
        self%dumpEmulatorCount=self%dumpEmulatorCount+1
        fileName=self%dumpEmulatorFileRoot//self%dumpEmulatorCount//".log"
        open(newUnit=fileUnit,file=char(fileName),form='formatted',status='unknown')
     end if
     do i=1,self%emulatorRebuildCount
        do j=1,self%emulatorRebuildCount
           separation                =likelihoodGaussianRegressionSeparation(self,self%statesCombined(:,i),self%statesCombined(:,j))
           self%regressionMatrix(i,j)=likelihoodGaussianRegressionCorrelation(self,separation)
           if (self%dumpEmulator) then
              k=k+1
              write (fileUnit,*) i,j,separation,semiVariances(k),self%regressionMatrix(i,j)
           end if
       end do
     end do
     if (self%dumpEmulator) close(fileUnit)
     ! Find the LU decomposition of the regression matrix for later use.
     if (mpiSelf%isMaster()) call Galacticus_Display_Message('computing regression matrix ['//char(Formatted_Date_and_Time())//']')
     self%regressionMatrix(1:self%emulatorRebuildCount  ,  self%emulatorRebuildCount+1)=1.0d0
     self%regressionMatrix(  self%emulatorRebuildCount+1,1:self%emulatorRebuildCount  )=1.0d0
     self%regressionMatrix(  self%emulatorRebuildCount+1,  self%emulatorRebuildCount+1)=0.0d0
     if (FGSL_Well_Defined(self%regressionMatrixLU)) call FGSL_Matrix_Free     (self%regressionMatrixLU)
     if (FGSL_Well_Defined(self%permutations      )) call FGSL_Permutation_Free(self%permutations      )
     self%regressionMatrixLU=FGSL_Matrix_Init      (type=1.0_FGSL_Double)
     self%permutations      =FGSL_Permutation_Alloc(self%regressionMatrixSize)
     status                 =FGSL_Matrix_Align     (self%regressionMatrix,self%regressionMatrixSize,self%regressionMatrixSize,self%regressionMatrixSize,self%regressionMatrixLU)
     status                 =FGSL_LinAlg_LU_Decomp (self%regressionMatrixLU,self%permutations,decompositionSign)     
     determinantSign        =FGSL_Linalg_LU_SgnDet (self%regressionMatrixLU                  ,decompositionSign)
     self%regressionMatrixIsSingular=(determinantSign == 0)
     if (mpiSelf%isMaster().and.self%regressionMatrixIsSingular) call Galacticus_Display_Message('   ==> regression matrix is singular')
     ! Retain (the most recent) 50% of the required number of points.
     self%simulatorLikelihood  (  1:self%accumulatedStateCount/2)=self%simulatorLikelihood(  self%accumulatedStateCount/2+1:2*(self%accumulatedStateCount/2))
     self%simulationState      (:,1:self%accumulatedStateCount/2)=self%simulationState    (:,self%accumulatedStateCount/2+1:2*(self%accumulatedStateCount/2))
     self%accumulatedStateCount                                  =                           self%accumulatedStateCount/2
     ! Deallocate workspace.
     deallocate(likelihoodsCombined)
     deallocate(likelihoodsFitted  )
     deallocate(workspace          )
     deallocate(workspace2D        )
     deallocate(semiVariances      )
     deallocate(separations        )
     ! Finished.
     if (mpiSelf%isMaster()) call Galacticus_Display_Unindent('done ['//char(Formatted_Date_and_Time())//']')
  end if
  ! Count evaluations.
  self%evaluationCount=self%evaluationCount+1
  ! Ensure arrays are allocated.
  if (.not.allocated(self%simulatorLikelihood)) then
     call allocateArray(self%simulatorLikelihood,[                            self%emulatorRebuildCount])
     call allocateArray(self%simulationState    ,[simulationState%dimension(),self%emulatorRebuildCount])
  end if
  likelihoodIsSimulated=.false.
  if (self%initialized.and..not.self%regressionMatrixIsSingular) then
     ! Perform the emulation.
     call likelihoodGaussianRegressionEmulate(self,simulationState,likelihoodGaussianRegressionEvaluate,likelihoodError)
     if (present(logLikelihoodVariance)) logLikelihoodVariance=likelihoodError**2
     ! Test likelihood emulation. We do this whenever the emulator is currently rated "not good", and periodically otherwise to
     ! monitor emulator behavior. When first initialized, the emulator is rated "not good" such that it has to prove that it is
     ! valid before we actually begin using it.
     if (.not.self%isGood .or. (mod(self%evaluationCount,self%reportCount) == 0 .and. self%evaluationCount > 0)) then
        ! Every so many steps we evaluate the simulated likelihood and check that our emulator is reliable.
        likelihoodEmulated                  =likelihoodGaussianRegressionEvaluate
        likelihoodGaussianRegressionEvaluate=self%simulatorLikelihoodFunction%evaluate(simulationState,parameterMappings,simulationConvergence,temperature,logLikelihoodCurrent,logPriorCurrent,logPriorProposed,timeEvaluate,logLikelihoodVariance)
        likelihoodIsSimulated               =.true.
        ! Check that a non-impossible likelihood was returned.
        if (likelihoodGaussianRegressionEvaluate > logImpossible) then
           ! Count number of emulator checks and the failure rate.
           self%emulatorCheckCount=self%emulatorCheckCount+1
           if     (                                                                                                                    &
                &   abs(likelihoodEmulated-likelihoodGaussianRegressionEvaluate) > emulatorFailureSignificance        *likelihoodError &
                &  .and.                                                                                                               &
                &   abs(likelihoodEmulated-likelihoodGaussianRegressionEvaluate) > emulatorFailureSignificanceAbsolute                 &
                & ) self%emulatorFailCount=self%emulatorFailCount+1
        end if
        checksTotal  =mpiSelf%sum(self%emulatorCheckCount)
        failuresTotal=mpiSelf%sum(self%emulatorFailCount )
        ! Determine if the emulator is sufficiently good to use or not.
        failureRateExpected=1.0d0-Error_Function(emulatorFailureSignificance/sqrt(2.0d0))
        self%isGood= checksTotal         > checksTotalMinimum                                         &
             &      .and.                                                                             &
             &       dble(failuresTotal) < emulatorFailureLimit*failureRateExpected*dble(checksTotal) &
             &      .and.                                                                             &
             &       .not.self%dummyEmulator
        ! Report on emulator failure rate.
        if (mpiSelf%isMaster() .and. Galacticus_Verbosity_Level() >= verbosityInfo .and. mod(self%evaluationCount,self%reportCount) == 0 .and. self%evaluationCount > 0) then
           write (label,'(i8)') failuresTotal
           message='Emulator failed '//trim(adjustl(label))//' times out of '
           write (label,'(i8)') checksTotal
           message=message//trim(adjustl(label))//' checks ('
           write (label,'(f6.2)') 100.0d0*dble(failuresTotal)/dble(checksTotal)
           message=message//trim(adjustl(label))//'% - expect '
           write (label,'(f6.2)') 100.0d0*failureRateExpected
           message=message//trim(adjustl(label))//'% for perfect emulator)'
           call Galacticus_Display_Message(message)
           if (.not.self%isGood) call Galacticus_Display_Message('WARNING: emulator failure rate is too high - emulator will not be used')
        end if     
     else        
        if (simulationConvergence%isConverged().and.simulationConvergence%chainIsOutlier(simulationState%chainIndex()).and.self%emulateOutliers) return
        if (likelihoodGaussianRegressionEvaluate+logPriorProposed+self%sigmaBuffer*likelihoodError < logLikelihoodCurrent+logPriorCurrent-self%logLikelihoodBuffer        *temperature) return
        if (                                                                       likelihoodError <                                      self%logLikelihoodErrorTolerance*temperature) return
     end if
  end if
  ! Evaluate the likelihood using the simulator, unless we have already done so.
  self%simulationCount=self%simulationCount+1
  if (.not.likelihoodIsSimulated) then     
     ! If prior probability is impossible, then don't even try to simulate.
     if (logPriorProposed <= logImpossible) then
        likelihoodGaussianRegressionEvaluate=logImpossible
        if (present(logLikelihoodVariance)) logLikelihoodVariance=0.0d0
     else
        likelihoodGaussianRegressionEvaluate=self%simulatorLikelihoodFunction%evaluate(simulationState,parameterMappings,simulationConvergence,temperature,logLikelihoodCurrent,logPriorCurrent,logPriorProposed,timeEvaluate,logLikelihoodVariance)
        ! Store the likelihood and state.
        if (likelihoodGaussianRegressionEvaluate > logImpossible .and. self%accumulatedStateCount < self%emulatorRebuildCount) then
           self%accumulatedStateCount                            =self%accumulatedStateCount+1
           self%simulatorLikelihood(  self%accumulatedStateCount)=likelihoodGaussianRegressionEvaluate
           self%simulationState    (:,self%accumulatedStateCount)=simulationState%get()
        end if
     end if
  end if
  return
end function likelihoodGaussianRegressionEvaluate

elemental double precision function likelihoodGaussianRegressionEvaluateVariogram(self,h)
  !% Compute the variogram at separation {\normalfont \ttfamily h}.
  implicit none
  class           (likelihoodGaussianRegression), intent(in   ) :: self
  double precision                              , intent(in   ) :: h
  
  if (h <= 0.0d0) then
     likelihoodGaussianRegressionEvaluateVariogram=self%C0
  else if (h < self%CR) then
     likelihoodGaussianRegressionEvaluateVariogram=self%C0+self%C1*(1.5d0*h/self%CR-0.5d0*(h/self%CR)**3)
  else
     likelihoodGaussianRegressionEvaluateVariogram=self%C0+self%C1
  end if
  return
end function likelihoodGaussianRegressionEvaluateVariogram

elemental double precision function likelihoodGaussianRegressionCorrelation(self,h)
  !% Compute correlation of the variogram model.
  implicit none
  class           (likelihoodGaussianRegression), intent(in   ) :: self
  double precision                              , intent(in   ) :: h
  
  likelihoodGaussianRegressionCorrelation=self%C0+self%C1-likelihoodGaussianRegressionEvaluateVariogram(self,h)
  return
end function likelihoodGaussianRegressionCorrelation

double precision function likelihoodGaussianRegressionSeparation(self,state1,state2)
  !% Determine the separation between two state vectors.
  implicit none
  class           (likelihoodGaussianRegression)              , intent(in   ) :: self
  double precision                              , dimension(:), intent(in   ) :: state1, state2

  likelihoodGaussianRegressionSeparation=sqrt(sum(((state1-state2)/self%stateScales)**2))
  return
end function likelihoodGaussianRegressionSeparation

subroutine likelihoodGaussianRegressionFitVariogram(self,separations,semiVariances)
  !% Compute best fit coefficients for the variogram model.
  use, intrinsic :: ISO_C_Binding
  use Galacticus_Error
  use FGSL
  use Sort
  implicit none
  class           (likelihoodGaussianRegression), intent(inout)               :: self
  double precision                              , intent(in   ), dimension(:) :: separations                , semiVariances
  double precision                              , target       , dimension(3) :: C
  real            (fgsl_double                 ), pointer      , dimension(:) :: cPtr
  integer         (c_size_t                    ), allocatable  , dimension(:) :: rank
  integer                                       , parameter                   :: iterationsMaximum   =10000
  double precision                              , parameter                   :: gradientTolerance   =1.0d-2
  double precision                              , parameter                   :: binWidthMaximum     =2.0d0
  integer                                       , parameter                   :: binCountMaximum     =100000
  type            (fgsl_multimin_function_fdf  )                              :: minimizationFunction
  type            (fgsl_multimin_fdfminimizer  )                              :: minimizer
  type            (fgsl_vector                 )                              :: cVector
  type            (c_ptr                       )                              :: parameters
  integer                                                                     :: status                     , iteration
  integer         (c_size_t                    )                              :: k                          , j        , &
       &                                                                         i
  double precision                                                            :: currentMinimum

  ! Allocate workspace.  
  allocate(separationsNormalized  (size(separations)))
  allocate(separationsLimited     (size(separations)))
  allocate(semiVariancesNormalized(size(separations)))
  allocate(semiVariancesBinned    (size(separations)))
  allocate(separationsBinned      (size(separations)))
  allocate(rank                   (size(separations)))
  ! Compute normalized separations and variances.
  separationNormalization  =sum(separations  )/dble(size(separations))
  semiVarianceNormalization=sum(semiVariances)/dble(size(separations))
  separationsNormalized    =separations       /separationNormalization
  semiVariancesNormalized  =semiVariances     /semiVarianceNormalization
  ! Get rank ordering by separation.
  rank=Sort_Index_Do(separationsNormalized)
  ! Compute binned estimates of the mean semi-variances.
  binCount=0
  j       =0
  k       =1
  do while (.true.)
     j=j+1
     if (j-k == binCountMaximum .or. separationsNormalized(rank(j)) > binWidthMaximum*separationsNormalized(rank(k)) .or. j == size(separations)) then
        binCount=binCount+1
        separationsBinned  (binCount)=0.0d0
        semiVariancesBinned(binCount)=0.0d0        
        do i=k,j
           separationsBinned  (binCount)=separationsBinned  (binCount)+separationsNormalized  (rank(i))
           semiVariancesBinned(binCount)=semiVariancesBinned(binCount)+semiVariancesNormalized(rank(i))
        end do
        separationsBinned  (binCount)=separationsBinned  (binCount)/dble(j-k+1)
        semiVariancesBinned(binCount)=semiVariancesBinned(binCount)/dble(j-k+1)
        k=j+1
        if (j == size(separations)) exit
     end if
  end do
  ! Initialize the minimizer.
  minimizationFunction=FGSL_MultiMin_Function_FDF_Init(                                              &
       &                                               likelihoodGaussianRegressionVariogramModelF , &
       &                                               likelihoodGaussianRegressionVariogramModelD , &
       &                                               likelihoodGaussianRegressionVariogramModelFD, &
       &                                               3_FGSL_Size_T                               , &
       &                                               parameters                                    &
       &                                              )
  minimizer=FGSL_MultiMin_FDFMinimizer_Alloc(FGSL_MultiMin_FDFMinimizer_Conjugate_PR,3_FGSL_Size_T)
  cVector  =FGSL_Vector_Init(type=1.0_FGSL_Double)
  C        =[semiVariancesBinned(1),semiVariancesBinned(binCount),separationsBinned(binCount/2)] ! Initial guess for the parameters.
  status   =FGSL_Vector_Align(C,3_FGSL_Size_T,cVector,3_FGSL_Size_T,0_FGSL_Size_T,1_FGSL_Size_T)
  if (status /= FGSL_Success) call Galacticus_Error_Report('likelihoodGaussianRegressionFitVariogram','failed to initialize parameter vector')
  status   =FGSL_MultiMin_FDFMinimizer_Set(minimizer,minimizationFunction,cVector,0.01d0,0.1d0)
  if (status /= FGSL_Success) call Galacticus_Error_Report('likelihoodGaussianRegressionFitVariogram','failed to set minimizer')
  ! Iterate the minimizer until a sufficiently good solution is found.
  currentMinimum=0.0d0
  iteration     =0
  do while (                                                                                                                                   &
       &     FGSL_MultiMin_Test_Gradient(FGSL_MultiMin_FDFMinimizer_Gradient(minimizer),gradientTolerance*currentMinimum) == FGSL_Continue     &
       &    .and.                                                                                                                              &
       &     iteration                                                                                                    <  iterationsMaximum &
       &   )
     iteration     =iteration+1
     status        =FGSL_MultiMin_FDFMinimizer_Iterate(minimizer)
     currentMinimum=FGSL_MultiMin_FDFMinimizer_Minimum(minimizer)
     if (status == FGSL_ENoProg) exit
     if (status /= FGSL_Success) call Galacticus_Error_Report('likelihoodGaussianRegressionFitVariogram','failed to iterate minimizer')  
  end do
  ! Extract the best fit parameters.
  call FGSL_Vector_Free(cVector)
  cVector=FGSL_Vector_Init            (type=1.0_FGSL_Double        )
  cVector=FGSL_Multimin_FDFMinimizer_x(     minimizer              )
  status =FGSL_Vector_Align           (     cPtr           ,cVector)
  self%C0=cPtr(1)*semiVarianceNormalization
  self%C1=cPtr(2)*semiVarianceNormalization
  self%CR=cPtr(3)*separationNormalization
  ! Clean up.
  call FGSL_MultiMin_FDFMinimizer_Free(minimizer           )
  call FGSL_MultiMin_Function_FDF_Free(minimizationFunction)
  deallocate(separationsNormalized  )
  deallocate(separationsLimited     )
  deallocate(semiVariancesNormalized)
  deallocate(separationsBinned      )
  deallocate(semiVariancesBinned    )
  deallocate(rank                   )
  return
end subroutine likelihoodGaussianRegressionFitVariogram

function likelihoodGaussianRegressionVariogramModelF(x, parameters) bind(c)
  !% Function to be minimized when fitting the variogram.
  use, intrinsic :: ISO_C_Binding
  implicit none
  real   (c_double   )                        :: likelihoodGaussianRegressionVariogramModelF
  type   (c_ptr      ), value                 :: x                                          , parameters
  real   (FGSL_double), pointer, dimension(:) :: xx
  type   (FGSL_vector)                        :: vec
  integer(FGSL_int   )                        :: status
  !GCC$ attributes unused :: parameters
  
  call FGSL_obj_c_ptr(vec,x)
  status=FGSL_vector_align(xx,vec)
  where (separationsBinned(1:binCount) > xx(3))
     separationsLimited(1:binCount)=xx(3)
  elsewhere
     separationsLimited(1:binCount)=separationsBinned(1:binCount)
  end where
  likelihoodGaussianRegressionVariogramModelF=sum(((xx(1)+xx(2)*(1.5d0*separationsLimited(1:binCount)/xx(3)-0.5d0*(separationsLimited(1:binCount)/xx(3))**3))/semiVariancesBinned(1:binCount)-1.0d0)**2)
  return
end function likelihoodGaussianRegressionVariogramModelF

subroutine likelihoodGaussianRegressionVariogramModelD(x,parameters,df) bind(c)
  !% Derivatives of the function to be minimized when fitting the variogram.
  use, intrinsic :: ISO_C_Binding
  implicit none
  type   (c_ptr      ), value                 :: x     , parameters, &
       &                                         df
  real   (c_double   ), pointer, dimension(:) :: xx    , ddf
  type   (FGSL_vector)                        :: vec   , grad
  integer(FGSL_int   )                        :: status  
  !GCC$ attributes unused :: parameters
  
  call FGSL_obj_c_ptr(vec ,x )
  call FGSL_obj_c_ptr(grad,df)
  status=FGSL_vector_align(xx ,vec )
  status=FGSL_vector_align(ddf,grad)   
  where (separationsBinned > xx(3))
     separationsLimited(1:binCount)=xx(3)
  elsewhere
     separationsLimited(1:binCount)=separationsBinned(1:binCount)
  end where
  ddf(1)=2.0d0*sum(((xx(1)+xx(2)*(1.5d0*separationsLimited(1:binCount)/xx(3)-0.5d0*(separationsLimited(1:binCount)/xx(3))**3))/semiVariancesBinned(1:binCount)-1.0d0)/semiVariancesBinned(1:binCount))
  ddf(2)=2.0d0*sum(((xx(1)+xx(2)*(1.5d0*separationsLimited(1:binCount)/xx(3)-0.5d0*(separationsLimited(1:binCount)/xx(3))**3))/semiVariancesBinned(1:binCount)-1.0d0)*(1.5d0*separationsLimited(1:binCount)/xx(3)-0.5d0*(separationsLimited(1:binCount)/xx(3))**3)/semiVariancesBinned(1:binCount))
  ddf(3)=2.0d0*sum(((xx(1)+xx(2)*(1.5d0*separationsLimited(1:binCount)/xx(3)-0.5d0*(separationsLimited(1:binCount)/xx(3))**3))/semiVariancesBinned(1:binCount)-1.0d0)*xx(2)*(-1.5d0*separationsLimited(1:binCount)/xx(3)+1.5d0*(separationsLimited(1:binCount)/xx(3))**3)/xx(3)/semiVariancesBinned(1:binCount))
  where(abs(ddf) < 1.0d-30)
     ddf=1.0d-30
  end where
  return
end subroutine likelihoodGaussianRegressionVariogramModelD

subroutine likelihoodGaussianRegressionVariogramModelFD(x, parameters, f, df) bind(c)
  !% Computes both function and derivatives to be minimized when fitting the variogram.
  use, intrinsic :: ISO_C_Binding
  implicit none
  type(c_ptr   ), value :: x , parameters, &
       &                   df
  real(c_double)        :: f
  
  f=   likelihoodGaussianRegressionVariogramModelF(x,parameters   )
  call likelihoodGaussianRegressionVariogramModelD(x,parameters,df)
  return
end subroutine likelihoodGaussianRegressionVariogramModelFD

integer function polynomialCoefficientCount(n,d)
  !% Return the number of coefficients at {\normalfont \ttfamily n}$^{\mathrm th}$ order in polynomial of dimension {\normalfont \ttfamily d}.
  use Factorials
  implicit none
  integer, intent(in   ) :: n,d

  if (n == 2) then
     polynomialCoefficientCount=(d*(1+d))/2
  else
     polynomialCoefficientCount=nint(Factorial(d+n-1)/Factorial(n)/Factorial(d-1))
  end if
  return
end function polynomialCoefficientCount

function polynomialIteratorConstructor(order,rank)
  !% Create a polynomial iterator for a poynomial of specified {\normalfont \ttfamily order} and {\normalfont \ttfamily rank}.
  use Memory_Management
  implicit none
  type   (polynomialIterator)                :: polynomialIteratorConstructor
  integer                    , intent(in   ) :: order                        , rank

  call allocateArray(polynomialIteratorConstructor%indices,[order])
  polynomialIteratorConstructor     %order=order
  polynomialIteratorConstructor     %rank =rank
  call polynomialIteratorConstructor%reset()
  return
end function polynomialIteratorConstructor

subroutine polynomialIteratorReset(self)
  !% Reset a polynomial iterator.
  implicit none
  class(polynomialIterator), intent(inout) :: self

  self%orderCurrent=-1
  self%stateCurrent=-1
  self%count       = 0
  self%indices     = 0
  return
end subroutine polynomialIteratorReset

logical function polynomialIteratorIterate(self)
  !% Iterate over polynomial coefficients.
  implicit none
  class  (polynomialIterator), intent(inout) :: self
  integer                                    :: j

  polynomialIteratorIterate=.true.
  self%count=self%count+1
  if     (                                                                              &
       &   self%stateCurrent <  0                                                       &
       &  .or.                                                                          &
       &   self%stateCurrent >= polynomialCoefficientCount(self%orderCurrent,self%rank) &
       & ) then
     ! Move to next polynomial order.
     self%orderCurrent=self%orderCurrent+1
     if (self%orderCurrent > self%order) then
        polynomialIteratorIterate=.false.
     else
        self%stateCurrent                     =1
        self%indices     (1:self%orderCurrent)=1
     end if
  else
     self%stateCurrent=self%stateCurrent+1
     j=self%orderCurrent
     do while (j > 0)
        self%indices(j)=self%indices(j)+1
        if (self%indices(j) > self%rank) then
           self%indices(j)=self%indices(j-1)+1
           j=j-1
        else
           j=0
        end if
     end do
  end if
  return
end function polynomialIteratorIterate

integer function polynomialIteratorIndex(self,i)
  !% Return the requested index of a polynomial iterator.
  implicit none
  class  (polynomialIterator), intent(inout) :: self
  integer                    , intent(in   ) :: i

  polynomialIteratorIndex=self%indices(i)
  return
end function polynomialIteratorIndex

integer function polynomialIteratorCurrentOrder(self)
  !% Return the current order of a polynomial iterator.
  implicit none
  class  (polynomialIterator), intent(inout) :: self

  polynomialIteratorCurrentOrder=self%orderCurrent
  return
end function polynomialIteratorCurrentOrder

integer function polynomialIteratorCounter(self)
  !% Return the current count of a polynomial iterator.
  implicit none
  class  (polynomialIterator), intent(inout) :: self

  polynomialIteratorCounter=self%count
  return
end function polynomialIteratorCounter

subroutine likelihoodGaussianRegressionFunctionChanged(self)
  !% Respond to possible changes in the likelihood function.
  use Memory_Management
  implicit none
  class(likelihoodGaussianRegression), intent(inout) :: self

  ! Reset emulator state.
  self%initialized          =.false.
  self%accumulatedStateCount=0
  self%simulationCount      =0
  self%evaluationCount      =0
  self%emulatorCheckCount   =0
  self%emulatorFailCount    =0
  ! Free allocated space.
  if (allocated(self%polynomialCoefficient)) call deallocateArray(self%polynomialCoefficient)
  if (allocated(self%likelihoodSums       )) call deallocateArray(self%likelihoodSums       )
  if (allocated(self%stateSums            )) call deallocateArray(self%stateSums            )
  if (allocated(self%coefficients         )) call deallocateArray(self%coefficients         )
  if (allocated(self%regressionMatrix     )) call deallocateArray(self%regressionMatrix     )
  if (allocated(self%stateOffset          )) call deallocateArray(self%stateOffset          )
  if (allocated(self%weight               )) call deallocateArray(self%weight               )
  if (allocated(self%likelihoodResiduals  )) call deallocateArray(self%likelihoodResiduals  )
  if (allocated(self%statesCombined       )) call deallocateArray(self%statesCombined       )
  if (allocated(self%stateScales          )) call deallocateArray(self%stateScales          )
  if (allocated(self%stateMeans           )) call deallocateArray(self%stateMeans           )
  ! Let the simulator know that the likelihood function may have changed.
  call self%simulatorLikelihoodFunction%functionChanged()
  return
end subroutine likelihoodGaussianRegressionFunctionChanged

logical function likelihoodGaussianRegressionWillEvaluate(self,simulationState,parameterMappings,simulationConvergence,temperature,logLikelihoodCurrent,logPriorCurrent,logPriorProposed)
  !% Return true if the log-likelihood will be evaluated.
  use, intrinsic :: ISO_C_Binding
  use Constraints_State
  use Constraints_Convergence
  use Constraints_Constants
  use Galacticus_Display
  implicit none
  class           (likelihoodGaussianRegression  ), intent(inout)               :: self
  class           (state                         ), intent(in   )               :: simulationState
  type            (mappingList                   ), intent(in   ), dimension(:) :: parameterMappings
  class           (convergence                   ), intent(inout)               :: simulationConvergence
  double precision                                , intent(in   )               :: temperature                      , logLikelihoodCurrent, &
       &                                                                           logPriorCurrent                  , logPriorProposed
  double precision                                                              :: likelihoodEmulated               , likelihoodEmulatedError
  !GCC$ attributes unused :: parameterMappings

  if (logPriorProposed <= logImpossible) then
     ! Prior is impossible, no need to evaluate.
     likelihoodGaussianRegressionWillEvaluate=.false.
     return
  else
     likelihoodGaussianRegressionWillEvaluate=.true.
  end if
  if (self%initialized.and..not.self%regressionMatrixIsSingular) then
     if (mod(self%evaluationCount,self%reportCount) == 0 .and. self%evaluationCount > 0 .and. Galacticus_Verbosity_Level() >= verbosityInfo) then
        ! Emulation will be tested, so the simulator is always run.
        likelihoodGaussianRegressionWillEvaluate=.true.
        return
     else
        ! Evaluate the emulator.
        call likelihoodGaussianRegressionEmulate(self,simulationState,likelihoodEmulated,likelihoodEmulatedError)
        ! If simulation is converged, this is an outlier chain, and we're told to emulate such outliers, then return.
        if (simulationConvergence%isConverged().and.simulationConvergence%chainIsOutlier(simulationState%chainIndex()).and.self%emulateOutliers) likelihoodGaussianRegressionWillEvaluate=.false.
        ! If likelihood is well below current likelihood (and this should be sufficient that changes in priors won't affect the
        ! conclusion), then use the emulated likelihood. We scale the likelihood buffer by the current temperature to reflect the
        ! fact that transitions between states are easier when the temperature is high.
        if (likelihoodEmulated+logPriorProposed+self%sigmaBuffer*likelihoodEmulatedError < logLikelihoodCurrent+logPriorCurrent-self%logLikelihoodBuffer        *temperature) likelihoodGaussianRegressionWillEvaluate=.false.
        ! Return if the error is below the tolerance. We increase the tolerance value in proportion to temperature since the
        ! likelihoods will be divided by this amount when evaluating transition probabilties.
        if (likelihoodEmulatedError                                                      <                                      self%logLikelihoodErrorTolerance*temperature) likelihoodGaussianRegressionWillEvaluate=.false.
     end if
     return
  else
     ! Evaluate the simulator.
     likelihoodGaussianRegressionWillEvaluate=.true.
  end if
  return
end function likelihoodGaussianRegressionWillEvaluate

subroutine likelihoodGaussianRegressionEmulate(self,simulationState,likelihoodEmulated,likelihoodEmulatedError)
  !% Evaluate the model emulator.
  implicit none
  class           (likelihoodGaussianRegression  ), intent(inout)               :: self
  class           (state                         ), intent(in   )               :: simulationState
  double precision                                , intent(  out)               :: likelihoodEmulated        , likelihoodEmulatedError
  double precision                                , allocatable  , dimension(:) :: stateCurrent
  double precision                                , parameter                   :: likelihoodErrorLarge=1.0d6
  integer                                                                       :: i                         , j
  double precision                                                              :: separation                , likelihoodFit
  type            (fgsl_vector                   )                              :: stateOffsetVector         , weightVector
  integer         (kind=FGSL_Int                 )                              :: status
  type            (polynomialIterator            )                              :: iterator1

  ! Compute vector D.
  stateCurrent=simulationState%get()-self%stateMeans
  do i=1,self%emulatorRebuildCount
     separation         =likelihoodGaussianRegressionSeparation (self,stateCurrent,self%statesCombined(:,i))
     self%stateOffset(i)=likelihoodGaussianRegressionCorrelation(self,separation                           )
  end do
  self%stateOffset(self%emulatorRebuildCount+1)=1.0d0
  ! Solve the linear system.
  stateOffsetVector=FGSL_Vector_Init(type=1.0_FGSL_Double)
  weightVector     =FGSL_Vector_Init(type=1.0_FGSL_Double)
  status           =FGSL_Vector_Align(self%stateOffset,self%regressionMatrixSize,stateOffsetVector,self%regressionMatrixSize,0_FGSL_Size_T,1_FGSL_Size_T)
  status           =FGSL_Vector_Align(self%weight     ,self%regressionMatrixSize,weightVector     ,self%regressionMatrixSize,0_FGSL_Size_T,1_FGSL_Size_T)
  status           =FGSL_LinAlg_LU_Solve(self%regressionMatrixLU,self%permutations,stateOffsetVector,weightVector)
  call FGSL_Vector_Free(weightVector     )
  call FGSL_Vector_Free(stateOffsetVector)
  ! Compute the likelihood and variance.
  likelihoodEmulated     =sum(self%likelihoodResiduals*self%weight(1:self%emulatorRebuildCount))
  likelihoodEmulatedError=likelihoodGaussianRegressionCorrelation(self,0.0d0)-sum(self%weight*self%stateOffset)
  if (likelihoodEmulatedError >= 0.0d0) then
     likelihoodEmulatedError=sqrt(likelihoodEmulatedError)
  else
     likelihoodEmulatedError=likelihoodErrorLarge
  end if
  iterator1=polynomialIterator(self%polynomialOrder,simulationState%dimension())
  do while (iterator1%iterate())
     likelihoodFit=self%coefficients(iterator1%counter())
     do j=1,iterator1%currentOrder()
        likelihoodFit=likelihoodFit*stateCurrent(iterator1%index(j))
     end do
     likelihoodEmulated=likelihoodEmulated+likelihoodFit        
  end do
  return
end subroutine likelihoodGaussianRegressionEmulate

subroutine likelihoodGaussianRegressionRestore(self,simulationState,logLikelihood)
  !% Process a previous state to restore likelihood function.
  use Constraints_Constants
  use Memory_Management
  implicit none
  class           (likelihoodGaussianRegression), intent(inout)               :: self
  double precision                              , intent(in   ), dimension(:) :: simulationState
  double precision                              , intent(in   )               :: logLikelihood
  logical                                                                     :: storeState

  if (logLikelihood > logImpossible) then
     if (.not.allocated(self%simulatorLikelihood)) then
        call allocateArray(self%simulatorLikelihood,[                      self%emulatorRebuildCount])
        call allocateArray(self%simulationState    ,[size(simulationState),self%emulatorRebuildCount])
     end if
     if (self%accumulatedStateCount == self%emulatorRebuildCount) then
        ! Discard the oldest state.
        self%simulatorLikelihood  (  1:self%emulatorRebuildCount-1)=self%simulatorLikelihood  (  2:self%emulatorRebuildCount)
        self%simulationState      (:,1:self%emulatorRebuildCount-1)=self%simulationState      (:,2:self%emulatorRebuildCount)
        self%accumulatedStateCount                                 =self%accumulatedStateCount                               -1
     end if
     ! Store the state unless it is identical to the previous state.
     storeState=self%accumulatedStateCount == 0
     if (.not.storeState) storeState=any(simulationState /= self%simulationState(:,self%accumulatedStateCount))
     if (storeState) then
        self%accumulatedStateCount=min(self%accumulatedStateCount+1,self%emulatorRebuildCount)
        self%simulatorLikelihood(  self%accumulatedStateCount)=logLikelihood
        self%simulationState    (:,self%accumulatedStateCount)=simulationState
     end if
  end if
  return
end subroutine likelihoodGaussianRegressionRestore

