!! Copyright 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018
!!    Andrew Benson <abenson@carnegiescience.edu>
!!
!! This file is part of Galacticus.
!!
!!    Galacticus is free software: you can redistribute it and/or modify
!!    it under the terms of the GNU General Public License as published by
!!    the Free Software Foundation, either version 3 of the License, or
!!    (at your option) any later version.
!!
!!    Galacticus is distributed in the hope that it will be useful,
!!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!!    GNU General Public License for more details.
!!
!!    You should have received a copy of the GNU General Public License
!!    along with Galacticus.  If not, see <http://www.gnu.org/licenses/>.

!% Defines methods for a mass function likelihood function.

function likelihoodMassFunctionConstructor(haloMassMinimum,haloMassMaximum,redshiftMinimum,redshiftMaximum,useSurveyLimits,massFunctionFileName,modelSurfaceBrightness,surfaceBrightnessLimit)
  !% Constructor for the mass function likelihood class.
  use Galacticus_Input_Paths
  use IO_HDF5
  use Memory_Management
  use Galacticus_Display
  implicit none
  type            (likelihoodMassFunction)                              :: likelihoodMassFunctionConstructor
  double precision                        , intent(in   )               :: redshiftMinimum                  , redshiftMaximum       , &
       &                                                                   haloMassMinimum                  , haloMassMaximum       , &
       &                                                                   surfaceBrightnessLimit
  logical                                 , intent(in   )               :: useSurveyLimits                  , modelSurfaceBrightness
  character       (len=*                 ), intent(in   )               :: massFunctionFileName
  double precision                        , allocatable  , dimension(:) :: massBinWidth                     , eigenValueArray
  type            (hdf5Object            )                              :: massFunctionFile
  integer                                                               :: i
  type            (matrix                )                              :: eigenVectors
  type            (vector                )                              :: eigenValues

  likelihoodMassFunctionConstructor%useSurveyLimits=useSurveyLimits
  likelihoodMassFunctionConstructor%       haloMassMinimum=      haloMassMinimum
  likelihoodMassFunctionConstructor%       haloMassMaximum=      haloMassMaximum
  likelihoodMassFunctionConstructor%    logHaloMassMinimum=log10(haloMassMinimum)
  likelihoodMassFunctionConstructor%    logHaloMassMaximum=log10(haloMassMaximum)
  likelihoodMassFunctionConstructor%       redshiftMinimum=      redshiftMinimum
  likelihoodMassFunctionConstructor%       redshiftMaximum=      redshiftMaximum
  likelihoodMassFunctionConstructor%modelSurfaceBrightness=      modelSurfaceBrightness
  likelihoodMassFunctionConstructor%surfaceBrightnessLimit=      surfaceBrightnessLimit
  ! Read the mass function file.
  !$omp critical(HDF5_Access)
  call massFunctionFile%openFile(char(Galacticus_Input_Path())//massFunctionFileName,readOnly=.true.)
  call massFunctionFile%readDataset("mass"                ,likelihoodMassFunctionConstructor%mass                )
  call massFunctionFile%readDataset("massFunctionObserved",likelihoodMassFunctionConstructor%massFunctionObserved)
  call massFunctionFile%readDataset("covariance"          ,likelihoodMassFunctionConstructor%covarianceMatrix    )
  ! Compute mass bin limits.
  call allocateArray(likelihoodMassFunctionConstructor%massFunction,shape(likelihoodMassFunctionConstructor%mass))
  call allocateArray(likelihoodMassFunctionConstructor%massMinimum ,shape(likelihoodMassFunctionConstructor%mass))
  call allocateArray(likelihoodMassFunctionConstructor%massMaximum ,shape(likelihoodMassFunctionConstructor%mass))
  if (massFunctionFile%hasDataset("massWidthObserved")) then
     call massFunctionFile%readDataset("massWidthObserved",massBinWidth)
     do i=1,size(likelihoodMassFunctionConstructor%mass)
        likelihoodMassFunctionConstructor%massMinimum(i)=likelihoodMassFunctionConstructor%mass(i)/sqrt(massBinWidth(i))
        likelihoodMassFunctionConstructor%massMaximum(i)=likelihoodMassFunctionConstructor%mass(i)*sqrt(massBinWidth(i))
     end do
     call deallocateArray(massBinWidth)
  else
     do i=1,size(likelihoodMassFunctionConstructor%mass)
        if (i ==                                            1) then
           likelihoodMassFunctionConstructor              %massMinimum(i  ) &
                & =      likelihoodMassFunctionConstructor%mass       (i  ) &
                & *sqrt(                                                    &
                &        likelihoodMassFunctionConstructor%mass       (i  ) &
                &       /likelihoodMassFunctionConstructor%mass       (i+1) &
                &      )
        else
           likelihoodMassFunctionConstructor              %massMinimum(i  ) &
                & =sqrt(                                                    &
                &        likelihoodMassFunctionConstructor%mass       (i-1) &
                &       *likelihoodMassFunctionConstructor%mass       (i  ) &
                &      )
        end if
        if (i == size(likelihoodMassFunctionConstructor%mass)) then
           likelihoodMassFunctionConstructor              %massMaximum(i  ) &
                & =      likelihoodMassFunctionConstructor%mass       (i  ) &
                & *sqrt(                                                    &
                &        likelihoodMassFunctionConstructor%mass       (i  ) &
                &       /likelihoodMassFunctionConstructor%mass       (i-1) &
                &      )
        else
           likelihoodMassFunctionConstructor              %massMaximum(i  ) &
                & =sqrt(                                                    &
                &        likelihoodMassFunctionConstructor%mass       (i  ) &
                &       *likelihoodMassFunctionConstructor%mass       (i+1) &
                &      )
        end if
     end do
  end if
  call massFunctionFile%close()
  !$omp end critical(HDF5_Access)
  ! Find the inverse covariance matrix.
  likelihoodMassFunctionConstructor%covariance       =likelihoodMassFunctionConstructor%covarianceMatrix
  likelihoodMassFunctionConstructor%inverseCovariance=likelihoodMassFunctionConstructor%covariance      %invert()
  ! Symmetrize the inverse covariance matrix.
  call likelihoodMassFunctionConstructor%inverseCovariance%symmetrize()
  ! Get eigenvalues and vectors of the inverse covariance matrix.
  allocate(eigenValueArray(size(likelihoodMassFunctionConstructor%mass)))
  call likelihoodMassFunctionConstructor%inverseCovariance%eigenSystem(eigenVectors,eigenValues)
  eigenValueArray=eigenValues
  if (any(eigenValueArray < 0.0d0)) call Galacticus_Display_Message('WARNING: inverse covariance matrix is not semi-positive definite')
  deallocate(eigenValueArray)
  return
end function likelihoodMassFunctionConstructor

double precision function likelihoodMassFunctionEvaluate(self,simulationState,parameterMappings,simulationConvergence,temperature,logLikelihoodCurrent,logPriorCurrent,logPriorProposed,timeEvaluate,logLikelihoodVariance)
  !% Return the log-likelihood for the mass function likelihood function.
  use Constraints_State
  use Constraints_Constants
  use Constraints_Convergence
  use Conditional_Mass_Functions
  use Cosmology_Functions
  use Geometry_Surveys
  use Numerical_Integration
  use Galacticus_Error
  use Mass_Function_Incompletenesses
  use Halo_Mass_Functions
  implicit none
  class           (likelihoodMassFunction                     ), intent(inout)               :: self
  class           (state                                      ), intent(inout)               :: simulationState
  type            (mappingList                                ), intent(in   ), dimension(:) :: parameterMappings
  class           (convergence                                ), intent(inout)               :: simulationConvergence
  double precision                                             , intent(in   )               :: temperature                    , logLikelihoodCurrent              , &
       &                                                                                        logPriorCurrent                , logPriorProposed
  real                                                         , intent(inout)               :: timeEvaluate
  double precision                                             , intent(  out), optional     :: logLikelihoodVariance
  double precision                                             , allocatable  , dimension(:) :: stateVector
  class           (cosmologyFunctionsClass                    ), pointer                     :: cosmologyFunctions_
  class           (surveyGeometryClass                        ), pointer                     :: surveyGeometry_
  class           (haloMassFunctionClass                      ), pointer                     :: haloMassFunction_
  type            (conditionalMassFunctionBehroozi2010        )                              :: thisConditionalMassFunction
  type            (massFunctionIncompletenessSurfaceBrightness)                              :: massFunctionIncompletenessModel
  type            (fgsl_function                              )                              :: integrandFunction               , integrandFunctionNormalization
  type            (fgsl_integration_workspace                 )                              :: integrationWorkspace            , integrationWorkspaceNormalization
  type            (vector                                     )                              :: difference
  integer                                                                                    :: i                               , j
  double precision                                                                           :: binTimeMinimum                  , binTimeMaximum                    , &
       &                                                                                        timeMinimum                     , timeMaximum                       , &
       &                                                                                        distanceMaximum                 , time                              , &
       &                                                                                        massFunction                    , normalization
  logical                                                                                    :: integrationReset                , integrationResetNormalization
  !GCC$ attributes unused :: logLikelihoodCurrent, logPriorCurrent, simulationConvergence, temperature, timeEvaluate
  
  ! There is no variance in our likelihood estimate.
  if (present(logLikelihoodVariance)) logLikelihoodVariance=0.0d0
  ! Do not evaluate if the proposed prior is impossible.
  if (logPriorProposed <= logImpossible) then
     likelihoodMassFunctionEvaluate=0.0d0
     return
  end if
  ! Get required objects.
  cosmologyFunctions_ => cosmologyFunctions()     
  haloMassFunction_   => haloMassFunction  ()
  ! Get the default survey geometry object.
  surveyGeometry_     => surveyGeometry    ()     
  ! Construct the conditional mass function object.
  stateVector=simulationState%get()
  if     (                                                                  &
       &   (.not.self%modelSurfaceBrightness .and. size(stateVector) /= 11) &
       &  .or.                                                              &
       &   (     self%modelSurfaceBrightness .and. size(stateVector) /= 14) &
       & )                                                                  &
       & call Galacticus_Error_Report('11 or 14 parameters are required for this likelihood function'//{introspection:location})
  do i=1,size(stateVector)
     stateVector(i)=parameterMappings(i)%thisMapping%unmap(stateVector(i))
  end do
  thisConditionalMassFunction                                  &
       & =conditionalMassFunctionBehroozi2010(                 &
       &                                      stateVector( 1), &
       &                                      stateVector( 2), &
       &                                      stateVector( 3), &
       &                                      stateVector( 4), &
       &                                      stateVector( 5), &
       &                                      stateVector( 6), &
       &                                      stateVector( 7), &
       &                                      stateVector( 8), &
       &                                      stateVector( 9), &
       &                                      stateVector(10), &
       &                                      stateVector(11)  &
       &                                     )
  ! Extract surface brightness parameters and get an incompleteness model.
  if (self%modelSurfaceBrightness)                                                  &
       & massFunctionIncompletenessModel                                            &
       &  =massFunctionIncompletenessSurfaceBrightness(                             &
       &                                               self%surfaceBrightnessLimit, &
       &                                               1.0d0                      , &
       &                                               stateVector(12)            , &
       &                                               stateVector(13)            , &
       &                                               stateVector(14)              &
       &                                               )
  ! Compute the time corresponding to the specified redshifts.
  timeMinimum=cosmologyFunctions_%cosmicTime(cosmologyFunctions_%expansionFactorFromRedshift(self%redshiftMaximum))
  timeMaximum=cosmologyFunctions_%cosmicTime(cosmologyFunctions_%expansionFactorFromRedshift(self%redshiftMinimum))
  ! Compute the mass function.
  integrationReset             =.true.
  integrationResetNormalization=.true.
  do i=1,size(self%mass)
     ! A survey geometry is imposed - sum over fields.
     massFunction =0.0d0
     normalization=0.0d0
     do j=1,surveyGeometry_%fieldCount()
        ! Find the maximum distance at which a galaxy of the present mass can be detected in this survey.
        distanceMaximum=surveyGeometry_%distanceMaximum(sqrt(self%massMinimum(i)*self%massMaximum(i)),field=j)
        ! Set integration limits appropriately.
        binTimeMaximum=                                                       timeMaximum
        binTimeMinimum=min(                                                                 &
             &                                                                timeMaximum , &
             &             max(                                                             &
             &                                                                timeMinimum , &
             &                 cosmologyFunctions_%timeAtDistanceComoving(distanceMaximum)  &
             &                )                                                             &
             &            )
        ! Integrate the mass function over this time interval.
        massFunction=                                                               &
             &       +massFunction                                                  &
             &       +surveyGeometry_%solidAngle(j)                                 &
             &       *Integrate(                                                    &
             &                   binTimeMinimum                                   , &
             &                   binTimeMaximum                                   , &
             &                   likelihoodMassFunctionTimeIntegrand              , &
             &                   integrandFunction                                , &
             &                   integrationWorkspace                             , &
             &                   toleranceRelative=1.0d-3                         , &
             &                   reset=integrationReset                             &
             &                  )
        normalization=                                                              &
             &        +normalization                                                &
             &        +surveyGeometry_%solidAngle(j)                                &
             &        *Integrate(                                                   &
             &                   binTimeMinimum                                   , &
             &                   binTimeMaximum                                   , &
             &                   likelihoodMassFunctionTimeNormalizationIntegrand , &
             &                   integrandFunctionNormalization                   , &
             &                   integrationWorkspaceNormalization                , &
             &                   toleranceRelative=1.0d-3                         , &
             &                   reset=integrationResetNormalization                &
             &                  )
     end do
     self%massFunction(i)=                          &
          &               +massFunction             &
          &               /normalization            &
          &               /log(                     &
          &                     self%massMaximum(i) &
          &                    /self%massMinimum(i) &
          &                   )
     ! Account for surface brightness incompleteness if required.
     if (self%modelSurfaceBrightness) self%massFunction(i)=self%massFunction(i)*massFunctionIncompletenessModel%completeness(self%mass(i))
  end do
  call Integrate_Done(integrandFunction             ,integrationWorkspace             )
  call Integrate_Done(integrandFunctionNormalization,integrationWorkspaceNormalization)
  deallocate(stateVector)
  ! Evaluate the log-likelihood.
  difference                    =self%massFunction-self%massFunctionObserved
  likelihoodMassFunctionEvaluate=-0.5d0*(difference*(self%inverseCovariance*difference))
  return
  
contains
  
  double precision function likelihoodMassFunctionTimeIntegrand(timePrime)
    !% Integral over time.
    use Galacticus_Error
    use String_Handling
    implicit none
    double precision                            , intent(in   ) :: timePrime
    type            (fgsl_function             )                :: integrandFunctionTime
    type            (fgsl_integration_workspace)                :: integrationWorkspaceTime
    integer                                                     :: errorStatus
    logical                                                     :: integrationResetTime
    type            (varying_string            )                :: message
    character       (len=14                    )                :: label
    double precision                                            :: haloMassMinimum,haloMassMaximum

    ! Check for zero contribution from the ends of our halo mass range.
    haloMassMinimum=10.0d0**self%logHaloMassMinimum
    haloMassMaximum=10.0d0**self%logHaloMassMaximum
    if          (                                                                                     &
         &        thisConditionalMassFunction%massFunction(      haloMassMinimum,self%massMinimum(i)) &
         &         ==                                                                                 &
         &        thisConditionalMassFunction%massFunction(      haloMassMinimum,self%massMaximum(i)) &
         &       .and.                                                                                &
         &        thisConditionalMassFunction%massFunction(      haloMassMinimum,self%massMinimum(i)) &
         &         ==                                                                                 &
         &        0.0d0                                                                               &
         &       .and.                                                                                &
         &        thisConditionalMassFunction%massFunction(      haloMassMaximum,self%massMinimum(i)) &
         &         ==                                                                                 &
         &        thisConditionalMassFunction%massFunction(      haloMassMaximum,self%massMaximum(i)) &
         &       .and.                                                                                &
         &        thisConditionalMassFunction%massFunction(      haloMassMaximum,self%massMinimum(i)) &
         &         >                                                                                  &
         &        0.0d0                                                                               &
         &      ) then       
       do while (                                                                                     &
            &     thisConditionalMassFunction%massFunction(2.0d0*haloMassMinimum,self%massMinimum(i)) &
            &      ==                                                                                 &
            &     thisConditionalMassFunction%massFunction(2.0d0*haloMassMinimum,self%massMaximum(i)) &
            &    .and.                                                                                &
            &     thisConditionalMassFunction%massFunction(2.0d0*haloMassMinimum,self%massMinimum(i)) &
            &      ==                                                                                 &
            &     0.0d0                                                                               &
            &   )
          haloMassMinimum=2.0d0*haloMassMinimum
       end do
       do while (                                                                                     &
            &     thisConditionalMassFunction%massFunction(0.5d0*haloMassMaximum,self%massMinimum(i)) &
            &      ==                                                                                 &
            &     thisConditionalMassFunction%massFunction(0.5d0*haloMassMaximum,self%massMaximum(i)) &
            &    .and.                                                                                &
            &     thisConditionalMassFunction%massFunction(0.5d0*haloMassMaximum,self%massMinimum(i)) &
            &      >                                                                                  &
            &     0.0d0                                                                               &           
            &   )
          haloMassMaximum=0.5d0*haloMassMaximum          
       end do       
    end if
    time                =timePrime
    integrationResetTime=.true.
    likelihoodMassFunctionTimeIntegrand= Integrate(                                            &
         &                                           log10(haloMassMinimum)                  , &
         &                                           log10(haloMassMaximum)                  , &
         &                                           likelihoodMassFunctionHaloMassIntegrand , &
         &                                           integrandFunctionTime                   , &
         &                                           integrationWorkspaceTime                , &
         &                                           toleranceRelative=1.0d-3                , &
         &                                           toleranceAbsolute=1.0d-9                , &
         &                                           reset      =integrationResetTime        , &
         &                                           errorStatus=errorStatus                   &
         &                                          )                                          &
         &                               *cosmologyFunctions_%comovingVolumeElementTime(timePrime)
    call Integrate_Done(integrandFunctionTime,integrationWorkspaceTime)
    if (errorStatus /= errorStatusSuccess) then
       message='integration failed - state vector follows'
       do i=1,size(stateVector)
          write (label,'(e12.6)') stateVector(i)
          message=message//char(10)//" state ["//i//"] = "//trim(label)
        end do       
       call Galacticus_Error_Report(message//{introspection:location})
    end if
    return
  end function likelihoodMassFunctionTimeIntegrand
  
  double precision function likelihoodMassFunctionTimeNormalizationIntegrand(timePrime)
    !% Normalization integral over time.
    implicit none
    double precision, intent(in   ) :: timePrime
    
    likelihoodMassFunctionTimeNormalizationIntegrand=cosmologyFunctions_%comovingVolumeElementTime(timePrime)
    return
  end function likelihoodMassFunctionTimeNormalizationIntegrand
  
  double precision function likelihoodMassFunctionHaloMassIntegrand(logMass)
    !% Integral over halo mass function.
    implicit none
    double precision, intent(in   ) :: logMass
    double precision                :: mass

    mass=10.0d0**logMass
    likelihoodMassFunctionHaloMassIntegrand=+haloMassFunction_%differential(time,mass)                                &
         &                                  *                                    mass                                 &
         &                                  *log(10.0d0)                                                              &
         &                                  *max(                                                                     &
         &                                       +0.0d0                                                             , &
         &                                       +thisConditionalMassFunction%massFunction(mass,self%massMinimum(i))  &
         &                                       -thisConditionalMassFunction%massFunction(mass,self%massMaximum(i))  &
         &                                      )
    return
  end function likelihoodMassFunctionHaloMassIntegrand
    
end function likelihoodMassFunctionEvaluate

subroutine likelihoodMassFunctionFunctionChanged(self)
  !% Respond to possible changes in the likelihood function.
  implicit none
  class(likelihoodMassFunction), intent(inout) :: self
  !GCC$ attributes unused :: self
  
  return
end subroutine likelihoodMassFunctionFunctionChanged
