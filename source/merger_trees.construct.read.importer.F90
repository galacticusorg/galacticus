!! Copyright 2009, 2010, 2011, 2012, 2013, 2014 Andrew Benson <abenson@obs.carnegiescience.edu>
!!
!! This file is part of Galacticus.
!!
!!    Galacticus is free software: you can redistribute it and/or modify
!!    it under the terms of the GNU General Public License as published by
!!    the Free Software Foundation, either version 3 of the License, or
!!    (at your option) any later version.
!!
!!    Galacticus is distributed in the hope that it will be useful,
!!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!!    GNU General Public License for more details.
!!
!!    You should have received a copy of the GNU General Public License
!!    along with Galacticus.  If not, see <http://www.gnu.org/licenses/>.

!% Contains a module which provides an object that implements importing of merger trees from file.

module Merger_Tree_Read_Importers
  !% Provides an object that implements importing of merger trees from file. 
  use, intrinsic :: ISO_C_Binding
  use               ISO_Varying_String
  use               Kind_Numbers
  use               Galacticus_Nodes
  !# <include directive="mergerTreeImporter" type="functionModules" >
  include 'mergerTreeImporter.functionModules.inc'
  !# </include>
  private
  public :: nodeData

  ! Type used to specify units.
  type :: importerUnits
     logical          :: status                              
     double precision :: unitsInSI                           
     integer          :: hubbleExponent, scaleFactorExponent 
   contains
     !@ <objectMethods>
     !@   <object>importerUnits</object>
     !@   <objectMethod>
     !@     <method>multiply</method>
     !@     <type>\textcolor{red}{\textless type(importerUnits)\textgreater}</type>
     !@     <arguments>\textcolor{red}{\textless type(importerUnits)\textgreater} units2\argin</arguments>
     !@     <description>Multiply by another {\tt importerUnits} object.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>exponentiate</method>
     !@     <type>\textcolor{red}{\textless type(importerUnits)\textgreater}</type>
     !@     <arguments>\intzero exponent\argin</arguments>
     !@     <description>Raise to the given integer power.</description>
     !@   </objectMethod>
     !@ </objectMethods>
     procedure :: multiply    =>importerUnitsMultiply     
     procedure :: exponentiate=>importerUnitsExponentiate 
     generic   :: operator(* ) => multiply
     generic   :: operator(**) => exponentiate
  end type importerUnits

  ! Type used to store raw data.
  type nodeData
     !% Structure used to store raw data read from merger tree files.
     integer         (kind=kind_int8)               :: descendentIndex   , hostIndex               , & 
          &                                            isolatedNodeIndex , mergesWithIndex         , & 
          &                                            nodeIndex         , primaryIsolatedNodeIndex, &
          &                                            particleCount
     double precision                               :: angularMomentum   , halfMassRadius          , & 
          &                                            nodeMass          , nodeTime                , & 
          &                                            scaleRadius       , velocityMaximum         , &
          &                                            velocityDispersion, spin
     double precision                , dimension(3) :: position          , velocity                , &
          &                                            angularMomentum3D , spin3D
     logical                                        :: childIsSubhalo    , isSubhalo                   
     class           (nodeData      ), pointer      :: descendent        , host                    , & 
          &                                            parent                                         
     type            (treeNode      ), pointer      :: node                                           
  end type nodeData

  interface importerUnitConvert
     !% Unit convertors for \glc\ format tree importer.
     module procedure importerUnitConvertScalar
     module procedure importerUnitConvert1D
     module procedure importerUnitConvert2D
  end interface importerUnitConvert

  !# <include directive="mergerTreeImporter" type="function" >
  !#  <description>Object providing functions for importing merger trees.</description>
  !#  <descriptiveName>Merger Tree Importer</descriptiveName>
  !#  <default>galacticus</default>
  !#  <defaultThreadPrivate>no</defaultThreadPrivate>
  !#  <method name="open" >
  !#   <description>Opens the file.</description>
  !#   <type>void</type>
  !#   <pass>yes</pass>
  !#   <argument>type(varying_string), intent(in   ) :: fileName</argument>
  !#  </method>
  !#  <method name="close" >
  !#   <description>Closes the file.</description>
  !#   <type>void</type>
  !#   <pass>yes</pass>
  !#  </method>
  !#  <method name="treesHaveSubhalos" >
  !#   <description>Returns a Boolean integer specifying whether or not the trees have subhalos.</description>
  !#   <type>integer</type>
  !#   <pass>yes</pass>
  !#  </method>
  !#  <method name="massesIncludeSubhalos" >
  !#   <description>Returns a Boolean specifying whether halo masses include the contribution from their subhalos.</description>
  !#   <type>logical</type>
  !#   <pass>yes</pass>
  !#  </method>
  !#  <method name="treesAreSelfContained" >
  !#   <description>Returns a Boolean integer specifying whether trees are self-contained.</description>
  !#   <type>integer</type>
  !#   <pass>yes</pass>
  !#  </method>
  !#  <method name="velocitiesIncludeHubbleFlow" >
  !#   <description>Returns a Boolean integer specifying whether velocities include the Hubble flow.</description>
  !#   <type>integer</type>
  !#   <pass>yes</pass>
  !#  </method>
  !#  <method name="positionsArePeriodic" >
  !#   <description>Returns a Boolean integer specifying whether positions are periodic.</description>
  !#   <type>integer</type>
  !#   <pass>yes</pass>
  !#  </method>
  !#  <method name="cubeLength" >
  !#   <description>Returns the length of the simulation cube.</description>
  !#   <type>double precision</type>
  !#   <pass>yes</pass>
  !#   <argument>double precision, intent(in   )           :: time</argument>
  !#   <argument>integer         , intent(  out), optional :: status</argument>
  !#  </method>
  !#  <method name="treeCount" >
  !#   <description>Returns a count of the number of trees available.</description>
  !#   <type>integer</type>
  !#   <pass>yes</pass>
  !#  </method>
  !#  <method name="treeIndex" >
  !#   <description>Returns the index of the $i^{\rm th}$ tree.</description>
  !#   <type>integer(kind=kind_int8)</type>
  !#   <pass>yes</pass>
  !#   <argument>integer, intent(in   ) :: i</argument>
  !#  </method>
  !#  <method name="nodeCount" >
  !#   <description>Returns the number of nodes in the $i^{\rm th}$ tree.</description>
  !#   <type>integer</type>
  !#   <pass>yes</pass>
  !#   <argument>integer, intent(in   ) :: i</argument>
  !#  </method>
  !#  <method name="treeWeight" >
  !#   <description>Returns the weight to assign to the $i^{\rm th}$ tree.</description>
  !#   <type>double precision</type>
  !#   <pass>yes</pass>
  !#   <argument>integer, intent(in   ) :: i</argument>
  !#  </method>
  !#  <method name="positionsAvailable" >
  !#   <description>Return true if positions and/or velocities are available.</description>
  !#   <type>logical</type>
  !#   <pass>yes</pass>
  !#   <argument>logical, intent(in   ) :: positions, velocities</argument>
  !#  </method>
  !#  <method name="scaleRadiiAvailable" >
  !#   <description>Return true if scale radii are available.</description>
  !#   <type>logical</type>
  !#   <pass>yes</pass>
  !#  </method>
  !#  <method name="particleCountAvailable" >
  !#   <description>Return true if particle counts are available.</description>
  !#   <type>logical</type>
  !#   <pass>yes</pass>
  !#  </method>
  !#  <method name="velocityMaximumAvailable" >
  !#   <description>Return true if rotation curve velocity maxima are available.</description>
  !#   <type>logical</type>
  !#   <pass>yes</pass>
  !#  </method>
  !#  <method name="velocityDispersionAvailable" >
  !#   <description>Return true if halo velocity dispersions are available.</description>
  !#   <type>logical</type>
  !#   <pass>yes</pass>
  !#  </method>
  !#  <method name="angularMomentaAvailable" >
  !#   <description>Return true if angular momenta (magnitudes) are available.</description>
  !#   <type>logical</type>
  !#   <pass>yes</pass>
  !#  </method>
  !#  <method name="angularMomenta3DAvailable" >
  !#   <description>Return true if angular momenta (vectors) are available.</description>
  !#   <type>logical</type>
  !#   <pass>yes</pass>
  !#  </method>
  !#  <method name="spinAvailable" >
  !#   <description>Return true if spin (magnitudes) are available.</description>
  !#   <type>logical</type>
  !#   <pass>yes</pass>
  !#  </method>
  !#  <method name="spin3DAvailable" >
  !#   <description>Return true if spin (vectors) are available.</description>
  !#   <type>logical</type>
  !#   <pass>yes</pass>
  !#  </method>
  !#  <method name="import" >
  !#   <description>Imports the $i^{\rm th}$ tree.</description>
  !#   <type>void</type>
  !#   <pass>yes</pass>
  !#   <argument>integer          , intent(in   )                            :: i</argument>
  !#   <argument>class  (nodeData), intent(  out), allocatable, dimension(:) :: nodes</argument>
  !#   <argument>logical          , intent(in   ), optional                  :: requireScaleRadii, requireAngularMomenta, requireAngularMomenta3D, requireSpin, requireSpin3D, requirePositions, requireParticleCounts, requireVelocityMaxima, requireVelocityDispersions</argument>
  !#  </method>
  !#  <method name="subhaloTrace" >
  !#   <description>Supplies epochs, positions, and velocities for traced subhalos.</description>
  !#   <type>void</type>
  !#   <pass>yes</pass>
  !#   <argument>class           (nodeData), intent(in   )                 :: node</argument>
  !#   <argument>double precision          , intent(  out), dimension(:  ) :: time</argument>
  !#   <argument>double precision          , intent(  out), dimension(:,:) :: position, velocity</argument>
  !#  </method>
  !#  <method name="subhaloTraceCount" >
  !#   <description>Returns the length of a node's subhalo trace.</description>
  !#   <type>integer</type>
  !#   <pass>yes</pass>
  !#   <argument>class(nodeData), intent(in   ) :: node</argument>
  !#  </method>
  include 'mergerTreeImporter.type.inc'
  !# </include>

  function importerUnitsMultiply(units1,units2)
    !% Multiply to {\tt importerUnits} objects.
    implicit none
    type (importerUnits)                :: importerUnitsMultiply 
    class(importerUnits), intent(in   ) :: units1                
    type (importerUnits), intent(in   ) :: units2                
    
    importerUnitsMultiply%status             =units1%status             .and.units2%status
    importerUnitsMultiply%unitsInSI          =units1%unitsInSI            *  units2%unitsInSI
    importerUnitsMultiply%scaleFactorExponent=units1%scaleFactorExponent  +  units2%scaleFactorExponent
    importerUnitsMultiply%hubbleExponent     =units1%hubbleExponent       +  units2%hubbleExponent
    return
  end function importerUnitsMultiply

  function importerUnitsExponentiate(units1,exponent)
    !% Exponentiate {\tt importerUnits} objects.
    implicit none
    type   (importerUnits)                :: importerUnitsExponentiate 
    class  (importerUnits), intent(in   ) :: units1                    
    integer               , intent(in   ) :: exponent                  
    
    importerUnitsExponentiate%status             =units1%status
    importerUnitsExponentiate%unitsInSI          =units1%unitsInSI          **exponent
    importerUnitsExponentiate%scaleFactorExponent=units1%scaleFactorExponent* exponent
    importerUnitsExponentiate%hubbleExponent     =units1%hubbleExponent     * exponent
    return
  end function importerUnitsExponentiate

  function importerUnitConvertScalar(values,times,units,requiredUnits)
    !% Convert a set of values for \glc\ internal units.
    use Cosmology_Parameters
    use Cosmology_Functions
    use Galacticus_Error
    implicit none
    double precision                          , intent(in   ) :: values                    , times
    type            (importerUnits           ), intent(in   ) :: units
    double precision                          , intent(in   ) :: requiredUnits
    double precision                                          :: importerUnitConvertScalar
    class           (cosmologyParametersClass), pointer       :: cosmologyParametersDefault
    class           (cosmologyFunctionsClass ), pointer       :: cosmologyFunctionsDefault

    if (.not.units%status) call Galacticus_Error_Report('importerUnitConvertScalar','units are not defined')
    cosmologyParametersDefault => cosmologyParameters()
    importerUnitConvertScalar=values*(units%unitsInSI/requiredUnits)*cosmologyParametersDefault%HubbleConstant(unitsLittleH)**units%hubbleExponent
    if (units%scaleFactorExponent /= 0) then
       cosmologyFunctionsDefault => cosmologyFunctions()
       importerUnitConvertScalar=importerUnitConvertScalar*cosmologyFunctionsDefault%expansionFactor(times)**units%scaleFactorExponent
    end if
    return
  end function importerUnitConvertScalar
  
  function importerUnitConvert1D(values,times,units,requiredUnits)
    !% Convert a set of values for \glc\ internal units.
    use Cosmology_Parameters
    use Cosmology_Functions
    use Galacticus_Error
    implicit none
    double precision                          , intent(in   ), dimension(           :) :: values                    , times
    type            (importerUnits           ), intent(in   )                          :: units
    double precision                          , intent(in   )                          :: requiredUnits
    double precision                                         , dimension(size(values)) :: importerUnitConvert1D
    class           (cosmologyParametersClass), pointer                                :: cosmologyParametersDefault
    class           (cosmologyFunctionsClass ), pointer                                :: cosmologyFunctionsDefault
    integer                                                                            :: i

    if (.not.units%status) call Galacticus_Error_Report('importerUnitConvert1D','units are not defined')
    cosmologyParametersDefault => cosmologyParameters()
    importerUnitConvert1D=values*(units%unitsInSI/requiredUnits)*cosmologyParametersDefault%HubbleConstant(unitsLittleH)**units%hubbleExponent
    if (units%scaleFactorExponent /= 0) then
       cosmologyFunctionsDefault => cosmologyFunctions()
       do i=1,size(values)
          importerUnitConvert1D(i)=importerUnitConvert1D(i)*cosmologyFunctionsDefault%expansionFactor(times(i))**units%scaleFactorExponent
       end do
    end if
    return
  end function importerUnitConvert1D
  
  function importerUnitConvert2D(values,times,units,requiredUnits)
    !% Convert a set of values for \glc\ internal units.
    use Cosmology_Parameters
    use Cosmology_Functions
    use Galacticus_Error
    implicit none
    double precision                          , intent(in   ), dimension(                 :,                 :) :: values
    double precision                          , intent(in   ), dimension(                                    :) :: times
    type            (importerUnits           ), intent(in   )                                                   :: units
    double precision                          , intent(in   )                                                   :: requiredUnits
    double precision                                         , dimension(size(values,dim=1),size(values,dim=2)) :: importerUnitConvert2D
    class           (cosmologyParametersClass), pointer                                                         :: cosmologyParametersDefault
    class           (cosmologyFunctionsClass ), pointer                                                         :: cosmologyFunctionsDefault
    integer                                                                                                     :: i

    if (.not.units%status) call Galacticus_Error_Report('importerUnitConvert2D','units are not defined')
    cosmologyParametersDefault => cosmologyParameters()
    importerUnitConvert2D=values*(units%unitsInSI/requiredUnits)*cosmologyParametersDefault%HubbleConstant(unitsLittleH)**units%hubbleExponent
    if (units%scaleFactorExponent /= 0) then
       cosmologyFunctionsDefault => cosmologyFunctions()
       do i=1,size(values,dim=2)
          importerUnitConvert2D(:,i)=importerUnitConvert2D(:,i)*cosmologyFunctionsDefault%expansionFactor(times(i))**units%scaleFactorExponent
       end do
    end if
    return
  end function importerUnitConvert2D
  
end module Merger_Tree_Read_Importers
