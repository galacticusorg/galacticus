!! Copyright 2009, 2010, 2011, 2012, 2013, 2014, 2015 Andrew Benson <abenson@obs.carnegiescience.edu>
!!
!! This file is part of Galacticus.
!!
!!    Galacticus is free software: you can redistribute it and/or modify
!!    it under the terms of the GNU General Public License as published by
!!    the Free Software Foundation, either version 3 of the License, or
!!    (at your option) any later version.
!!
!!    Galacticus is distributed in the hope that it will be useful,
!!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!!    GNU General Public License for more details.
!!
!!    You should have received a copy of the GNU General Public License
!!    along with Galacticus.  If not, see <http://www.gnu.org/licenses/>.

!% Contains a module which implements calculations related to satellite orbits.

module Satellite_Orbits
  !% Implements calculations related to satellite orbits.
  use Galacticus_Nodes
  implicit none
  private
  public :: Satellite_Orbit_Equivalent_Circular_Orbit_Radius, Satellite_Orbit_Extremum_Phase_Space_Coordinates

  ! Orbital energy and angular momentum - used for finding radius of equivalent circular orbit.
  double precision                              :: orbitalAngularMomentumInternal   , orbitalEnergyInternal
  !$omp threadprivate(orbitalEnergyInternal,orbitalAngularMomentumInternal)
  ! Node used in root finding calculations.
  type            (treeNode), pointer           :: activeNode
  !$omp threadprivate(activeNode)

  ! Enumeratation used to indicate type of extremum.
  integer                   , parameter, public :: extremumPericenter            =-1
  integer                   , parameter, public :: extremumApocenter             =+1

  ! Error codes.
  integer, parameter, public :: errorCodeSuccess          =0
  integer, parameter, public :: errorCodeOrbitUnbound     =1
  integer, parameter, public :: errorCodeNoEquivalentOrbit=2

contains

  double precision function Satellite_Orbit_Equivalent_Circular_Orbit_Radius(hostNode,thisOrbit,errorCode)
    !% Solves for the equivalent circular orbit radius for {\normalfont \ttfamily thisOrbit} in {\normalfont \ttfamily hostNode}.
    use Root_Finder
    use Kepler_Orbits
    use Dark_Matter_Halo_Scales
    implicit none
    type            (treeNode         ), intent(inout), pointer  :: hostNode
    type            (keplerOrbit      ), intent(inout)           :: thisOrbit
    integer                            , intent(  out), optional :: errorCode
    class           (darkMatterHaloScaleClass)               , pointer :: darkMatterHaloScale_
    double precision                   , parameter               :: toleranceAbsolute=0.0d0, toleranceRelative=1.0d-6
    type            (rootFinder       ), save                    :: finder
    !$omp threadprivate(finder)
    type            (keplerOrbit      )                          :: currentOrbit

    ! Convert the orbit to the potential of the current halo in which the satellite finds itself.
    currentOrbit=Satellite_Orbit_Convert_To_Current_Potential(thisOrbit,hostNode)
    ! Assign the active node.
    activeNode => hostNode
    ! Store the orbital energy.
    orbitalEnergyInternal=thisOrbit%energy()
    ! Test for conditions that an equivalent circular orbit exists.
    if (orbitalEnergyInternal >= 0.0d0) then
       ! Orbit is unbound, return unphysical value.
       Satellite_Orbit_Equivalent_Circular_Orbit_Radius=-1.0d0
       if (present(errorCode)) errorCode=errorCodeOrbitUnbound
    else if (Equivalent_Circular_Orbit_Solver(0.0d0) > 0.0d0) then
       ! No equivalent circular orbit exists (i.e. the orbital energy is less [i.e. more negative] than the gravitational
       ! potential at zero radius. Return an unphysical value.
       Satellite_Orbit_Equivalent_Circular_Orbit_Radius=-1.0d0
       if (present(errorCode)) errorCode=errorCodeNoEquivalentOrbit
    else
       if (.not.finder%isInitialized()) then
          call finder%rootFunction(Equivalent_Circular_Orbit_Solver   )
          call finder%tolerance   (toleranceAbsolute,toleranceRelative)
          call finder%rangeExpand (                                                             &
               &                   rangeExpandUpward            =2.0d0                        , &
               &                   rangeExpandDownward          =0.5d0                        , &
               &                   rangeExpandDownwardSignExpect=rangeExpandSignExpectNegative, &
               &                   rangeExpandUpwardSignExpect  =rangeExpandSignExpectPositive, &
               &                   rangeExpandType              =rangeExpandMultiplicative      &
               &                  )
       end if
       darkMatterHaloScale_ => darkMatterHaloScale()
       Satellite_Orbit_Equivalent_Circular_Orbit_Radius=finder%find(rootGuess=darkMatterHaloScale_%virialRadius(hostNode))
       if (present(errorCode)) errorCode=errorCodeSuccess
    end if
    return
  end function Satellite_Orbit_Equivalent_Circular_Orbit_Radius

  double precision function Equivalent_Circular_Orbit_Solver(radius)
    !% Root function used in finding equivalent circular orbits.
    use Galactic_Structure_Options
    use Galactic_Structure_Potentials
    use Galacticus_Error
    use Dark_Matter_Profiles
    implicit none
    double precision                        , intent(in   ) :: radius
    double precision                        , parameter     :: potentialInfinite=1.0d30
    class           (darkMatterProfileClass), pointer       :: darkMatterProfile_
    double precision                                        :: potential
    integer                                                 :: status

    ! Get potential.
    potential=Galactic_Structure_Potential(activeNode,radius,status=status)
    select case (status)
    case (structureErrorCodeSuccess )
       darkMatterProfile_ => darkMatterProfile()
       Equivalent_Circular_Orbit_Solver=potential+0.5d0*darkMatterProfile_%circularVelocity(activeNode,radius)**2-orbitalEnergyInternal
    case (structureErrorCodeInfinite)
       ! The gravitational potential is negative infinity at this radius (most likely zero radius). Since all we care about in
       ! this root-finding function is the sign of the function, return a large negative value.
       Equivalent_Circular_Orbit_Solver=-potentialInfinite
    case default
       call Galacticus_Error_Report('Equivalent_Circular_Orbit_Solver','dark matter potential evaluation failed')
    end select
    return
  end function Equivalent_Circular_Orbit_Solver

  subroutine Satellite_Orbit_Extremum_Phase_Space_Coordinates(hostNode,thisOrbit,extremumType,radius,velocity)
    !% Solves for the pericentric radius and velocity of {\normalfont \ttfamily thisOrbit} in {\normalfont \ttfamily hostNode}.
    use Root_Finder
    use Kepler_Orbits
    use Numerical_Constants_Prefixes
    use Numerical_Constants_Physical
    use Galacticus_Error
    use Galactic_Structure_Options
    use Galactic_Structure_Potentials
    implicit none
    type            (treeNode   ), intent(inout), pointer :: hostNode
    type            (keplerOrbit), intent(inout)          :: thisOrbit
    integer                      , intent(in   )          :: extremumType
    double precision             , intent(  out)          :: radius                 , velocity
    double precision             , parameter              :: toleranceAbsolute=0.0d0, toleranceRelative=1.0d-6
    type            (rootFinder ), save                   :: finder
    !$omp threadprivate(finder)
    type            (keplerOrbit)                         :: currentOrbit
    integer                                               :: status
    double precision                                      :: potential

    ! Convert the orbit to the potential of the current halo in which the satellite finds itself.
    currentOrbit=Satellite_Orbit_Convert_To_Current_Potential(thisOrbit,hostNode)
    ! Extract the orbital energy and angular momentum.
    orbitalEnergyInternal         =  currentOrbit%energy         ()
    orbitalAngularMomentumInternal=  currentOrbit%angularMomentum()
    ! Set a pointer to the host node.
    activeNode                    => hostNode
    ! Catch orbits which are close to being circular.
    if      (   Extremum_Solver(currentOrbit%radius()) == 0.0d0             ) then
       ! Orbit is at extremum.
       radius=currentOrbit%radius()
    else if (                                                                      &
         &    (                                                                    &
         &      extremumType                           == extremumPericenter       &
         &     .and.                                                               &
         &      Extremum_Solver(currentOrbit%radius()) >  0.0d0                    &
         &    )                                                                    &
         &   .or.                                                                  &
         &    (                                                                    &
         &      extremumType                           == extremumApocenter        &
         &     .and.                                                               &
         &      Extremum_Solver(currentOrbit%radius()) <  0.0d0                    &
         &    )                                                                    &
         &  ) then
       ! No solution exists, assume a circular orbit.
       radius=currentOrbit%radius()
    else if (                                                                      &
         &      extremumType                           == extremumPericenter       &
         &   .and.                                                                 &
         &      orbitalAngularMomentumInternal         <= 0.0d0                    &
         &  ) then
       ! Orbit is radial, so pericenter is zero.
       radius=0.0d0
    else
       if (.not.finder%isInitialized()) then
          call finder%rootFunction(Extremum_Solver                    )
          call finder%tolerance   (toleranceAbsolute,toleranceRelative)
       end if
       select case (extremumType)
       case (extremumPericenter)
          call finder%rangeExpand (                                                             &
               &                   rangeExpandDownward          =0.5d0                        , &
               &                   rangeExpandDownwardSignExpect=rangeExpandSignExpectPositive, &
               &                   rangeExpandType              =rangeExpandMultiplicative      &
               &                  )
       case (extremumApocenter )
          call finder%rangeExpand (                                                             &
               &                   rangeExpandUpward            =2.0d0                        , &
               &                   rangeExpandUpwardSignExpect  =rangeExpandSignExpectNegative, &
               &                   rangeExpandType              =rangeExpandMultiplicative      &
               &                  )
       end select
       radius=finder%find(rootGuess=currentOrbit%radius())
    end if
    ! Get the orbital velocity at this radius.
    if (orbitalAngularMomentumInternal > 0.0d0) then
       ! Orbit is non-radial - use angular momentum to find velocity.
       velocity=orbitalAngularMomentumInternal/radius
    else
       ! Orbit is radial - use energy to find velocity.
       potential=Galactic_Structure_Potential(activeNode,radius,status=status)    
       select case (status)
       case (structureErrorCodeSuccess )
          velocity=sqrt(2.0d0*(orbitalEnergyInternal-potential))
       case (structureErrorCodeInfinite)
          ! The gravitational potential is negative infinity at this radius (most likely zero radius). Velocity is formally
          ! infinite. Return speed of light as a suitably fast value.
          velocity=speedLight/kilo
       case default
          call Galacticus_Error_Report('Satellite_Orbit_Extremum_Phase_Space_Coordinates','dark matter potential evaluation failed')
       end select
    end if
    return
  end subroutine Satellite_Orbit_Extremum_Phase_Space_Coordinates

  double precision function Extremum_Solver(radius)
    !% Root function used in finding orbital extremum radius.
    use Galactic_Structure_Potentials
    implicit none
    double precision, intent(in   ) :: radius
    double precision                :: potential
    
    potential=Galactic_Structure_Potential(activeNode,radius)
    Extremum_Solver=potential+0.5d0*(orbitalAngularMomentumInternal/radius)**2-orbitalEnergyInternal
    return
  end function Extremum_Solver

  function Satellite_Orbit_Convert_To_Current_Potential(thisOrbit,currentHost)
    !% Takes a virial orbit and adjusts the energy to account for the change in the definition of potential between the original
    !% halo in which the orbit was defined and the current halo. Since the potential at the virial radius of halos is always
    !% defined to be $\Phi(r_{\mathrm vir}) = - V_{\mathrm vir}^2$ then the specific energy transforms as:
    !% \begin{equation}
    !% e \rightarrow e + V^2_{\mathrm vir,0} + \Phi(r_{\mathrm vir,0}),
    !% \end{equation}
    !% where subscript $0$ refers to the original halo in which the orbit was defined and $\Phi(r)$ is the potential of the
    !% current halo.
    use Galactic_Structure_Potentials
    use Numerical_Constants_Physical
    use Kepler_Orbits
    implicit none
    type            (keplerOrbit)                         :: Satellite_Orbit_Convert_To_Current_Potential
    type            (keplerOrbit), intent(inout)          :: thisOrbit
    type            (treeNode   ), intent(inout), pointer :: currentHost
    double precision                                      :: potentialHost                               , radiusVirialOriginal, &
         &                                                   velocityVirialOriginal

    ! Compute the properties of the initial orbit, and the current potential.
    radiusVirialOriginal  =gravitationalConstantGalacticus*thisOrbit%hostMass()/thisOrbit%velocityScale()**2
    velocityVirialOriginal=                                                     thisOrbit%velocityScale()
    potentialHost         =Galactic_Structure_Potential(currentHost,radiusVirialOriginal)
    ! Create a new orbit with an adjusted energy.
    Satellite_Orbit_Convert_To_Current_Potential=thisOrbit    
    call Satellite_Orbit_Convert_To_Current_Potential%energySet(thisOrbit%energy()+velocityVirialOriginal**2+potentialHost)
    return
  end function Satellite_Orbit_Convert_To_Current_Potential

end module Satellite_Orbits
