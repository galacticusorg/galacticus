!! Copyright 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018
!!    Andrew Benson <abenson@carnegiescience.edu>
!!
!! This file is part of Galacticus.
!!
!!    Galacticus is free software: you can redistribute it and/or modify
!!    it under the terms of the GNU General Public License as published by
!!    the Free Software Foundation, either version 3 of the License, or
!!    (at your option) any later version.
!!
!!    Galacticus is distributed in the hope that it will be useful,
!!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!!    GNU General Public License for more details.
!!
!!    You should have received a copy of the GNU General Public License
!!    along with Galacticus.  If not, see <http://www.gnu.org/licenses/>.

!% Contains a module which performs analysis to compute a variety of correlation functions.

module Galacticus_Output_Analyses_Correlation_Functions
  !% Performs analysis to compute a variety of correlation functions.
  use, intrinsic :: ISO_C_Binding
  use Galacticus_Nodes
  use Galactic_Structure_Options
  use Geometry_Surveys
  use Numerical_Constants_Astronomical
  use Numerical_Constants_Prefixes
  implicit none
  private
  public :: Galacticus_Output_Analysis_Correlation_Functions, Galacticus_Output_Analysis_Correlation_Functions_Output

  ! Record of module initialization.
  logical                                                          :: moduleInitialized               =.false.

  ! Record of whether this analysis is active.
  logical                                                          :: analysisActive

  ! Number of supported mass functions.
  integer          , parameter                                     :: correlationFunctionsSupportedCount=1

  ! Labels for supported mass functions.
  character(len=25), dimension(correlationFunctionsSupportedCount) :: correlationFunctionLabels= &
       & [                                                                                       &
       &  'sdssClusteringZ0.07'                                                                  &
       & ]

  ! Interface for mass mapping functions.
  abstract interface
     double precision function Map_Mass(mass,node)
       import treeNode
       double precision          , intent(in   )          :: mass
       type            (treeNode), intent(inout), pointer :: node
     end function Map_Mass
  end interface

  ! Interface for mass error functions.
  abstract interface
     double precision function Mass_Error(mass,node)
       import treeNode
       double precision          , intent(in   )          :: mass
       type            (treeNode), intent(inout), pointer :: node
     end function Mass_Error
  end interface

  ! Type for descriptors of correlation functions.
  type :: correlationFunctionDescriptor
     double precision                                           :: massSystematicLogM0
     procedure       (Mass_Error         ), pointer    , nopass :: massRandomErrorFunction
     double precision                                           :: massLogarithmicMinimum
     integer                                                    :: massSystematicCoefficientCount, massRandomCoefficientCount
     integer                                                    :: massType
     double precision                                           :: massUnitsInSI
     logical                                                    :: halfIntegral
     character       (len= 32            )                      :: label
     character       (len=128            )                      :: comment
     procedure       (Map_Mass           ), pointer    , nopass :: mapMass
     class           (surveyGeometryClass), allocatable         :: geometry
  end type correlationFunctionDescriptor

  ! Correlation function descriptors.
  type(correlationFunctionDescriptor), dimension(correlationFunctionsSupportedCount), target :: correlationFunctionDescriptors= &
       & [                                                                                                                      &
       ! Hearin et al. (2013) SDSS.
       &                           correlationFunctionDescriptor(                                                               &
       &                                                          11.300d0                                               ,      &
       &                                                          null()                                                 ,      &
       &                                                           8.000d0                                               ,      &
       &                                                           2                                                     ,      &
       &                                                           2                                                     ,      &
       &                                                          massTypeStellar                                        ,      &
       &                                                          massSolar                                              ,      &
       &                                                          .false.                                                ,      &
       &                                                          'sdssClusteringZ0.07'                                  ,      &
       &                                                          'SDSS galaxy clustering at z=0.07'                     ,      &
       &                                                          null()                                                 ,      &
       &                                                          null()                                                        &
       &                                                        )                                                               &
       & ]

  ! Type to store size functions.
  type :: correlationFunction
     ! Copy of the mass function descriptor for this mass function.
     type            (correlationFunctionDescriptor), pointer                       :: descriptor
     ! Parameters for the systematic error model.
     double precision                               , allocatable, dimension(:    ) :: massSystematicCoefficients, massRandomCoefficients
     double precision                                                               :: massRandomMinimum         , massRandomMaximum
     ! Weights to apply to each output.
     double precision                               , allocatable, dimension(:,:  ) :: outputWeight
     ! Mass range.
     double precision                               , allocatable, dimension(:    ) :: massMinimum
     double precision                               , allocatable, dimension(:    ) :: massMinimumLogarithmic
     ! Separations.
     double precision                               , allocatable, dimension(:    ) :: separation
     ! Integral constraint.
     double precision                               , allocatable, dimension(:,:  ) :: integralConstraint
     ! Line-of-sight integration depth.
     double precision                                                               :: lineOfSightDepth
     ! Population statistics.
     double precision                               , allocatable, dimension(:    ) :: meanDensity
     ! Density and count of galaxies on the main branches of trees.
     double precision                               , allocatable, dimension(:,:  ) :: meanDensityMainBranch
     double precision                               , allocatable, dimension(:,:,:) :: oneHaloTermMainBranch, twoHaloTermMainBranch
     integer                                        , allocatable, dimension(:    ) :: countMainBranch     
     ! Power spectrum wavenumbers.
     double precision                               , allocatable, dimension(:    ) :: wavenumber
     ! Power spectra.
     double precision                               , allocatable, dimension(:,:  ) :: oneHaloTerm               , twoHaloTerm
     ! Covariances.
     double precision                               , allocatable, dimension(:,:  ) :: termCovariance
     ! Cosmology conversion factors.
     double precision                               , allocatable, dimension(:    ) :: cosmologyConversionMass   , cosmologyConversionSize
     ! Weighted linear growth factor.
     double precision                               , allocatable, dimension(:    ) :: linearGrowthFactor
  end type correlationFunction

  ! Correlation functions.
  type(correlationFunction), allocatable, dimension(:) :: correlationFunctions

  ! Type for storing temporary size functions during cumulation.
  type :: correlationFunctionWork
     double precision                , allocatable, dimension(:,:) :: satelliteProbability
     double precision                , allocatable, dimension(  :) :: centralProbability  , fourierProfile
     integer                                                       :: satelliteCount
     integer         (c_size_t      )                              :: outputNumber
     double precision                                              :: haloBias            , haloWeight    , &
          &                                                           haloTime            , haloMass      , &
          &                                                           hostMass
     logical                                                       :: propertiesSet       , isMainBranch  , &
          &                                                           initialized
     ! Indices of current halo.
     integer         (kind=kind_int8)                              :: treeIndex           , haloIndex
  end type correlationFunctionWork

  ! Work array.
  type(correlationFunctionWork), allocatable, dimension(:) :: haloWork
  !$omp threadprivate(haloWork)

  ! Halo mass binning.
  double precision :: analysisProjectedCorrelationFunctionsHaloMassMinimum           , analysisProjectedCorrelationFunctionsHaloMassMaximum      , &
       &              analysisProjectedCorrelationFunctionsHaloMassMinimumLogarithmic, haloMassIntervalLogarithmicInverse
  integer          :: analysisProjectedCorrelationFunctionsHaloMassBinsCount         , analysisProjectedCorrelationFunctionsHaloMassBinsPerDecade

  abstract interface
     double precision function integrandTemplate(x)
       double precision, intent(in   ) :: x
     end function integrandTemplate
  end interface

contains

  !# <mergerTreeAnalysisTask>
  !#  <unitName>Galacticus_Output_Analysis_Correlation_Functions</unitName>
  !# </mergerTreeAnalysisTask>
  subroutine Galacticus_Output_Analysis_Correlation_Functions(tree,node,nodeStatus,iOutput,mergerTreeAnalyses)
    !% Construct correlation functions to compare to various observational determinations.
    use, intrinsic :: ISO_C_Binding
    use Galacticus_Nodes
    use Galacticus_Paths
    use ISO_Varying_String
    use Memory_Management
    use Cosmology_Parameters
    use Galactic_Structure_Enclosed_Masses
    use Input_Parameters
    use Galacticus_Output_Times
    use Galacticus_Error
    use Cosmology_Functions
    use String_Handling
    use Galacticus_Output_Analyses_Cosmology_Scalings
    use Numerical_Comparison
    use Numerical_Ranges
    use IO_HDF5
    use Linear_Growth
    use Galacticus_Output_Merger_Tree_Data
    implicit none
    type            (mergerTree                    ), intent(inout)                 :: tree
    type            (treeNode                      ), intent(inout), pointer        :: node
    integer                                         , intent(in   )                 :: nodeStatus
    integer         (c_size_t                      ), intent(in   )                 :: iOutput
    type            (varying_string                ), intent(in   ), dimension(:  ) :: mergerTreeAnalyses
    class           (cosmologyFunctionsClass       )               , pointer        :: cosmologyFunctionsModel
    class           (linearGrowthClass             )               , pointer        :: linearGrowth_
    integer                                         , parameter                     :: wavenumberCount  =60
    double precision                                , parameter                     :: wavenumberMinimum=0.001d0, wavenumberMaximum=10000.0d0
    type            (cosmologyFunctionsMatterLambda)                                :: cosmologyFunctionsObserved
    type            (cosmologyParametersSimple     ), pointer                       :: cosmologyParametersObserved => null()
    double precision                                                                :: mass, massLogarithmic, dataHubbleParameter, dataOmegaMatter, dataOmegaDarkEnergy, redshift, timeMinimum, timeMaximum, distanceMinimum, distanceMaximum, weight
    integer                                                                         :: i,j,k,m, currentAnalysis, activeAnalysisCount,massCount
    integer         (c_size_t                      )                                :: jOutput
    type            (varying_string                )                                :: parameterName, cosmologyScalingMass, cosmologyScalingSize, message
    type            (hdf5Object                    )                                :: dataFile        , parameters, dataset

    ! Initialize the module if necessary.
    if (.not.moduleInitialized) then
       !$omp critical(Galacticus_Output_Analysis_Correlation_Functions_Initialize)
       if (.not.moduleInitialized) then
          !# <inputParameter>
          !#   <name>analysisProjectedCorrelationFunctionsHaloMassBinsPerDecade</name>
          !#   <cardinality>0..1</cardinality>
          !#   <defaultValue>10</defaultValue>
          !#   <description>The number of bins per decade of halo mass to use when constructing the mass function covariance matrix for main branch galaxies.</description>
          !#   <group>output</group>
          !#   <source>globalParameters</source>
          !#   <type>real</type>
          !# </inputParameter>
          !# <inputParameter>
          !#   <name>analysisProjectedCorrelationFunctionsHaloMassMinimum</name>
          !#   <cardinality>0..1</cardinality>
          !#   <defaultValue>1.0d8</defaultValue>
          !#   <description>The minimum halo mass to consider when constructing the mass function covariance matrix for main branch galaxies.</description>
          !#   <group>output</group>
          !#   <source>globalParameters</source>
          !#   <type>real</type>
          !# </inputParameter>
          !# <inputParameter>
          !#   <name>analysisProjectedCorrelationFunctionsHaloMassMaximum</name>
          !#   <cardinality>0..1</cardinality>
          !#   <defaultValue>1.0d16</defaultValue>
          !#   <description>The maximum halo mass to consider when constructing the mass function covariance matrix for main branch galaxies.</description>
          !#   <group>output</group>
          !#   <source>globalParameters</source>
          !#   <type>real</type>
          !# </inputParameter>
          analysisProjectedCorrelationFunctionsHaloMassMinimumLogarithmic=log10(analysisProjectedCorrelationFunctionsHaloMassMinimum)
          analysisProjectedCorrelationFunctionsHaloMassBinsCount=int(log10(analysisProjectedCorrelationFunctionsHaloMassMaximum/analysisProjectedCorrelationFunctionsHaloMassMinimum)*dble(analysisProjectedCorrelationFunctionsHaloMassBinsPerDecade)+0.5d0)
          haloMassIntervalLogarithmicInverse=dble(analysisProjectedCorrelationFunctionsHaloMassBinsCount)/log10(analysisProjectedCorrelationFunctionsHaloMassMaximum/analysisProjectedCorrelationFunctionsHaloMassMinimum)
          ! Validate correlation function descriptors.
          call validateDescriptors(correlationFunctionDescriptors)
          ! Establish mapping functions for correlation function descriptors.
          correlationFunctionDescriptors(1)%mapMass => null()
          ! Determine how many supported mass functions are requested.
          activeAnalysisCount=0
          do i=1,correlationFunctionsSupportedCount
             if (any(trim(mergerTreeAnalyses) == trim(correlationFunctionLabels(i)))) activeAnalysisCount=activeAnalysisCount+1
          end do
          ! Allocate mass function arrays and populate with required data.
          if (activeAnalysisCount <= 0) then
             analysisActive=.false.
          else
             analysisActive=.true.
             cosmologyFunctionsModel => cosmologyFunctions()
             ! Establish survey geometries.
             allocate(surveyGeometryHearin2014SDSS :: correlationFunctionDescriptors(1)%geometry)
             select type (g => correlationFunctionDescriptors(1)%geometry)
             type is (surveyGeometryHearin2014SDSS)
                g=surveyGeometryHearin2014SDSS(cosmologyFunctionsModel)
             end select
             ! Initialize correlation functions.
             currentAnalysis=0
             allocate(correlationFunctions(activeAnalysisCount))
             linearGrowth_ => linearGrowth()
             do i=1,size(mergerTreeAnalyses)
                do j=1,correlationFunctionsSupportedCount
                   if (mergerTreeAnalyses(i) == trim(correlationFunctionLabels(j))) then
                      currentAnalysis=currentAnalysis+1
                      ! Set a pointer to the descriptor for this size function.
                      correlationFunctions(currentAnalysis)%descriptor => correlationFunctionDescriptors(j)
                      ! Read parameters of the systematic error model.
                      if (correlationFunctionDescriptors(j)%massSystematicCoefficientCount > 0) then
                         allocate(correlationFunctions(currentAnalysis)%massSystematicCoefficients(correlationFunctionDescriptors(j)%massSystematicCoefficientCount))
                         do k=1,correlationFunctionDescriptors(j)%massSystematicCoefficientCount
                            parameterName=trim(correlationFunctionLabels(j))//'MassSystematic'
                            parameterName=parameterName//(k-1)
                            !# <inputParameter>
                            !#   <name>char(parameterName)</name>
                            !#   <variable>correlationFunctions(currentAnalysis)%massSystematicCoefficients(k)</variable>
                            !#   <source>globalParameters</source>
                            !#   <regEx>(sdssClustering)Z[0-9\.]+MassSystematic[0-9]+</regEx>
                            !#   <defaultValue>0.0d0</defaultValue>
                            !#   <description>Correlation function systematic error model parameters.</description>
                            !#   <type>real</type>
                            !#   <cardinality>1</cardinality>
                            !# </inputParameter>
                         end do
                      end if
                      ! Read parameters of the random error model.
                      if (correlationFunctionDescriptors(j)%massRandomCoefficientCount > 0) then
                         allocate(correlationFunctions(currentAnalysis)%massRandomCoefficients(correlationFunctionDescriptors(j)%massRandomCoefficientCount))
                         do k=1,correlationFunctionDescriptors(j)%massRandomCoefficientCount
                            parameterName=trim(correlationFunctionLabels(j))//'MassRandom'
                            parameterName=parameterName//(k-1)
                            !# <inputParameter>
                            !#   <name>char(parameterName)</name>
                            !#   <variable>correlationFunctions(currentAnalysis)%massRandomCoefficients(k)</variable>
                            !#   <regEx>(sdssClustering)Z[0-9\.]+MassRandom[0-9]+</regEx>
                            !#   <defaultValue>0.0d0</defaultValue>
                            !#   <source>globalParameters</source>
                            !#   <description>Correlation function mass random parameters.</description>
                            !#   <type>real</type>
                            !#   <cardinality>1</cardinality>
                            !# </inputParameter>
                         end do
                      end if
                      parameterName=trim(correlationFunctionLabels(j))//'MassRandomMinimum'
                      !# <inputParameter>
                      !#   <name>char(parameterName)</name>
                      !#   <variable>correlationFunctions(currentAnalysis)%massRandomMinimum</variable>
                      !#   <regEx>(sdssClustering)Z[0-9\.]+MassRandomMinimum</regEx>
                      !#   <defaultValue>1.0d-3</defaultValue>
                      !#   <source>globalParameters</source>
                      !#   <description>Correlation function mass random minimum.</description>
                      !#   <type>real</type>
                      !#   <cardinality>1</cardinality>
                      !# </inputParameter>
                      parameterName=trim(correlationFunctionLabels(j))//'MassRandomMaximum'
                      !# <inputParameter>
                      !#   <name>char(parameterName)</name>
                      !#   <variable>correlationFunctions(currentAnalysis)%massRandomMaximum</variable>
                      !#   <regEx>(sdssClustering)Z[0-9\.]+MassRandomMaximum</regEx>
                      !#   <defaultValue>1.0d-3</defaultValue>
                      !#   <source>globalParameters</source>
                      !#   <description>Correlation function mass random maximum.</description>
                      !#   <type>real</type>
                      !#   <cardinality>1</cardinality>
                      !# </inputParameter>
                      ! Read the appropriate observational data definition.
                      select case (trim(correlationFunctionLabels(j)))
                      case ('sdssClusteringZ0.07')
                         ! Read data for the Hearin et al. (2013) projected correlation function.
                         !$ call hdf5Access%set()
                         call dataFile%openFile(char(galacticusPath(pathTypeDataStatic)//'/observations/correlationFunctions/Projected_Correlation_Functions_Hearin_2013.hdf5'),readOnly=.true.)
                         ! Extract parameters.
                         parameters =dataFile%openGroup('Parameters')
                         call parameters %readAttribute('H_0'                                         ,dataHubbleParameter                                   )
                         call parameters %readAttribute('Omega_Matter'                                ,dataOmegaMatter                                       )
                         call parameters %readAttribute('Omega_DE'                                    ,dataOmegaDarkEnergy                                   )
                         call parameters %readAttribute('projectedCorrelationFunctionLineOfSightDepth',correlationFunctions(currentAnalysis)%lineOfSightDepth)
                         call parameters %close()
                         ! Read cosmology scalings.
                         dataset=dataFile%openDataset('massMinimum')
                         call dataset%readAttribute('cosmologyScaling',cosmologyScalingMass,allowPseudoScalar=.true.)
                         call dataset%close()
                         dataset=dataFile%openDataset('separation')
                         call dataset%readAttribute('cosmologyScaling',cosmologyScalingSize,allowPseudoScalar=.true.)
                         call dataset%close()
                         ! Extract minimum mass.
                         call dataFile%readDataset('massMinimum'       ,correlationFunctions(currentAnalysis)%massMinimum       )
                         correlationFunctions(currentAnalysis)%massMinimumLogarithmic=log10(correlationFunctions(currentAnalysis)%massMinimum)
                         ! Extract separations.
                         call dataFile%readDataset('separationObserved',correlationFunctions(currentAnalysis)%separation        )
                         ! Extract integral constraint.
                         call dataFile%readDataset('integralConstraint',correlationFunctions(currentAnalysis)%integralConstraint)
                         ! Done.
                         call dataFile%close()
                         !$ call hdf5Access%unset()                      
                         ! Create the observed cosmology.
                         allocate(cosmologyParametersObserved)
                         cosmologyParametersObserved=cosmologyParametersSimple     (                                     &
                              &                                                     OmegaMatter    =dataOmegaMatter    , &
                              &                                                     OmegaDarkEnergy=dataOmegaDarkEnergy, &
                              &                                                     HubbleConstant =dataHubbleParameter, &
                              &                                                     temperatureCMB =0.0d0              , &
                              &                                                     OmegaBaryon    =0.0d0                &
                              &                                                    )
                         cosmologyFunctionsObserved =cosmologyFunctionsMatterLambda(                                     &
                              &                                                     cosmologyParametersObserved          &
                              &                                                    )
                         ! Allocate wavenumbers.
                         massCount=size(correlationFunctions(currentAnalysis)%massMinimum)
                         call allocateArray(correlationFunctions(currentAnalysis)%wavenumber           ,[wavenumberCount                                                                 ])
                         call allocateArray(correlationFunctions(currentAnalysis)%meanDensity          ,[                massCount                                                       ])
                         call allocateArray(correlationFunctions(currentAnalysis)%meanDensityMainBranch,[                massCount,analysisProjectedCorrelationFunctionsHaloMassBinsCount])
                         call allocateArray(correlationFunctions(currentAnalysis)%countMainBranch      ,[                          analysisProjectedCorrelationFunctionsHaloMassBinsCount])
                         call allocateArray(correlationFunctions(currentAnalysis)%oneHaloTermMainBranch,[wavenumberCount,massCount,analysisProjectedCorrelationFunctionsHaloMassBinsCount])
                         call allocateArray(correlationFunctions(currentAnalysis)%twoHaloTermMainBranch,[wavenumberCount,massCount,analysisProjectedCorrelationFunctionsHaloMassBinsCount])
                         call allocateArray(correlationFunctions(currentAnalysis)%oneHaloTerm          ,[wavenumberCount,massCount                                                       ])
                         call allocateArray(correlationFunctions(currentAnalysis)%twoHaloTerm          ,[wavenumberCount,massCount                                                       ])
                         call allocateArray(correlationFunctions(currentAnalysis)%termCovariance       ,[massCount*(2*wavenumberCount+1),massCount*(2*wavenumberCount+1)                 ])
                         correlationFunctions(currentAnalysis)%wavenumber=Make_Range(wavenumberMinimum,wavenumberMaximum,wavenumberCount,rangeTypeLogarithmic)
                      case default
                         massCount=0
                         call Galacticus_Error_Report('unknown size function'//{introspection:location})
                      end select
                      ! Get cosmological conversion factors.
                      call allocateArray(correlationFunctions(currentAnalysis)%cosmologyConversionMass,[Galacticus_Output_Time_Count()])
                      call allocateArray(correlationFunctions(currentAnalysis)%cosmologyConversionSize,[Galacticus_Output_Time_Count()])
                      do jOutput=1,Galacticus_Output_Time_Count()
                         redshift=                                                                                      &
                              &   cosmologyFunctionsModel %redshiftFromExpansionFactor(                                 &
                              &    cosmologyFunctionsModel%expansionFactor             (                                &
                              &                                                         Galacticus_Output_Time(jOutput) &
                              &                                                        )                                &
                              &                                                       )
                         call Cosmology_Conversion_Factors(                                                                                                        &
                              &                            redshift                                                                                              , &
                              &                            cosmologyFunctionsModel                                                                               , &
                              &                            cosmologyFunctionsObserved                                                                            , &
                              &                            cosmologyScalingMass           =cosmologyScalingMass                                                  , &
                              &                            cosmologyScalingSize           =cosmologyScalingSize                                                  , &
                              &                            cosmologyConversionMass        =correlationFunctions(currentAnalysis)%cosmologyConversionMass(jOutput), &
                              &                            cosmologyConversionSize        =correlationFunctions(currentAnalysis)%cosmologyConversionSize(jOutput)  &
                              &                           )
                      end do
                      nullify(cosmologyParametersObserved)
                      ! Compute output weights for correlation function. We assume a volume limited survey at the minimum mass.
                      call allocateArray(correlationFunctions(currentAnalysis)%linearGrowthFactor,[    massCount                                              ])
                      call allocateArray(correlationFunctions(currentAnalysis)%outputWeight      ,[int(massCount,kind=c_size_t),Galacticus_Output_Time_Count()])
                      correlationFunctions(currentAnalysis)%outputWeight      =0.0d0
                      correlationFunctions(currentAnalysis)%linearGrowthFactor=0.0d0
                      do k=1,massCount
                         do jOutput=1,Galacticus_Output_Time_Count()
                            do m=1,correlationFunctions(currentAnalysis)%descriptor%geometry%fieldCount()
                               if (jOutput == Galacticus_Output_Time_Count()) then
                                  timeMaximum=     Galacticus_Output_Time(jOutput)
                               else
                                  timeMaximum=sqrt(Galacticus_Output_Time(jOutput)*Galacticus_Output_Time(jOutput+1))
                               end if
                               if (jOutput ==                              1) then
                                  timeMinimum=     Galacticus_Output_Time(jOutput)
                               else
                                  timeMinimum=sqrt(Galacticus_Output_Time(jOutput)*Galacticus_Output_Time(jOutput-1))
                               end if
                               distanceMinimum=max(                                                                                                                                         &
                                    &              cosmologyFunctionsModel%distanceComoving(timeMaximum)                                                                                  , &
                                    &              correlationFunctions(currentAnalysis)%descriptor%geometry%distanceMinimum(correlationFunctions(currentAnalysis)%massMinimum(k),field=m)  &
                                    &             )
                               distanceMaximum=min(                                                                                                                                         &
                                    &              cosmologyFunctionsModel%distanceComoving(timeMinimum)                                                                                  , &
                                    &              correlationFunctions(currentAnalysis)%descriptor%geometry%distanceMaximum(correlationFunctions(currentAnalysis)%massMinimum(k),field=m)  &
                                    &             )
                               weight=+correlationFunctions(currentAnalysis)%descriptor%geometry%solidAngle(m)  &
                                    & /3.0d0                                                                    &
                                    & *                                                                         &
                                    & max(                                                                      &
                                    &     +0.0d0                                                              , &
                                    &     +distanceMaximum**3                                                   &
                                    &     -distanceMinimum**3                                                   &
                                    &    )
                               correlationFunctions        (currentAnalysis)%outputWeight(k,jOutput) &
                                    & =correlationFunctions(currentAnalysis)%outputWeight(k,jOutput) &
                                    & +weight
                               correlationFunctions        (currentAnalysis)%linearGrowthFactor(k)= &
                                    & +correlationFunctions(currentAnalysis)%linearGrowthFactor(k)  &
                                    & +weight                                                       &
                                    & *linearGrowth_%value(Galacticus_Output_Time(jOutput))**2
                            end do
                         end do
                         where(correlationFunctions(currentAnalysis)%outputWeight(k,:) < 0.0d0)
                            correlationFunctions(currentAnalysis)%outputWeight(k,:)=0.0d0
                         end where
                         if (any(correlationFunctions(currentAnalysis)%outputWeight(k,:) > 0.0d0)) then
                            correlationFunctions                        (currentAnalysis)%linearGrowthFactor(k  )  &
                                 &       =sqrt(                                                                    &
                                 &             +    correlationFunctions(currentAnalysis)%linearGrowthFactor(k  )  &
                                 &             /sum(correlationFunctions(currentAnalysis)%outputWeight      (k,:)) &
                                 &            )
                            correlationFunctions                        (currentAnalysis)%outputWeight      (k,:)  &
                                 &       =     +    correlationFunctions(currentAnalysis)%outputWeight      (k,:)  &
                                 &             /sum(correlationFunctions(currentAnalysis)%outputWeight      (k,:))
                         else
                            message="correlation function '"//trim(correlationFunctions(currentAnalysis)%descriptor%label)//"' mass bin "
                            message=message//k//" has zero weights"
                            call Galacticus_Error_Report(message//{introspection:location})
                         end if
                      end do
                      ! Initialize population statistics.
                      correlationFunctions(currentAnalysis)%countMainBranch      =0
                      correlationFunctions(currentAnalysis)%meanDensity          =0.0d0
                      correlationFunctions(currentAnalysis)%meanDensityMainBranch=0.0d0
                      correlationFunctions(currentAnalysis)%oneHaloTermMainBranch=0.0d0
                      correlationFunctions(currentAnalysis)%twoHaloTermMainBranch=0.0d0
                      correlationFunctions(currentAnalysis)%oneHaloTerm          =0.0d0
                      correlationFunctions(currentAnalysis)%twoHaloTerm          =0.0d0
                      correlationFunctions(currentAnalysis)%termCovariance       =0.0d0
                      exit
                  end if
               end do
             end do
          end if
          ! Record that module is initialized.
          moduleInitialized=.true.
       end if
       !$omp end critical(Galacticus_Output_Analysis_Correlation_Functions_Initialize)
    end if
    ! Return if this analysis is not active.
    if (.not.analysisActive) return
    ! Accumulate halo and return on tree finalization.
    if (nodeStatus == nodeStatusFinal) then
       if (allocated(haloWork)) then
          do i=1,size(correlationFunctions)
             if (haloWork(i)%initialized) call Accumulate_Halo(correlationFunctions(i),haloWork(i))
          end do
       end if
       return
    end if
    ! Allocate work arrays.
    if (.not.allocated(haloWork)) then
       allocate(haloWork(size(correlationFunctions)))
       haloWork%initialized=.false.
    end if
    ! Iterate over active analyses.
    do i=1,size(correlationFunctions)
       ! Return if this correlation function receives no contribution from this output number.
       if (all(correlationFunctions(i)%outputWeight(:,iOutput) <= 0.0d0)) cycle
       ! Get the galactic mass.
       mass=                                                                                                                                               &
            &  Galactic_Structure_Enclosed_Mass(node,radiusLarge,componentType=componentTypeDisk    ,massType=correlationFunctions(i)%descriptor%massType) &
            & +Galactic_Structure_Enclosed_Mass(node,radiusLarge,componentType=componentTypeSpheroid,massType=correlationFunctions(i)%descriptor%massType)
       if (mass <= 0.0d0) cycle
       if (associated(correlationFunctions(i)%descriptor%mapMass)) mass=correlationFunctions(i)%descriptor%mapMass(mass,node)
       mass=mass*correlationFunctions(i)%cosmologyConversionMass(iOutput) ! Convert for cosmology.
       massLogarithmic=log10(mass)
       do j=1,correlationFunctions(i)%descriptor%massSystematicCoefficientCount
          massLogarithmic=+massLogarithmic                                          &
               &          +correlationFunctions(i)%massSystematicCoefficients(j)    &
               &          *(                                                        &
               &            +log10(mass)                                            &
               &            -correlationFunctions(i)%descriptor%massSystematicLogM0 &
               &          )**(j-1)
       end do
       if (massLogarithmic < correlationFunctions(i)%descriptor%massLogarithmicMinimum) cycle
       ! Accumulate the node.
       call Accumulate_Node(correlationFunctions(i),haloWork(i),tree,node,mass,massLogarithmic,iOutput)
       ! Accumulate halo if this is the last node in the tree.
       if (nodeStatus == nodeStatusLast) call Accumulate_Halo(correlationFunctions(i),haloWork(i))
    end do
    return
  end subroutine Galacticus_Output_Analysis_Correlation_Functions

  subroutine Accumulate_Node(correlationFunction_,haloWork,tree,node,mass,massLogarithmic,iOutput)
    !% Accumulate a single galaxy to the population of the current halo. Since galaxy masses
    !% have random errors, each galaxy added is assigned an inclusion probability, which will be
    !% taken into account when evaluating the one- and two-halo terms from this halo in the halo
    !% model.
    use, intrinsic :: ISO_C_Binding
    use Dark_Matter_Halo_Biases
    use Cosmology_Functions
    use Dark_Matter_Profiles
    use Memory_Management
    use Galacticus_Output_Merger_Tree_Data
    implicit none
    type            (correlationFunction    ), intent(inout)                 :: correlationFunction_
    type            (correlationFunctionWork), intent(inout)                 :: haloWork
    type            (mergerTree             ), intent(in   )                 :: tree
    type            (treeNode               ), intent(inout), pointer        :: node
    double precision                         , intent(in   )                 :: mass                     , massLogarithmic
    integer         (c_size_t               ), intent(in   )                 :: iOutput
    type            (treeNode               )               , pointer        :: hostNode
    class           (cosmologyFunctionsClass)               , pointer        :: cosmologyFunctions_    
    class           (nodeComponentBasic     )               , pointer        :: basic                    , basicRoot
    class           (darkMatterProfileClass )               , pointer        :: darkMatterProfile_
    class           (darkMatterHaloBiasClass)               , pointer        :: darkMatterHaloBias_
    double precision                         , allocatable  , dimension(:,:) :: satelliteProbabilityTmp
    integer                                  , parameter                     :: satelliteCountMinimum=100
    integer         (kind=kind_int8        )                                 :: hostIndex    
    integer                                                                  :: i, j
    double precision                                                         :: expansionFactor          , galaxyInclusionProbability, &
         &                                                                      randomError
    logical                                                                  :: satelliteIncluded
    
    ! Get the index of the host halo.
    if (node%isSatellite()) then
       hostNode => node%parent
    else
       hostNode => node
    end if
    hostIndex=hostNode%uniqueID()
    ! Allocate arrays.
    if (.not.haloWork%initialized) then
       call allocateArray(haloWork%centralProbability,[size(correlationFunction_%massMinimumLogarithmic)])
       call allocateArray(haloWork%fourierProfile    ,[size(correlationFunction_%wavenumber            )])
       allocate  (haloWork%satelliteProbability(0,0))
       deallocate(haloWork%satelliteProbability     )
       haloWork%propertiesSet     =.false.
       haloWork%satelliteCount    =0
       haloWork%centralProbability=0.0d0
       haloWork%isMainBranch      =.false.
       haloWork%initialized       =.true.
       haloWork%treeIndex         =-1_kind_int8
       haloWork%haloIndex         =-1_kind_int8
    end if
    ! Check if the host has changed.
    if     (                                       &
         &   tree     %index /= haloWork%treeIndex &
         &  .or.                                   &
         &   hostIndex       /= haloWork%haloIndex &
         & )                                       &
         & call Accumulate_Halo(correlationFunction_,haloWork)
    ! Accumulate properties to the current halo.
    haloWork%treeIndex=tree%index
    haloWork%haloIndex=hostIndex
    ! Find the random error on the galaxy mass.
    if (associated(correlationFunction_%descriptor%massRandomErrorFunction)) then
       randomError=correlationFunction_%descriptor%massRandomErrorFunction(mass,node)
    else
       randomError=0.0d0
       do j=1,correlationFunction_%descriptor%massRandomCoefficientCount
          randomError=+randomError                                               &
               &          +correlationFunction_%massRandomCoefficients(j)        &
               &          *(                                                     &
               &            +log10(mass)                                         &
               &            -correlationFunction_%descriptor%massSystematicLogM0 &
               &           )**(j-1)
       end do
       randomError=max(min(randomError,correlationFunction_%massRandomMaximum),correlationFunction_%massRandomMinimum)
    end if
    ! Iterate over mass ranges.
    satelliteIncluded=.false.
    do j=1,size(correlationFunction_%massMinimumLogarithmic)
       ! Find the probability that this galaxy is included in the sample.
       galaxyInclusionProbability=0.5d0*(1.0d0-erf((correlationFunction_%massMinimumLogarithmic(j)-massLogarithmic)/randomError/sqrt(2.0d0)))
       if (node%isSatellite()) then
          if (galaxyInclusionProbability > 0.0d0) then
             if (.not.satelliteIncluded) then
                satelliteIncluded=.true.
                haloWork%satelliteCount=haloWork%satelliteCount+1
                if (.not.allocated(haloWork%satelliteProbability)) then
                   call allocateArray(haloWork%satelliteProbability,[satelliteCountMinimum,size(correlationFunction_%massMinimumLogarithmic)])
                else if (size(haloWork%satelliteProbability,dim=1) < haloWork%satelliteCount) then
                   call Move_Alloc(haloWork%satelliteProbability,satelliteProbabilityTmp)
                   call allocateArray(haloWork%satelliteProbability,[2*size(satelliteProbabilityTmp,dim=1),size(correlationFunction_%massMinimumLogarithmic)])
                   haloWork%satelliteProbability(1:size(satelliteProbabilityTmp,dim=1),:)=satelliteProbabilityTmp
                   call deallocateArray(satelliteProbabilityTmp)
                end if
                haloWork%satelliteProbability(haloWork%satelliteCount,:)=0.0d0
             end if
             haloWork%satelliteProbability(haloWork%satelliteCount,j)=galaxyInclusionProbability
          end if
       else
          haloWork%centralProbability(j)=  galaxyInclusionProbability
       end if
       if (galaxyInclusionProbability > 0.0d0 .and. .not.haloWork%propertiesSet) then
          cosmologyFunctions_           => cosmologyFunctions      (        )
          darkMatterProfile_            => darkMatterProfile       (        )
          darkMatterHaloBias_           => darkMatterHaloBias      (        )
          haloWork%propertiesSet        =  .true.
          haloWork%isMainBranch         =  hostNode %isOnMainBranch(        )
          basic                     => hostNode          %basic(        )
          basicRoot                     => tree     %baseNode%basic(        )
          haloWork%haloMass             =  basicRoot%mass          (        )
          haloWork%hostMass             =  basic%mass          (        )
          haloWork%haloWeight           =  tree     %volumeWeight
          haloWork%outputNumber         =  iOutput
          haloWork%haloTime             =  basic%time          (        )
          haloWork%haloBias             =  darkMatterHaloBias_%bias(hostNode)
          expansionFactor               =  cosmologyFunctions_%expansionFactor(basic%time())
          do i=1,size(correlationFunction_%wavenumber)
             ! Note that wavenumbers must be converted from comoving to physical units for the dark matter profile k-space function.
             haloWork%fourierProfile(i)=darkMatterProfile_%kSpace(                                                        &
                  &                                                hostNode                                             , &
                  &                                                correlationFunction_%waveNumber             (i      )  &
                  &                                               *correlationFunction_%cosmologyConversionSize(iOutput)  &
                  &                                               /expansionFactor                                        &
                  &                                              )
          end do
       end if
    end do
    return
  end subroutine Accumulate_Node

  subroutine Accumulate_Halo(correlationFunction_,haloWork)
    !% Assumulate a single halo's contributions to the halo model one- and two-halo terms. For
    !% the one-halo term we count contributions from central-satellite pairs, and from
    !% satellite-satellite pairs. Contributions differ in the scalings applied to the
    !% Fourier-transformed dark matter halo density profile---see
    !% \cite[][\S6.1]{cooray_halo_2002} for a discussion of this. The number of satellites in
    !% the halo is assumed to follow a Poisson binomial distribution.
    use Math_Distributions_Poisson_Binomial
    use Vectors
    use Halo_Model_Power_Spectrum_Modifiers
    use Linear_Algebra
    implicit none
    type            (correlationFunction                ), intent(inout)                                                               :: correlationFunction_        
    type            (correlationFunctionWork            ), intent(inout)                                                               :: haloWork
    double precision                                                    , dimension(                                                                                                                   &
         &                                                                          size(correlationFunction_%wavenumber            ),                                                                 &
         &                                                                          size(correlationFunction_%massMinimumLogarithmic)                                                                  &
         &                                                                         )                                                   :: oneHaloTerm                , twoHaloTerm
    double precision                                                    , dimension(size(correlationFunction_%massMinimumLogarithmic)) :: galaxyDensity
    logical                                                             , dimension(size(correlationFunction_%massMinimumLogarithmic)) :: oneHaloTermActive              , twoHaloTermActive
    double precision                                     , allocatable  , dimension(:,:                                              ) :: termJacobian                   , termCovariance            , &
         &                                                                                                                                mainBranchTermCovariance       , modifierCovariance
    double precision                                     , allocatable  , dimension(:                                                ) :: satelliteJacobian              , modifierCovarianceDiagonal
    class           (haloModelPowerSpectrumModifierClass), pointer                                                                     :: haloModelPowerSpectrumModifier_
    double precision                                                                                                                   :: satellitePairsCountMean        , satelliteCountMean        , &
         &                                                                                                                                haloWeightOutput
    integer                                                                                                                            :: wavenumberCount                , haloMassBin               , &
         &                                                                                                                                i                              , j                         , &
         &                                                                                                                                indexOneHalo                   , indexTwoHalo              , &
         &                                                                                                                                indexDensity                   , massCount
    logical                                                                                                                            :: mainBranchCounted    
    type            (matrix                             )                                                                              :: jacobianMatrix

    ! Return immediately if no nodes have been accumulated.
    if (haloWork%treeIndex /= -1_kind_int8) then
       oneHaloTermActive=.false.
       twoHaloTermActive=.false.
       mainBranchCounted=.false.
       massCount        =size(correlationFunction_%massMinimumLogarithmic)
       wavenumberCount  =size(correlationFunction_%wavenumber            )
       allocate(termJacobian              (massCount*(2*wavenumberCount+1),haloWork%satelliteCount+1))
       allocate(satelliteJacobian         (                                haloWork%satelliteCount  ))
       allocate(modifierCovariance        (             wavenumberCount   ,wavenumberCount          ))
       allocate(modifierCovarianceDiagonal(massCount*(2*wavenumberCount+1)                          ))
       haloModelPowerSpectrumModifier_ => haloModelPowerSpectrumModifier()
       termJacobian              =0.0d0
       modifierCovariance        =0.0d0
       modifierCovarianceDiagonal=0.0d0
       ! Iterate over masses.
       do i=1,massCount
           ! Find mean number of satellites and satellite pairs.
          if (haloWork%satelliteCount > 0) then
             satelliteCountMean     =Poisson_Binomial_Distribution_Mean      (haloWork%satelliteProbability(1:haloWork%satelliteCount,i))
             satellitePairsCountMean=Poisson_Binomial_Distribution_Mean_Pairs(haloWork%satelliteProbability(1:haloWork%satelliteCount,i))
          else
             satelliteCountMean     =0.0d0
             satellitePairsCountMean=0.0d0
          end if
          ! Skip if this halo contains no galaxies.
          if (haloWork%centralProbability(i) > 0.0d0 .or. satelliteCountMean > 0.0d0) then             
             ! Compute output halo weight.
             haloWeightOutput=haloWork%haloWeight*correlationFunction_%outputWeight(i,haloWork%outputNumber)
             ! Compute contribution to galaxy density.
             galaxyDensity(i)= haloWeightOutput                 &
                  &           *(                                &
                  &             +haloWork%centralProbability(i) &
                  &             +satelliteCountMean             &
                  &            )             
             ! For main branch galaxies, accumulate their contribution to the density as a function of halo mass, so that we can later subtract this from the variance.
             if (haloWork%isMainBranch) then
                haloMassBin=floor((log10(haloWork%haloMass)-analysisProjectedCorrelationFunctionsHaloMassMinimumLogarithmic)*haloMassIntervalLogarithmicInverse)+1
                ! Accumulate weights to halo mass arrays.
                if (haloMassBin >= 1 .and. haloMassBin <= analysisProjectedCorrelationFunctionsHaloMassBinsCount) then
                   !$omp critical (Analyses_Correlation_Functions_Main_Branch)
                   correlationFunction_        %meanDensityMainBranch(  i,haloMassBin)=   &
                        & +correlationFunction_%meanDensityMainBranch(  i,haloMassBin)    &
                        & +haloWeightOutput                                               &
                        & *haloWork               %centralProbability   (  i            )
                   correlationFunction_        %oneHaloTermMainBranch(:,i,haloMassBin)=   &
                        & +correlationFunction_%oneHaloTermMainBranch(:,i,haloMassBin)    &
                        & +haloWeightOutput                                               &
                        & *haloWork               %centralProbability   (  i            ) &
                        & *satelliteCountMean                                             &
                        & *haloWork%fourierProfile
                   correlationFunction_        %twoHaloTermMainBranch(:,i,haloMassBin)=   &
                        & +correlationFunction_%twoHaloTermMainBranch(:,i,haloMassBin)    &
                        & +haloWeightOutput                                               &
                        & *haloWork               %centralProbability   (  i            ) &
                        & *haloWork%haloBias                                              &
                        & *haloWork%fourierProfile
                   !$omp end critical (Analyses_Correlation_Functions_Main_Branch)
                   ! If this is the first mass bin in which the central, main branch galaxy is seen, increment the number of main branch galaxies.
                   if (.not.mainBranchCounted) then
                      mainBranchCounted=.true.
                      !$omp atomic
                      correlationFunction_%countMainBranch(haloMassBin)=correlationFunction_%countMainBranch(haloMassBin)+1
                   end if
                end if
             end if
             ! Accumulate contribution to galaxy density.
             !$omp atomic
             correlationFunction_%meanDensity(i)= correlationFunction_%meanDensity(i) &
                  &                              +galaxyDensity                   (i)
             ! Compute and accumulate one-halo term.
             if (satelliteCountMean > 0.0d0) then
                oneHaloTermActive(  i)=.true.
                oneHaloTerm  (:,i)= haloWeightOutput                      &
                     &                 *(                                &
                     &                   +haloWork%centralProbability(i) &
                     &                   *satelliteCountMean             &
                     &                   *haloWork%fourierProfile        &
                     &                   +satellitePairsCountMean        &
                     &                   *haloWork%fourierProfile    **2 &
                     &                  )
                call haloModelPowerSpectrumModifier_%modify(                                                                      &
                     &                                       correlationFunction_%wavenumber                                      &
                     &                                      *correlationFunction_%cosmologyConversionSize(haloWork%outputNumber), &
                     &                                       haloModelTermOneHalo                                               , &
                     &                                       oneHaloTerm(:,i)                                                   , &
                     &                                       modifierCovariance                                                 , &
                     &                                       mass=haloWork%hostMass                                               &
                     &                                     )
                call Term_Indices(i,wavenumberCount,indexOneHalo,indexTwoHalo,indexDensity)
                forall(j=1:wavenumberCount)
                   modifierCovarianceDiagonal(indexOneHalo+j-1)=modifierCovariance(j,j)
                end forall
                modifierCovarianceDiagonal(indexDensity)=0.0d0
                !$omp critical(Analyses_Correlation_Functions_Accumulate1)
                correlationFunction_%oneHaloTerm(:,i)= correlationFunction_%oneHaloTerm(:,i) &
                     &                                +oneHaloTerm                     (:,i)
                !$omp end critical(Analyses_Correlation_Functions_Accumulate1)
             end if
             ! Compute and accumulate two-halo term.
             twoHaloTermActive(  i)=.true.
             twoHaloTerm  (:,i)= galaxyDensity(i)        &
                  &             *haloWork%haloBias       &
                  &             *haloWork%fourierProfile
             call haloModelPowerSpectrumModifier_%modify(                                                                      &
                  &                                       correlationFunction_%wavenumber                                      &
                  &                                      *correlationFunction_%cosmologyConversionSize(haloWork%outputNumber), &
                  &                                       haloModelTermTwoHalo                                               , &
                  &                                       twoHaloTerm(:,i)                                                   , &
                  &                                       modifierCovariance                                                 , &
                  &                                       mass=haloWork%hostMass                                               &
                  &                                     )
             call Term_Indices(i,wavenumberCount,indexOneHalo,indexTwoHalo,indexDensity)
             forall(j=1:wavenumberCount)
                modifierCovarianceDiagonal(indexTwoHalo+j-1)=modifierCovariance(j,j)
             end forall
             modifierCovarianceDiagonal(indexDensity)=0.0d0
             !$omp critical(Analyses_Correlation_Functions_Accumulate2)
             correlationFunction_%twoHaloTerm(:,i)= correlationFunction_%twoHaloTerm(:,i) &
                  &                                +twoHaloTerm                     (:,i)
             !$omp end critical(Analyses_Correlation_Functions_Accumulate2)
             ! Construct Jacobian of the terms being accumulated. The Jacobian here is an MxN matrix, where M=massCount*(2*wavenumberCount+1)
             ! (the number of terms in halo model quantities being accumulated {wavenumberCount for 1- and 2-halo terms, plus a density, for
             ! each mass bin}), and N is the total number of galaxies in the halo (number of satellites plus 1 central).
             ! Compute indices.
             call Term_Indices(i,wavenumberCount,indexOneHalo,indexTwoHalo,indexDensity)
             ! One halo terms.
             if (haloWork%satelliteCount > 0) then
                satelliteJacobian=Poisson_Binomial_Distribution_Mean_Pairs_Jacobian(haloWork%satelliteProbability(1:haloWork%satelliteCount,i))*haloWork%satelliteProbability(1:haloWork%satelliteCount,i)
                do j=1,wavenumberCount
                   termJacobian(indexOneHalo             +j              -1,1:haloWork%satelliteCount  )=haloWeightOutput                   *haloWork%fourierProfile(j)**2*satelliteJacobian
                end do
             end if
             termJacobian      (indexOneHalo:indexOneHalo+wavenumberCount-1,  haloWork%satelliteCount+1)=haloWeightOutput                   *haloWork%fourierProfile      *haloWork%centralProbability(                           i)*satelliteCountMean
             ! Two halo terms.
             do j=1,wavenumberCount
                termJacobian   (indexTwoHalo             +j              -1,1:haloWork%satelliteCount  )=haloWeightOutput*haloWork%haloBias*haloWork%fourierProfile(j)   *haloWork%satelliteProbability(1:haloWork%satelliteCount,i)
             end do
             termJacobian      (indexTwoHalo:indexTwoHalo+wavenumberCount-1,  haloWork%satelliteCount+1)=haloWeightOutput*haloWork%haloBias*haloWork%fourierProfile      *haloWork%  centralProbability(                          i)
             ! Compute density terms.
             termJacobian      (indexDensity                               ,1:haloWork%satelliteCount  )=haloWeightOutput                                                *haloWork%satelliteProbability(1:haloWork%satelliteCount,i)
             termJacobian      (indexDensity                               ,  haloWork%satelliteCount+1)=haloWeightOutput                                                *haloWork%  centralProbability(                          i)
          end if
       end do
       ! Construct and accumulate term covariance.
       allocate(termCovariance(massCount*(2*wavenumberCount+1),massCount*(2*wavenumberCount+1)))
       jacobianMatrix=termJacobian
       termCovariance=jacobianMatrix*jacobianMatrix%transpose()
       ! Add modifier covariance.
       termCovariance=termCovariance+Vector_Outer_Product(modifierCovarianceDiagonal)
       ! For main branch galaxies, zero all off-diagonal contributions.
       if (haloWork%isMainBranch) then
          termJacobian(:,1:haloWork%satelliteCount)=0.0d0
          jacobianMatrix=termJacobian
          allocate(mainBranchTermCovariance(massCount*(2*wavenumberCount+1),massCount*(2*wavenumberCount+1)))
          mainBranchTermCovariance=jacobianMatrix*jacobianMatrix%transpose()          
          do i=1,massCount
             mainBranchTermCovariance(                                                       &
                  &                   (i-1)*(2*wavenumberCount+1)+1:i*(2*wavenumberCount+1), &
                  &                   (i-1)*(2*wavenumberCount+1)+1:i*(2*wavenumberCount+1)  &
                  &                  )                                                       &
                  &                  =0.0d0
          end do
          termCovariance=termCovariance-mainBranchTermCovariance
          deallocate(mainBranchTermCovariance)
       end if
       !$omp critical(Analyses_Correlation_Functions_Accumulate3)
       correlationFunction_%termCovariance=correlationFunction_%termCovariance+termCovariance
       !$omp end critical(Analyses_Correlation_Functions_Accumulate3)
       deallocate(termJacobian     )
       deallocate(satelliteJacobian)
    end if
    ! Reset counts.
    if (allocated(haloWork%centralProbability)) haloWork%centralProbability=0.0d0
    haloWork%satelliteCount=0
    haloWork%propertiesSet =.false.
    ! Reset indices.
    haloWork%treeIndex=-1_kind_int8
    haloWork%haloIndex=-1_kind_int8
    return
  end subroutine Accumulate_Halo
  
  !# <hdfPreCloseTask>
  !#  <unitName>Galacticus_Output_Analysis_Correlation_Functions_Output</unitName>
  !# </hdfPreCloseTask>
  subroutine Galacticus_Output_Analysis_Correlation_Functions_Output
    !% Outputs correlation functions to file.
    use, intrinsic :: ISO_C_Binding
    use Galacticus_HDF5
    use Power_Spectra
    use Array_Utilities
    use FFTLogs
    use Memory_Management
    use Tables
    use Table_Labels
    use Linear_Algebra
    use Vectors
    implicit none
    double precision                            , allocatable, dimension(:  ) :: separation
    double precision                            , allocatable, dimension(:,:) :: powerSpectrumCovariance       , jacobian                            , &
         &                                                                       correlationCovariance         , covarianceTmp                       , &
         &                                                                       projectedCorrelationCovariance, binnedProjectedCorrelationCovariance, &
         &                                                                       powerSpectrumValue            , correlation                         , &
         &                                                                       projectedCorrelation          , binnedProjectedCorrelation          , &
         &                                                                       oneTwoHaloCovariance
    class           (powerSpectrumClass        ), pointer                     :: powerSpectrum_
    integer                                                                   :: i                             , k                                  , &
         &                                                                       j                             , wavenumberCount, m, n, massCount, indexDensity, indexOneHalo, indexTwoHalo
    type            (hdf5Object                )                              :: analysisGroup                 , correlationFunctionGroup           , &
         &                                                                       dataset
    type            (table1DLogarithmicLinear  )                              :: correlationTable
    double precision                                                          :: projectedSeparation           , binSeparationMinimum               , &
         &                                                                       binSeparationMaximum          , binWidthLogarithmic
    type            (matrix                    )                              :: jacobianMatrix                , covarianceMatrix
    procedure       (integrandTemplate         ), pointer                     :: integrandWeightFunction

    ! Return immediately if this analysis is not active.
    if (.not.analysisActive) return
    ! Get required objects.
    powerSpectrum_ => powerSpectrum()
    ! Iterate over mass functions.
    do k=1,size(correlationFunctions)
       ! Copy upper to lower triangle of covariance matrix (we've accumulated only the upper triangle).
       correlationFunctions(k)%termCovariance=Matrix_Copy_Upper_To_Lower_Triangle(correlationFunctions(k)%termCovariance)
       ! Get count of mass bins and wavenumbers.
       massCount      =size(correlationFunctions(k)%massMinimumLogarithmic)
       wavenumberCount=size(correlationFunctions(k)%wavenumber            )
       ! Find average density contribution of main branch galaxies in each halo mass bin.
       do n=1,massCount
          where    (correlationFunctions(k)%countMainBranch(:) > 0)
             correlationFunctions                (k)%meanDensityMainBranch(n,:)  &
                  &    =     correlationFunctions(k)%meanDensityMainBranch(n,:)  &
                  &    /dble(correlationFunctions(k)%countMainBranch      (  :))
          end where
          do i=1,wavenumberCount
             where (correlationFunctions(k)%countMainBranch(:) > 0)
                correlationFunctions             (k)%oneHaloTermMainBranch(i,n,:)  &
                     & =     correlationFunctions(k)%oneHaloTermMainBranch(i,n,:)  &
                     & /dble(correlationFunctions(k)%countMainBranch      (    :))
                correlationFunctions             (k)%twoHaloTermMainBranch(i,n,:)  &
                     & =     correlationFunctions(k)%twoHaloTermMainBranch(i,n,:)  &
                     & /dble(correlationFunctions(k)%countMainBranch      (    :))
             end where
          end do
       end do
       ! Subtract out Poisson component of main branch galaxy variance (since these galaxies are not Poisson distributed).
       do m=1,massCount
          call Term_Indices(m,wavenumberCount,indexOneHalo,indexTwoHalo,indexDensity)
          do i=1,analysisProjectedCorrelationFunctionsHaloMassBinsCount
             ! Density-density.
             correlationFunctions                                  (k)%termCovariance       (  indexDensity                               ,indexDensity                               )=    &
                  & +                          correlationFunctions(k)%termCovariance       (  indexDensity                               ,indexDensity                               )     &
                  & -                          correlationFunctions(k)%meanDensityMainBranch(  m                                          ,i                                          ) **2 &
                  & *                     dble(correlationFunctions(k)%countMainBranch      (                                              i                                          ))
             ! One-halo-one-halo.
             correlationFunctions                                  (k)%termCovariance       (  indexOneHalo:indexOneHalo+wavenumberCount-1,indexOneHalo:indexOneHalo+wavenumberCount-1)=    &
                  & +                          correlationFunctions(k)%termCovariance       (  indexOneHalo:indexOneHalo+wavenumberCount-1,indexOneHalo:indexOneHalo+wavenumberCount-1)     &
                  & -     Vector_Outer_Product(                                                                                                                                             &
                  &                            correlationFunctions(k)%oneHaloTermMainBranch(:,m                                          ,i                                          ),    &
                  &                            correlationFunctions(k)%oneHaloTermMainBranch(:,m                                          ,i                                          )     &
                  &                           )                                                                                                                                             &
                  & *                     dble(correlationFunctions(k)%countMainBranch      (                                              i                                          ))
             ! Two-halo-two-halo.
             correlationFunctions                                  (k)%termCovariance       (  indexTwoHalo:indexTwoHalo+wavenumberCount-1,indexTwoHalo:indexTwoHalo+wavenumberCount-1)=    &
                  & +                          correlationFunctions(k)%termCovariance       (  indexTwoHalo:indexTwoHalo+wavenumberCount-1,indexTwoHalo:indexTwoHalo+wavenumberCount-1)     &
                  & -     Vector_Outer_Product(                                                                                                                                             &
                  &                            correlationFunctions(k)%twoHaloTermMainBranch(:,m                                          ,i                                          ),    &
                  &                            correlationFunctions(k)%twoHaloTermMainBranch(:,m                                          ,i                                          )     &
                  &                           )                                                                                                                                             &
                  & *                     dble(correlationFunctions(k)%countMainBranch      (                                              i                                          ))
             ! Density-one-halo.
             correlationFunctions                                  (k)%termCovariance       (  indexDensity                               ,indexOneHalo:indexOneHalo+wavenumberCount-1)=    &
                  & +                          correlationFunctions(k)%termCovariance       (  indexDensity                               ,indexOneHalo:indexOneHalo+wavenumberCount-1)     &
                  & -                          correlationFunctions(k)%meanDensityMainBranch(  m                                          ,i                                          )     &
                  & *                          correlationFunctions(k)%oneHaloTermMainBranch(:,m                                          ,i                                          )     &
                  & *                     dble(correlationFunctions(k)%countMainBranch      (                                              i                                          ))
             correlationFunctions                                  (k)%termCovariance       (  indexOneHalo:indexOneHalo+wavenumberCount-1,indexDensity                               )=    &
                  & +                          correlationFunctions(k)%termCovariance       (  indexOneHalo:indexOneHalo+wavenumberCount-1,indexDensity                               )     &
                  & -                          correlationFunctions(k)%oneHaloTermMainBranch(:,m                                          ,i                                          )     &
                  & *                          correlationFunctions(k)%meanDensityMainBranch(  m                                          ,i                                          )     &
                  & *                     dble(correlationFunctions(k)%countMainBranch      (                                              i                                          ))
             ! Density-two-halo.
             correlationFunctions                                  (k)%termCovariance       (  indexDensity                               ,indexTwoHalo:indexTwoHalo+wavenumberCount-1)=    &
                  & +                          correlationFunctions(k)%termCovariance       (  indexDensity                               ,indexTwoHalo:indexTwoHalo+wavenumberCount-1)     &
                  & -                          correlationFunctions(k)%meanDensityMainBranch(  m                                          ,i                                          )     &
                  & *                          correlationFunctions(k)%twoHaloTermMainBranch(:,m                                          ,i                                          )     &
                  & *                     dble(correlationFunctions(k)%countMainBranch      (                                              i                                          ))
             correlationFunctions                                  (k)%termCovariance       (  indexTwoHalo:indexTwoHalo+wavenumberCount-1,indexDensity                               )=    &
                  & +                          correlationFunctions(k)%termCovariance       (  indexTwoHalo:indexTwoHalo+wavenumberCount-1,indexDensity                               )     &
                  & -                          correlationFunctions(k)%twoHaloTermMainBranch(:,m                                          ,i                                          )     &
                  & *                          correlationFunctions(k)%meanDensityMainBranch(  m                                          ,i                                          )     &
                  & *                     dble(correlationFunctions(k)%countMainBranch      (                                              i                                          ))
             ! One-halo-two-halo
             correlationFunctions                                  (k)%termCovariance       (  indexOneHalo:indexOneHalo+wavenumberCount-1,indexTwoHalo:indexTwoHalo+wavenumberCount-1)=    &
                  & +                          correlationFunctions(k)%termCovariance       (  indexOneHalo:indexOneHalo+wavenumberCount-1,indexTwoHalo:indexTwoHalo+wavenumberCount-1)     &
                  & -     Vector_Outer_Product(                                                                                                                                             &
                  &                            correlationFunctions(k)%oneHaloTermMainBranch(:,m                                          ,i                                          ),    &
                  &                            correlationFunctions(k)%twoHaloTermMainBranch(:,m                                          ,i                                          )     &
                  &                           )                                                                                                                                             &
                  & *                     dble(correlationFunctions(k)%countMainBranch      (                                              i                                          ))
             correlationFunctions                                  (k)%termCovariance       (  indexTwoHalo:indexTwoHalo+wavenumberCount-1,indexOneHalo:indexOneHalo+wavenumberCount-1)=    &
                  & +                          correlationFunctions(k)%termCovariance       (  indexTwoHalo:indexTwoHalo+wavenumberCount-1,indexOneHalo:indexOneHalo+wavenumberCount-1)     &
                  & -     Vector_Outer_Product(                                                                                                                                             &
                  &                            correlationFunctions(k)%twoHaloTermMainBranch(:,m                                          ,i                                          ),    &
                  &                            correlationFunctions(k)%oneHaloTermMainBranch(:,m                                          ,i                                          )     &
                  &                           )                                                                                                                                             &
                  & *                     dble(correlationFunctions(k)%countMainBranch      (                                              i                                          ))
          end do
       end do
       ! Normalize one- and two-halo terms.
       call allocateArray(jacobian            ,[massCount*(2*wavenumberCount),massCount*(2*wavenumberCount+1)])
       call allocateArray(oneTwoHaloCovariance,[massCount*(2*wavenumberCount),massCount*(2*wavenumberCount  )])
       ! One-halo term.
       jacobian=0.0d0
       do n=1,massCount
          call Term_Indices(n,wavenumberCount,indexOneHalo,indexTwoHalo,indexDensity)
          if (correlationFunctions(k)%meanDensity(n) > 0.0d0) then
             do i=1,wavenumberCount
                jacobian((n-1)*(2*wavenumberCount)+i,indexOneHalo+i-1)=1.0d0/correlationFunctions(k)%meanDensity(n)**2
             end do
             jacobian((n-1)*(2*wavenumberCount)+1:(n-1)*(2*wavenumberCount)+wavenumberCount,indexDensity)=-2.0d0*correlationFunctions(k)%oneHaloTerm(:,n)/correlationFunctions(k)%meanDensity(n)**3
         end if
       end do
        ! Two-halo term.
       do n=1,massCount
          call Term_Indices(n,wavenumberCount,indexOneHalo,indexTwoHalo,indexDensity)
          if (correlationFunctions(k)%meanDensity(n) > 0.0d0) then
             do i=1,wavenumberCount
                jacobian((n-1)*(2*wavenumberCount)+wavenumberCount+i,indexTwoHalo+i-1)=1.0d0/correlationFunctions(k)%meanDensity(n)
             end do
             jacobian((n-1)*(2*wavenumberCount)+wavenumberCount+1:(n-1)*(2*wavenumberCount)+2*wavenumberCount,indexDensity)=-correlationFunctions(k)%twoHaloTerm(:,n)/correlationFunctions(k)%meanDensity(n)**2
          end if
       end do
       jacobianMatrix                     =jacobian
       covarianceMatrix                   =correlationFunctions(k)%termCovariance
       oneTwoHaloCovariance               =jacobianMatrix*(covarianceMatrix*jacobianMatrix%transpose())
       do n=1,massCount
          if (correlationFunctions(k)%meanDensity(n) > 0.0d0) then
             correlationFunctions(k)%oneHaloTerm(:,n)=correlationFunctions(k)%oneHaloTerm(:,n)/correlationFunctions(k)%meanDensity(n)**2
             correlationFunctions(k)%twoHaloTerm(:,n)=correlationFunctions(k)%twoHaloTerm(:,n)/correlationFunctions(k)%meanDensity(n)
          end if
       end do
       call deallocateArray(jacobian) 
       ! Square the two halo term, and multiply by the linear theory power spectrum.
       call allocateArray(jacobian            ,[massCount*(2*wavenumberCount),massCount*(2*wavenumberCount)])
       jacobian=0.0d0
       do n=1,massCount
          do i=1,wavenumberCount
             jacobian((n-1)*(2*wavenumberCount)                +i,(n-1)*(2*wavenumberCount)                +i)=+1.0d0
             jacobian((n-1)*(2*wavenumberCount)+wavenumberCount+i,(n-1)*(2*wavenumberCount)+wavenumberCount+i)=+2.0d0&
                  &                                                                                            *                     correlationFunctions(k)%twoHaloTerm       (i,n)     &
                  &                                                                                            *powerSpectrum_%power(correlationFunctions(k)%wavenumber        (i  ))    &
                  &                                                                                            *                     correlationFunctions(k)%linearGrowthFactor(  n) **2
          end do
       end do
       jacobianMatrix                        =jacobian
       covarianceMatrix                      =oneTwoHaloCovariance
       oneTwoHaloCovariance                  =jacobianMatrix*(covarianceMatrix*jacobianMatrix%transpose())
       do n=1,massCount
          do i=1,wavenumberCount
             correlationFunctions(k)%twoHaloTerm(i,n)=                      correlationFunctions(k)%twoHaloTerm       (i,n) **2 &
                  &                                   *powerSpectrum_%power(correlationFunctions(k)%wavenumber        (i  ))    &
                  &                                   *                     correlationFunctions(k)%linearGrowthFactor(  n) **2
          end do
       end do
       call deallocateArray(jacobian)
       ! Construct the final power spectra.
       call allocateArray(powerSpectrumValue     ,[          wavenumberCount,massCount                    ])
       call allocateArray(powerSpectrumCovariance,[massCount*wavenumberCount,massCount*   wavenumberCount ])
       call allocateArray(jacobian               ,[massCount*wavenumberCount,massCount*(2*wavenumberCount)])
       jacobian=0.0d0
       do n=1,massCount
          do i=1,wavenumberCount
             jacobian((n-1)*wavenumberCount+i,(n-1)*(2*wavenumberCount)                +i)=1.0d0
             jacobian((n-1)*wavenumberCount+i,(n-1)*(2*wavenumberCount)+wavenumberCount+i)=1.0d0
          end do
       end do
       jacobianMatrix                        =jacobian
       covarianceMatrix                      =oneTwoHaloCovariance
       powerSpectrumCovariance               =jacobianMatrix*(covarianceMatrix*jacobianMatrix%transpose())
       do n=1,massCount
          powerSpectrumValue(:,n)=correlationFunctions(k)%oneHaloTerm(:,n)+correlationFunctions(k)%twoHaloTerm(:,n)
       end do
       call deallocateArray(jacobian            )
       call deallocateArray(oneTwoHaloCovariance)
       ! Allocate correlation function and separation arrays.
       call allocateArray(correlation,shape(powerSpectrumValue))
       call allocateArray(separation ,[wavenumberCount])
       ! Fourier transform the power spectrum to get the correlation function.
       do n=1,massCount
          call FFTLog(                                    &
               &      correlationFunctions(k)%wavenumber, &
               &      separation                        , &
               &      +powerSpectrumValue(:,n)            &
               &      *correlationFunctions(k)%wavenumber &
               &      * 4.0d0*Pi                          &
               &      /(2.0d0*Pi)**3                    , &
               &      correlation(:,n)                  , &
               &      fftLogSine                        , &
               &      fftLogForward                       &
               &     )
          correlation(:,n)=correlation(:,n)/separation
       end do
       ! Compute the covariance of the correlation function.
       call allocateArray(covarianceTmp        ,[massCount*wavenumberCount,massCount*wavenumberCount])
       call allocateArray(correlationCovariance,[massCount*wavenumberCount,massCount*wavenumberCount])
       ! Apply wavenumber weighting to the power spectrum covariance.
       do n=1,massCount
          do m=1,massCount
             do i=1,wavenumberCount
                do j=1,wavenumberCount
                   powerSpectrumCovariance                   ((n-1)*wavenumberCount+i,(m-1)*wavenumberCount+j) &
                        & =powerSpectrumCovariance           ((n-1)*wavenumberCount+i,(m-1)*wavenumberCount+j) &
                        & *correlationFunctions(k)%wavenumber(                      i                        ) &
                        & *correlationFunctions(k)%wavenumber(                                              j) &
                        & *(                                                                                   &
                        &   + 4.0d0*Pi                                                                         &
                        &   /(2.0d0*Pi)**3                                                                     &
                        &  )**2
                end do
             end do
          end do
       end do
       ! Derive the covariance of the correlation function by first Fourier transforming each row of the power spectrum covariance
       ! matrix, and then Fourier transforming each column.
       do n=1,massCount
          do m=1,massCount
             do i=1,wavenumberCount
                call FFTlog(                                                                                            &
                     &      correlationFunctions(k)%wavenumber                                                        , &
                     &      separation                                                                                , &
                     &      powerSpectrumCovariance((n-1)*wavenumberCount+i,(m-1)*wavenumberCount+1:m*wavenumberCount), &
                     &      covarianceTmp          ((n-1)*wavenumberCount+i,(m-1)*wavenumberCount+1:m*wavenumberCount), &
                     &      fftLogSine                                                                                , &
                     &      fftLogForward                                                                               &
                     )
             end do
          end do
       end do
       do n=1,massCount
          do m=1,massCount
             do i=1,wavenumberCount
                call FFTlog(                                                                                            &
                     &      correlationFunctions(k)%wavenumber                                                        , &
                     &      separation                                                                                , &
                     &      covarianceTmp          ((n-1)*wavenumberCount+1:n*wavenumberCount,(m-1)*wavenumberCount+i), &
                     &      correlationCovariance  ((n-1)*wavenumberCount+1:n*wavenumberCount,(m-1)*wavenumberCount+i), &
                     &      fftLogSine                                                                                , &
                     &      fftLogForward                                                                               &
                     )
             end do
          end do
       end do
       do n=1,massCount
          do m=1,massCount
             do i=1,wavenumberCount
                do j=1,wavenumberCount
                   correlationCovariance        ((n-1)*wavenumberCount+i,(m-1)*wavenumberCount+j) &
                        & =correlationCovariance((n-1)*wavenumberCount+i,(m-1)*wavenumberCount+j) &
                        & /separation           (                      i                        ) &
                        & /separation           (                                              j)
                end do
             end do
          end do
       end do
       call deallocateArray(covarianceTmp)       
       ! Construct correlation table.
       call correlationTable%create(separation(1),separation(wavenumberCount),size(separation),extrapolationTypeExtrapolate)
       ! Project the correlation function.
       call allocateArray(jacobian                      ,[massCount*wavenumberCount,massCount*wavenumberCount])
       call allocateArray(projectedCorrelationCovariance,[massCount*wavenumberCount,massCount*wavenumberCount])
       call allocateArray(projectedCorrelation          ,[wavenumberCount,massCount                ])
       jacobian=0.0d0
       integrandWeightFunction => projectionIntegrandWeight
       do i=1,wavenumberCount
          projectedSeparation=correlationTable%x(i)
          jacobian(i,1:wavenumberCount)=correlationTable%integrationWeights(                                                   &
               &                                                            projectedSeparation                              , &
               &                                                            sqrt(                                              &
               &                                                                 +projectedSeparation                     **2  &
               &                                                                 +correlationFunctions(k)%lineOfSightDepth**2  &
               &                                                                )                                            , &
               &                                                            integrandWeightFunction                            &
               &                                                           )
          do n=1,massCount
             if (n > 1) jacobian((n-1)*wavenumberCount+i,(n-1)*wavenumberCount+1:n*wavenumberCount)=jacobian(i,1:wavenumberCount)
             projectedCorrelation(i,n)=sum(jacobian(i,1:wavenumberCount)*correlation(:,n))
          end do
       end do
       jacobianMatrix                =jacobian
       covarianceMatrix              =correlationCovariance
       projectedCorrelationCovariance=jacobianMatrix*(covarianceMatrix*jacobianMatrix%transpose())
       call deallocateArray(jacobian)
       ! If the integral was taken over the half range, 0<pi<pi_max, rather than the full range, -pi_max<pi<pi_max, then divide
       ! the projected correlation function by two.
       if (correlationFunctions(k)%descriptor%halfIntegral) then
          projectedCorrelation          =projectedCorrelation          /2.0d0
          projectedCorrelationCovariance=projectedCorrelationCovariance/2.0d0**2
       end if
       ! Integrate the projected correlation function over bins.
       call allocateArray(binnedProjectedCorrelation          ,[          size(correlationFunctions(k)%separation),massCount                                         ])
       call allocateArray(binnedProjectedCorrelationCovariance,[massCount*size(correlationFunctions(k)%separation),massCount*size(correlationFunctions(k)%separation)])
       call allocateArray(jacobian                            ,[massCount*size(correlationFunctions(k)%separation),massCount*wavenumberCount                         ])
       jacobian=0.0d0
       integrandWeightFunction => binningIntegrandWeight
       binWidthLogarithmic=log(correlationFunctions(k)%separation(2)/correlationFunctions(k)%separation(1))
       do i=1,size(correlationFunctions(k)%separation)      
          binSeparationMinimum         =correlationFunctions(k)%separation(i)*exp(-0.5d0*binWidthLogarithmic)
          binSeparationMaximum         =correlationFunctions(k)%separation(i)*exp(+0.5d0*binWidthLogarithmic)
          jacobian(i,1:wavenumberCount)=correlationTable%integrationWeights(                         &
               &                                                            binSeparationMinimum   , &
               &                                                            binSeparationMaximum   , &
               &                                                            integrandWeightFunction  &
               &                                                           )                         &
               &                        /Pi                                                          &
               &                        /(                                                           &
               &                          +binSeparationMaximum**2                                   &
               &                          -binSeparationMinimum**2                                   &
               &                         )
          do n=1,massCount
             if (n > 1) jacobian((n-1)*size(correlationFunctions(k)%separation)+i,(n-1)*wavenumberCount+1:n*wavenumberCount)=jacobian(i,1:wavenumberCount)
             binnedProjectedCorrelation(i,n)=sum(jacobian(i,1:wavenumberCount)*projectedCorrelation(:,n))
          end do
       end do
       jacobianMatrix                      =jacobian
       covarianceMatrix                    =projectedCorrelationCovariance
       binnedProjectedCorrelationCovariance=jacobianMatrix*(covarianceMatrix*jacobianMatrix%transpose())
       call deallocateArray(jacobian)
       call correlationTable%destroy()
       ! Apply the integral constraint.
       binnedProjectedCorrelation=binnedProjectedCorrelation/correlationFunctions(k)%integralConstraint
       ! Output the correlation function.
       !$ call hdf5Access%set()
       analysisGroup           =galacticusOutputFile%openGroup('analysis','Model analysis')
       correlationFunctionGroup=analysisGroup       %openGroup(trim(correlationFunctions(k)%descriptor%label),trim(correlationFunctions(k)%descriptor%comment))
       call correlationFunctionGroup%writeDataset  (correlationFunctions(k)%separation  ,'separation'                   ,'Separation'                      ,datasetReturned=dataset)
       call dataset             %writeAttribute(megaParsec                          ,'unitsInSI'                                                                                   )
       call dataset             %close         (                                                                                                                                   )
       call correlationFunctionGroup%writeDataset  (binnedProjectedCorrelation          ,'correlationFunction'          ,'Projected correlation'           ,datasetReturned=dataset)
       call dataset             %writeAttribute(megaParsec                          ,'unitsInSI'                                                                                   )
       call dataset             %close         (                                                                                                                                   )
       call correlationFunctionGroup%writeDataset  (binnedProjectedCorrelationCovariance,'correlationFunctionCovariance','Projected correlation covariance',datasetReturned=dataset)
       call dataset             %writeAttribute(megaParsec**2                       , 'unitsInSI'                                                                                  )
       call dataset             %close         (                                                                                                                                   )
       call correlationFunctionGroup%close         (                                                                                                                               )
       call analysisGroup           %close         (                                                                                                                               )
       !$ call hdf5Access%unset()
       call deallocateArray(binnedProjectedCorrelation          )
       call deallocateArray(binnedProjectedCorrelationCovariance)
    end do
    return
    
  contains

    double precision function projectionIntegrandWeight(separation)
      !% The weight function applied to the correlation function when integrating to get the projected correlation function.
      implicit none
      double precision, intent(in   ) :: separation
      
      if (separation > projectedSeparation) then
         projectionIntegrandWeight=2.0d0*separation/sqrt(separation**2-projectedSeparation**2)
      else
         projectionIntegrandWeight=0.0d0
      end if
      return
    end function projectionIntegrandWeight
    
    double precision function binningIntegrandWeight(separation)
      !% The weight function applied to the projected correlation function when integrating into bins.
      implicit none
      double precision, intent(in   ) :: separation

      binningIntegrandWeight=2.0d0*Pi*separation
      return
    end function binningIntegrandWeight

  end subroutine Galacticus_Output_Analysis_Correlation_Functions_Output

  subroutine Term_Indices(iMass,wavenumberCount,indexOneHalo,indexTwoHalo,indexDensity)
    !% Return the indices in the term covariances array at which one-halo, two-halo, and density terms are stored for the given mass.
    implicit none
    integer, intent(in   ) :: iMass       , wavenumberCount
    integer, intent(  out) :: indexOneHalo, indexTwoHalo   , indexDensity

    indexOneHalo=(iMass-1)*(2*wavenumberCount+1)                  +1
    indexTwoHalo=(iMass-1)*(2*wavenumberCount+1)+  wavenumberCount+1
    indexDensity=(iMass-1)*(2*wavenumberCount+1)+2*wavenumberCount+1
    return
  end subroutine Term_Indices

  subroutine validateDescriptors(descriptors)
    !% Perform some validation on correlation function descriptors to catch potential errors.
    use Galacticus_Error
    use ISO_Varying_String
    implicit none
    type     (correlationFunctionDescriptor), dimension(:), intent(in   ) :: descriptors
    type     (varying_string               )                              :: message
    character(len=8                        )                              :: label
    integer                                                               :: i
    
    do i=1,size(descriptors)
       if     (                                             &
            &   descriptors(i)%massSystematicLogM0 <  6.0d0 &
            &  .or.                                         &
            &   descriptors(i)%massSystematicLogM0 > 16.0d0 &
            & ) then
          write (label,'(f8.5)') descriptors(i)%massSystematicLogM0
          message="Error model mass zero-point ["//trim(adjustl(label))//"] for correlation function descriptor ["//trim(descriptors(i)%label)//"] is outside of plausible range"
          call Galacticus_Error_Report(message//{introspection:location})
       end if
    end do
    return
  end subroutine validateDescriptors
  
end module Galacticus_Output_Analyses_Correlation_Functions

