!! Copyright 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018,
!!           2019
!!    Andrew Benson <abenson@carnegiescience.edu>
!!
!! This file is part of Galacticus.
!!
!!    Galacticus is free software: you can redistribute it and/or modify
!!    it under the terms of the GNU General Public License as published by
!!    the Free Software Foundation, either version 3 of the License, or
!!    (at your option) any later version.
!!
!!    Galacticus is distributed in the hope that it will be useful,
!!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!!    GNU General Public License for more details.
!!
!!    You should have received a copy of the GNU General Public License
!!    along with Galacticus.  If not, see <http://www.gnu.org/licenses/>.

!% Contains a module which implements a star formation histories class which records \emph{in situ} star formation.

  use Output_Times, only : outputTimesClass, outputTimes

  !# <starFormationHistory name="starFormationHistoryInSitu">
  !#  <description>A star formation histories class which records \emph{in situ} star formation.</description>
  !# </starFormationHistory>
  type, extends(starFormationHistoryClass) :: starFormationHistoryInSitu
     !% A star formation histories class which records \emph{in situ} star formation.
     !@ <objectMethods>
     !@   <object>starFormationHistoryInSitu</object>
     !@   <objectMethod>
     !@     <method>make</method>
     !@     <arguments>\textcolor{red}{\textless type(history)\textgreater} historyStarFormation\arginout, \doublezero\ timeBegin\argin, \doublezero\ timeEnd\argin, \doubleone\ [timesCurrent]</arguments>
     !@     <type>\void</type>
     !@     <description>Make the star formation history.</description>
     !@   </objectMethod>
     !@ </objectMethods>
    private
     class           (outputTimesClass), pointer :: outputTimes_ => null()
     double precision                            :: timeStep              , timeStepFine, &
          &                                         timeFine
   contains
     final     ::             inSituDestructor
     procedure :: create   => inSituCreate
     procedure :: rate     => inSituRate
     procedure :: output   => inSituOutput
     procedure :: scales   => inSituScales
     procedure :: make     => inSituMake
     procedure :: autoHook => inSituAutoHook
  end type starFormationHistoryInSitu

  interface starFormationHistoryInSitu
     !% Constructors for the ``inSitu'' star formation history class.
     module procedure inSituConstructorParameters
     module procedure inSituConstructorInternal
  end interface starFormationHistoryInSitu

  ! Type used to store timestep range information.
  type inSituTimeStepRange
     private
     integer                                        :: count
     double precision                               :: timeBegin, timeEnd
     type            (inSituTimeStepRange), pointer :: next
  end type inSituTimeStepRange

contains

  function inSituConstructorParameters(parameters) result(self)
    !% Constructor for the ``inSitu'' star formation history class which takes a parameter set as input.
    use Input_Parameters, only : inputParameter, inputParameters
    implicit none
    type            (starFormationHistoryInSitu)                :: self
    type            (inputParameters           ), intent(inout) :: parameters
    class           (outputTimesClass          ), pointer       :: outputTimes_
    double precision                                            :: timeStep    , timeStepFine, &
         &                                                         timeFine
    
    !# <inputParameter>
    !#   <name>timeStep</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>0.1d0</defaultValue>
    !#   <description>The time step to use in tabulations of star formation histories [Gyr].</description>
    !#   <source>parameters</source>
    !#   <type>real</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>timeStepFine</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>0.01d0</defaultValue>
    !#   <description>The fine time step to use in tabulations of star formation histories [Gyr].</description>
    !#   <source>parameters</source>
    !#   <type>real</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>timeFine</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>0.1d0</defaultValue>
    !#   <description>The period prior to each output for which the fine time step is used in tabulations of star formation histories [Gyr].</description>
    !#   <source>parameters</source>
    !#   <type>real</type>
    !# </inputParameter>
    !# <objectBuilder class="outputTimes" name="outputTimes_" source="parameters"/>
    self=starFormationHistoryInSitu(timeStep,timeStepFine,timeFine,outputTimes_)
    !# <inputParametersValidate source="parameters"/>
    !# <objectDestructor name="outputTimes_"/>
    return
  end function inSituConstructorParameters

  function inSituConstructorInternal(timeStep,timeStepFine,timeFine,outputTimes_) result(self)
    !% Internal constructor for the ``inSitu'' star formation history class.
    implicit none
    type            (starFormationHistoryInSitu)                :: self
    double precision                            , intent(in   ) :: timeStep    , timeStepFine, &
         &                                                         timeFine
    class           (outputTimesClass          ), target        :: outputTimes_
    !# <constructorAssign variables="timeStep, timeStepFine, timeFine, *outputTimes_"/>
    
    return
  end function inSituConstructorInternal

  subroutine inSituAutoHook(self)
    !% Attach to the satellite merging event hook.
    use Events_Hooks, only : satelliteMergerEvent, openMPThreadBindingAllLevels
    implicit none
    class(starFormationHistoryInSitu), intent(inout) :: self

    call satelliteMergerEvent%attach(self,inSituSatelliteMerger,openMPThreadBindingAllLevels)
    return
  end subroutine inSituAutoHook
  
  subroutine inSituDestructor(self)
    !% Destructor for the {\normalfont \ttfamily inSitu} star formation histories class.
    implicit none
    type(starFormationHistoryInSitu), intent(inout) :: self
    
    !# <objectDestructor name="self%outputTimes_"/>
    return
  end subroutine inSituDestructor
  
  subroutine inSituCreate(self,node,historyStarFormation,timeBegin)
    !% Create the history required for storing star formation history.
    use Galacticus_Nodes, only : nodeComponentBasic
    implicit none
    class           (starFormationHistoryInSitu), intent(inout) :: self
    type            (treeNode                  ), intent(inout) :: node
    type            (history                   ), intent(inout) :: historyStarFormation
    double precision                            , intent(in   ) :: timeBegin
    class           (nodeComponentBasic        ), pointer       :: basic
    double precision                                            :: timeBeginActual     , timeEnd

    ! Find the start and end times for this history.
    basic           =>               node %basic()
    timeBeginActual =  min(timeBegin,basic%time ())
    timeEnd         =  self%outputTimes_%timeNext(timeBegin)
    call self%make(historyStarFormation,timeBeginActual,timeEnd)
    return
  end subroutine inSituCreate

  subroutine inSituRate(self,node,historyStarFormation,abundancesFuel,rateStarFormation)
    !% Set the rate the star formation history for {\normalfont \ttfamily node}.
    use Galacticus_Nodes, only : nodeComponentBasic
    use Arrays_Search   , only : Search_Array
    implicit none
    class           (starFormationHistoryInSitu), intent(inout) :: self
    type            (treeNode                  ), intent(inout) :: node
    type            (history                   ), intent(inout) :: historyStarFormation
    type            (abundances                ), intent(in   ) :: abundancesFuel
    double precision                            , intent(in   ) :: rateStarFormation
    class           (nodeComponentBasic        ), pointer       :: basic
    integer                                                     :: historyCount
    integer         (c_size_t                  )                :: iHistory
    double precision                                            :: timeNode
    !GCC$ attributes unused :: self, historyStarFormation, abundancesFuel

    basic                                 =>              node                %basic()
    timeNode                              =               basic               %time ()
    historyCount                          =          size(historyStarFormation%time            )
    iHistory                              =  Search_Array(historyStarFormation%time   ,timeNode)+1
    historyStarFormation%data(iHistory,:) =  rateStarFormation
    return
  end subroutine inSituRate

  subroutine inSituOutput(self,node,nodePassesFilter,historyStarFormation,indexOutput,indexTree,labelComponent)
    !% Output the star formation history for {\normalfont \ttfamily node}.
    use Galacticus_HDF5 , only : galacticusOutputFile
    use Galacticus_Nodes, only : nodeComponentBasic
    use String_Handling , only : operator(//)
    use IO_HDF5         , only : hdf5Access          , hdf5Object
    implicit none
    class           (starFormationHistoryInSitu), intent(inout)         :: self
    type            (treeNode                  ), intent(inout), target :: node
    logical                                     , intent(in   )         :: nodePassesFilter
    type            (history                   ), intent(inout)         :: historyStarFormation
    integer         (c_size_t                  ), intent(in   )         :: indexOutput
    integer         (kind=kind_int8            ), intent(in   )         :: indexTree
    character       (len=*                     ), intent(in   )         :: labelComponent
    class           (nodeComponentBasic        ), pointer               :: basicParent
    type            (treeNode                  ), pointer               :: nodeParent
    double precision                                                    :: timeBegin           , timeEnd
    type            (varying_string            )                        :: groupName
    type            (hdf5Object                )                        :: historyGroup        , outputGroup, &
         &                                                                 treeGroup
    type            (history                   )                        :: newHistory

    if (.not.historyStarFormation%exists()) return
    if (nodePassesFilter) then
       !$ call hdf5Access%set()
       historyGroup=galacticusOutputFile%openGroup("starFormationHistories","Star formation history data.")
       groupName   ="Output"
       groupName   =groupName//indexOutput
       outputGroup =historyGroup%openGroup(char(groupName),"Star formation histories for all trees at each output.")
       groupName   ="mergerTree"
       groupName   =groupName//indexTree
       treeGroup   =outputGroup %openGroup(char(groupName),"Star formation histories for each tree."               )
       groupName   =trim(labelComponent)//"Time"
       groupname   =groupName           //node%index()
       call treeGroup%writeDataset(historyStarFormation%time,char(groupName),"Star formation history times of the "         //trim(labelComponent)//" component.")
       groupName   =trim(labelComponent)//"SFH"
       groupname   =groupName//node%index()
       call treeGroup%writeDataset(historyStarFormation%data,char(groupName),"Star formation history stellar masses of the "//trim(labelComponent)//" component.")
       call treeGroup   %close()
       call outputGroup %close()
       call historyGroup%close()
       !$ call hdf5Access%unset()
    end if
    timeBegin=historyStarFormation%time(1)
    if (indexOutput < self%outputTimes_%count()) then
       timeEnd=self%outputTimes_%time(indexOutput+1)
    else
       nodeParent => node
       do while (associated(nodeParent%parent))
          nodeParent => nodeParent%parent
       end do
       basicParent => nodeParent %basic()
       timeEnd     =  basicParent%time ()
    end if
    call self%make(newHistory,timeBegin,timeEnd,historyStarFormation%time)
    newHistory%data(1:size(historyStarFormation%time),:)=historyStarFormation%data(:,:)
    call historyStarFormation%destroy()
    historyStarFormation=newHistory
    call newHistory%destroy(recordMemory=.false.)
    return
  end subroutine inSituOutput

  subroutine inSituScales(self,historyStarFormation,massStellar,abundancesStellar)
    !% Set the scalings for error control on the absolute values of star formation histories.
    use Memory_Management, only : deallocateArray
    implicit none
    class           (starFormationHistoryInSitu), intent(inout)               :: self
    double precision                            , intent(in   )               :: massStellar
    type            (abundances                ), intent(in   )               :: abundancesStellar
    type            (history                   ), intent(inout)               :: historyStarFormation
    double precision                            , allocatable  , dimension(:) :: timeSteps
    double precision                            , parameter                   :: massStellarMinimum  =1.0d0
    integer                                                                   :: i
    !GCC$ attributes unused :: self, abundancesStellar
    
    if (.not.historyStarFormation%exists()) return
    call historyStarFormation%timeSteps(timeSteps)
    forall(i=1:2)
       historyStarFormation%data(:,i)=max(massStellar,massStellarMinimum)/timeSteps
    end forall
    call deallocateArray(timeSteps)
    return
  end subroutine inSituScales

  subroutine inSituMake(self,historyStarFormation,timeBegin,timeEnd,timesCurrent)
    !% Create the history required for storing star formation history.
    use Numerical_Ranges, only : Make_Range             , rangeTypeLinear
    use Galacticus_Error, only : Galacticus_Error_Report
    implicit none
    class           (starFormationHistoryInSitu), intent(inout)                         :: self
    type            (history                   ), intent(inout)                         :: historyStarFormation
    double precision                            , intent(in   )                         :: timeBegin           , timeEnd
    double precision                            , intent(in   ), dimension(:), optional :: timesCurrent
    type            (inSituTimeStepRange       ), pointer                               :: timeStepFirst       , timeStepNext , &
         &                                                                                 timeStepCurrent
    integer                                                                             :: countTimeCoarse     , countTimeFine, &
         &                                                                                 countTime
    logical                                                                             :: timeStepFirstFound
    double precision                                                                    :: timeCoarseBegin     , timeCoarseEnd, &
         &                                                                                 timeFineBegin       , timeNext     , &
         &                                                                                 timeNow

    ! Exit with a null history if it would contain no time.
    if (timeEnd <= timeBegin) then
       call historyStarFormation%destroy()
       return
    end if
    ! If we have a set of times tabulated already, do some sanity checks.
    if (present(timesCurrent)) then
       ! Complain if the beginning time is before the given list of times.
       if (timeBegin < timesCurrent(1                 )) call Galacticus_Error_Report('requested begin time is before currently tabulated times'//{introspection:location})
       ! Complain if the end time is less than the maximum tabulated time.
       if (timeEnd   < timesCurrent(size(timesCurrent))) call Galacticus_Error_Report('requested end time is within currently tabulated times'  //{introspection:location})
    end if

    ! Step through time, creating a set of timesteps as needed.
    if (present(timesCurrent)) then
       timeNow         =  timesCurrent(size(timesCurrent))
    else
       timeNow         =  timeBegin
    end if
    countTime          =  0
    timeStepFirstFound =  .false.
    timeStepCurrent    => null()
    do while (timeNow < timeEnd)
       ! Get the time of the next output
       timeNext=self%outputTimes_%timeNext(timeNow)
       ! Unphysical (negative) value indicates no next output.
       if (timeNext < 0.0d0 .or. timeNext > timeEnd) timeNext=timeEnd
       ! Construct coarse and fine timesteps for this output, recording the parameters of each range.
       ! Determine the number of fine timestep bins required and the time at which we begin using fine timesteps.
       if (self%timeFine > 0.0d0) then
          countTimeFine  =int(min(timeNext-timeNow,self%timeFine)/self%timeStepFine)+1
          timeFineBegin  =timeNext-self%timeStepFine*dble(countTimeFine-1)
          timeCoarseBegin=timeNow      +self%timeStep
          timeCoarseEnd  =timeFineBegin-self%timeStepFine
       else
          countTimeFine  =0
          timeFineBegin  =timeNext
          timeCoarseBegin=timeNow      +self%timeStep
          timeCoarseEnd  =timeNext
       end if
       ! Determine the number of coarse time bins required for this history.
       if (timeCoarseEnd > timeCoarseBegin) then
          countTimeCoarse=max(int((timeCoarseEnd-timeCoarseBegin)/self%timeStep)+1,2)
       else if (countTimeFine == 0) then
          countTimeCoarse=2
          timeCoarseBegin=(timeCoarseEnd-timeNow)/3.0d0+timeNow
       else
          countTimeCoarse=0
       end if
       ! Create the time steps.
       if (timeStepFirstFound) then
          allocate(timeStepCurrent%next)
          timeStepCurrent => timeStepCurrent%next
       else
          allocate(timeStepFirst)
          timeStepCurrent => timeStepFirst
          if (countTimeCoarse > 0) then
             countTimeCoarse=countTimeCoarse+1
             timeCoarseBegin=max(timeCoarseBegin-self%timeStep    ,0.0d0)
          else
             countTimeFine  =countTimeFine  +1
             timeFineBegin  =max(timeFineBegin  -self%timeStepFine,0.0d0)
          end if
          timeStepFirstFound=.true.
       end if
       if (countTimeCoarse > 0) then
          timeStepCurrent%count    =  countTimeCoarse
          timeStepCurrent%timeBegin=  timeCoarseBegin
          timeStepCurrent%timeEnd  =  timeCoarseEnd
          allocate(timeStepCurrent%next)
          timeStepCurrent          => timeStepCurrent%next
       end if
       if (countTimeFine > 0) then
          timeStepCurrent%count    =  countTimeFine
          timeStepCurrent%timeBegin=  timeFineBegin
          timeStepCurrent%timeEnd  =  timeNext
       end if
       timeStepCurrent%next => null()
       ! Increment the total number of steps required.
       countTime=countTime+countTimeFine+countTimeCoarse
       ! Increment the time.
       timeNow=timeNext
    end do
    ! Shift the end point for the final step to the overall end time.
    if (timeStepFirstFound) timeStepCurrent%timeEnd=timeNext
    ! Copy in existing times if necessary.
    if (present(timesCurrent)) then
       countTime=countTime+size(timesCurrent)
       if (timeStepFirstFound) countTime=countTime-1
    end if
    call historyStarFormation%create(2,countTime)
    countTime=0
    if (present(timesCurrent)) then
       if (timeStepFirstFound) then
          historyStarFormation%time(countTime+1:countTime+size(timesCurrent)-1)=timesCurrent(1:size(timesCurrent)-1)
          countTime=size(timesCurrent)-1
       else
          historyStarFormation%time(countTime+1:countTime+size(timesCurrent)  )=timesCurrent(1:size(timesCurrent)  )
          countTime=size(timesCurrent)
       end if
    end if
    ! Create new times if necessary.
    if (timeStepFirstFound) then
       timeStepCurrent => timeStepFirst
       do while (associated(timeStepCurrent))
          ! Populate the time array.
          if      (timeStepCurrent%count == 1) then
             historyStarFormation%time(countTime+1                                )=                                     timeStepCurrent%timeEnd
          else if (timeStepCurrent%count >  1) then
             historyStarFormation%time(countTime+1:countTime+timeStepCurrent%count)=Make_Range(timeStepCurrent%timeBegin,timeStepCurrent%timeEnd,timeStepCurrent%count,rangeTypeLinear)
          end if
          countTime=countTime+timeStepCurrent%count
          ! Jump to the next time step.
          timeStepNext => timeStepCurrent%next
          deallocate(timeStepCurrent)
          timeStepCurrent => timeStepNext
       end do
    end if
    return
  end subroutine inSituMake

  subroutine inSituSatelliteMerger(self,node)
    !% Zero any in-situ star formation history for galaxy about to merge.
    use Galacticus_Nodes, only : nodeComponentDisk      , nodeComponentSpheroid
    use Galacticus_Error, only : Galacticus_Error_Report
    implicit none
    class(starFormationHistoryInSitu), intent(inout) :: self
    type (treeNode                  ), intent(inout) :: node
    class(nodeComponentDisk         ), pointer       :: disk
    class(nodeComponentSpheroid     ), pointer       :: spheroid
    type (history                   )                :: historyStarFormationDisk, historyStarFormationSpheroid

    select type (self)
    class is (starFormationHistoryInSitu)
       disk                                   => node    %disk                ()
       spheroid                               => node    %spheroid            ()
       historyStarFormationDisk               =  disk    %starFormationHistory()
       historyStarFormationSpheroid           =  spheroid%starFormationHistory()
       if (historyStarFormationDisk    %exists()) then
          historyStarFormationDisk    %data(:,1)=0.0d0
          call disk    %starFormationHistorySet(    historyStarFormationDisk)
       end if
       if (historyStarFormationSpheroid%exists()) then
          historyStarFormationSpheroid%data(:,1)=0.0d0
          call spheroid%starFormationHistorySet(historyStarFormationSpheroid)
       end if
    class default
       call Galacticus_Error_Report('incorrect class'//{introspection:location})
    end select
    return
  end subroutine inSituSatelliteMerger
    
