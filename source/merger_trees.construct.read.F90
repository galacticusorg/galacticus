!! Copyright 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018,
!!           2019
!!    Andrew Benson <abenson@carnegiescience.edu>
!!
!! This file is part of Galacticus.
!!
!!    Galacticus is free software: you can redistribute it and/or modify
!!    it under the terms of the GNU General Public License as published by
!!    the Free Software Foundation, either version 3 of the License, or
!!    (at your option) any later version.
!!
!!    Galacticus is distributed in the hope that it will be useful,
!!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!!    GNU General Public License for more details.
!!
!!    You should have received a copy of the GNU General Public License
!!    along with Galacticus.  If not, see <http://www.gnu.org/licenses/>.

  !% Implements a merger tree constructor class which constructs trees by reading their definitions from file.

  !$ use OMP_Lib                        , only : omp_lock_kind
  use Galacticus_Nodes                  , only : treeNode                    , nodeComponentBasic               , nodeComponentDarkMatterProfile
  use Dark_Matter_Profile_Scales        , only : darkMatterProfileScaleRadius, darkMatterProfileScaleRadiusClass
  use Cosmology_Functions
  use Merger_Tree_Read_Importers
  use Halo_Spin_Distributions
  use Dark_Matter_Halo_Scales
  use Dark_Matter_Profiles_DMO
  use Dark_Matter_Profiles_Concentration
  use Satellite_Merging_Timescales
  use Virial_Orbits
  use Kind_Numbers
  use MPI_Utilities
  use Output_Times
  
  !# <mergerTreeConstructor name="mergerTreeConstructorRead">
  !#  <description>Merger tree constructor class which builds merger trees assuming smooth accretion.</description>
  !# </mergerTreeConstructor>
  type, extends(mergerTreeConstructorClass) :: mergerTreeConstructorRead
     !% A class implementing merger tree construction by reading trees from file.
     private
     class           (cosmologyFunctionsClass            ), pointer                   :: cosmologyFunctions_                   => null()
     class           (mergerTreeImporterClass            ), pointer                   :: mergerTreeImporter_                   => null()
     class           (darkMatterProfileConcentrationClass), pointer                   :: darkMatterProfileConcentration_       => null()
     class           (satelliteMergingTimescalesClass    ), pointer                   :: satelliteMergingTimescales_           => null()
     class           (darkMatterHaloScaleClass           ), pointer                   :: darkMatterHaloScale_                  => null()
     class           (darkMatterProfileDMOClass          ), pointer                   :: darkMatterProfileDMO_                 => null()
     class           (haloSpinDistributionClass          ), pointer                   :: haloSpinDistribution_                 => null()
     class           (virialOrbitClass                   ), pointer                   :: virialOrbit_                          => null()
     class           (outputTimesClass                   ), pointer                   :: outputTimes_                          => null()
     class           (darkMatterProfileScaleRadiusClass  ), pointer                   :: darkMatterProfileScaleRadius_         => null()
     integer                                                                          :: fileCurrent
     type            (varying_string                     ), allocatable, dimension(:) :: fileNames                                      , presetNamedReals                    , &
          &                                                                              presetNamedIntegers
     integer                                              , allocatable, dimension(:) :: indexNamedReals                                , indexNamedIntegers
     logical                                                                          :: importerOpen
     integer         (kind_int8                          )                            :: beginAt
     double precision                                                                 :: treeWeightCurrent
     logical                                                                          :: allowBranchJumps
     logical                                                                          :: allowSubhaloPromotions
     integer         (c_size_t                           )                            :: forestSizeMaximum                              , treeNumberOffset
     logical                                                                          :: presetMergerTimes
     logical                                                                          :: presetMergerNodes
     logical                                                                          :: presetSubhaloMasses
     logical                                                                          :: presetSubhaloIndices
     logical                                                                          :: presetPositions
     logical                                                                          :: presetScaleRadii                               , scaleRadiiFailureIsFatal
     double precision                                                                 :: presetScaleRadiiMinimumMass                    , presetScaleRadiiConcentrationMinimum, &
          &                                                                              presetScaleRadiiConcentrationMaximum
     logical                                                                          :: presetSpins                                    , presetSpins3D                       , &
          &                                                                              presetUnphysicalSpins
     logical                                                                          :: presetOrbits                                   , presetOrbitsAssertAllSet            , & 
          &                                                                              presetOrbitsBoundOnly                          , presetOrbitsSetAll          
     integer                                                                          :: subhaloAngularMomentaMethod
     logical                                                                          :: missingHostsAreFatal
     logical                                                                          :: treeIndexToRootNodeIndex                                                       
     integer         (c_size_t                           )                            :: outputTimesCount                                                                             
     double precision                                                                 :: outputTimeSnapTolerance                                                        
     double precision                                     , allocatable, dimension(:) :: outputTimes
     integer         (c_size_t                           ), allocatable, dimension(:) :: descendentLocations                             , nodeLocations                             
     integer         (kind_int8                          ), allocatable, dimension(:) :: descendentIndicesSorted                         , nodeIndicesSorted                         
     !$ integer      (omp_lock_kind                      )                            :: splitForestLock
     integer                                                                          :: splitForestActiveForest
     integer         (c_size_t                           )                            :: splitForestNextTree                             , splitForestUniqueID
     integer         (c_size_t                           ), allocatable, dimension(:) :: splitForestTreeSize                             , splitForestTreeStart               , &
          &                                                                              splitForestMapIndex
     integer         (kind_int8                          ), allocatable, dimension(:) :: splitForestPushTo                               , splitForestPullFrom
     integer                                              , allocatable, dimension(:) :: splitForestPushType
     double precision                                     , allocatable, dimension(:) :: splitForestPushTime
     logical                                              , allocatable, dimension(:) :: splitForestIsPrimary                            , splitForestPushDone                , &
          &                                                                              splitForestPullDone
     logical                                                                          :: warningNestedHierarchyIssued
     logical                                                                          :: warningSplitForestNestedHierarchyIssued
     real                                                 , allocatable, dimension(:) :: timingTimes
     type            (varying_string                     ), allocatable, dimension(:) :: timingLabels
   contains
     !@ <objectMethods>
     !@   <object>mergerTreeConstructorRead</object>
     !@   <objectMethod>
     !@     <method>enforceSubhaloStatus</method>
     !@     <type>\void</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)(:)\textgreater} nodes\arginout</arguments>
     !@     <description>Ensure that any node which was once a subhalo remains a subhalo.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>scanForSubhaloPromotions</method>
     !@     <type>\void</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)(:)\textgreater} nodes\arginout, \textcolor{red}{\textless class(treeNodeList)(:)\textgreater} nodeList\arginout</arguments>
     !@     <description>Scan for cases where a subhalo stops being a subhalo and so must be promoted.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>createNodeIndices</method>
     !@     <type>\void</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)(:)\textgreater} nodes\arginout</arguments>
     !@     <description>Create a sorted list of node indices with an index into the original array.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>nodeLocation</method>
     !@     <type>\textcolor{red}{\textless integer(c\_size\_)\textgreater}</type>
     !@     <arguments>\textcolor{red}{\textless integer(kind\_int8)(:)\textgreater} nodeIndex\argin</arguments>
     !@     <description>Return the location in the original array of the given {\normalfont \ttfamily nodeIndex}.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>descendentNodeSortIndex</method>
     !@     <type>\textcolor{red}{\textless integer(c\_size\_)\textgreater}</type>
     !@     <arguments>\textcolor{red}{\textless integer(kind\_int8)(:)\textgreater} descendentIndex\argin</arguments>
     !@     <description> Return the sort index of the given {\normalfont \ttfamily descendentIndex}.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>destroyNodeIndices</method>
     !@     <type>\void</type>
     !@     <arguments></arguments>
     !@     <description>Destroy the sorted list of node indices.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>buildDescendentPointers</method>
     !@     <type>\void</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)(:)\textgreater} nodes\arginout</arguments>
     !@     <description>Builds pointers from each node to its descendent node.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>buildIsolatedParentPointers</method>
     !@     <type>\void</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)(:)\textgreater} nodes\arginout, \textcolor{red}{\textless class(treeNodeList)(:)\textgreater} nodeList\arginout</arguments>
     !@     <description>Create parent pointer links between isolated nodes and assign times and masses to those nodes.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>assignNamedProperties</method>
     !@     <type>\void</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)(:)\textgreater} nodes\arginout, \textcolor{red}{\textless class(treeNodeList)(:)\textgreater} nodeList\arginout</arguments>
     !@     <description>Assign named properties to nodes.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>assignScaleRadii</method>
     !@     <type>\void</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)(:)\textgreater} nodes\arginout, \textcolor{red}{\textless class(treeNodeList)(:)\textgreater} nodeList\arginout</arguments>
     !@     <description>Assign scale radii to nodes.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>scanForMergers</method>
     !@     <type>\void</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)(:)\textgreater} nodes\arginout, \textcolor{red}{\textless class(treeNodeList)(:)\textgreater} nodeList\arginout, \textcolor{red}{\textless integer(c\_size\_t)\textgreater} historyCountMaximum\argout</arguments>
     !@     <description>Scan for and record mergers between nodes.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>assignSpinParameters</method>
     !@     <type>\void</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)(:)\textgreater} nodes\arginout, \textcolor{red}{\textless class(treeNodeList)(:)\textgreater} nodeList\arginout</arguments>
     !@     <description>Assign spin parameters to nodes.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>assignMergers</method>
     !@     <type>\void</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)(:)\textgreater} nodes\arginout, \textcolor{red}{\textless class(treeNodeList)(:)\textgreater} nodeList\arginout</arguments>
     !@     <description>Assign pointers to merge targets.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>scanForBranchJumps</method>
     !@     <type>\void</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)(:)\textgreater} nodes\arginout, \textcolor{red}{\textless class(treeNodeList)(:)\textgreater} nodeList\arginout</arguments>
     !@     <description>Search for subhalos which move between branches/trees.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>buildSubhaloMassHistories</method>
     !@     <type>\void</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)(:)\textgreater} nodes\arginout, \textcolor{red}{\textless class(treeNodeList)(:)\textgreater} nodeList\arginout, \textcolor{red}{\textless integer(kind\_int8)(:)\textgreater} historyIndex\argin, \textcolor{red}{\textless integer(c\_size\_t)\textgreater} historyCountMaximum\argin, \doubleone\ historyMass\arginout, \doubleone\ hitoryTime\arginout, \doubletwo\ position\arginout, \doubletwo\ velocity\arginout</arguments>
     !@     <description>Build and attached bound mass histories to subhalos.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>timeUntilMergingSubresolution</method>
     !@     <type>\void</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)\textgreater} lastSeenNode\argin, \textcolor{red}{\textless class(nodeData)(:)\textgreater} nodes\arginout, \textcolor{red}{\textless class(treeNodeList)(:)\textgreater} nodeList\arginout, \intzero\ iNode\argin, \doublezero\ timeSubhaloMerges\arginout</arguments>
     !@     <description>Compute the additional time until merging after a subhalo is lost from the tree (presumably due to limited resolution).</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>phaseSpacePositionRealize</method>
     !@     <type>\void</type>
     !@     <arguments>\doublezero\ time\argin, \doubleone\ position\argin, \doubleone\ velocity\argin</arguments>
     !@     <description>Modify relative positions and velocities to account for both any periodicity of the simulated volume, and for Hubble flow.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>timingRecord</method>
     !@     <type>\void</type>
     !@     <arguments>\textcolor{red}{\textless character(len=*)\textgreater} label\argin</arguments>
     !@     <description>Record timing data.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>timingReport</method>
     !@     <type>\void</type>
     !@     <arguments></arguments>
     !@     <description>Report on time taken in various steps of processing merger trees read from file.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>rootNodeAffinitiesInitial</method>
     !@     <type>\void</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)(:)\textgreater} nodes\arginout</arguments>
     !@     <description>Find initial root node affinities for all nodes.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>isOnPushList</method>
     !@     <type>\logicalzero</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)\textgreater} node\argin</arguments>
     !@     <description>Return true if the given node is on the current ``push-to'' list of nodes for split forests.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>isOnPullList</method>
     !@     <type>\logicalzero</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)\textgreater} node\argin</arguments>
     !@     <description>Return true if the given node is on the current ``pull-from'' list of nodes for split forests.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>pushListIndex</method>
     !@     <type>\textcolor{red}{\textless integer(c\_size\_t)\textgreater}</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)\textgreater} node\argin</arguments>
     !@     <description>Return the index of the given node in the ``push-to'' list of nodes for split forests.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>pullListIndex</method>
     !@     <type>\textcolor{red}{\textless integer(c\_size\_t)\textgreater}</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)\textgreater} node\argin, \textcolor{red}{\textless integer(c\_size\_t)\textgreater} iPull\argin</arguments>
     !@     <description>Return the index of the given node in the ``pull-from'' list of nodes for split forests.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>pullListCount</method>
     !@     <type>\textcolor{red}{\textless integer(c\_size\_t)\textgreater}</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)\textgreater} node\argin</arguments>
     !@     <description>Return the number of the given node in the ``pull-from'' list of nodes for split forests.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>assignSplitForestEvents</method>
     !@     <type>\void</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)\textgreater} node\argin, \textcolor{red}{\textless class(treeNodeList)(:)\textgreater} nodeList\arginout</arguments>
     !@     <description>Assign events to nodes if they jump between trees in a forest.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>isSubhaloSubhaloMerger</method>
     !@     <type>\logicalzero</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)(:)\textgreater} nodes\argin, \textcolor{red}{\textless class(nodeData)\textgreater} node\argin</arguments>
     !@     <description>Returns true if {\normalfont \ttfamily node} undergoes a subhalo-subhalo merger.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>createNodeArray</method>
     !@     <type>\void</type>
     !@     <arguments>\textcolor{red}{\textless type(mergerTree)\textgreater} tree\arginout, \textcolor{red}{\textless class(nodeData)(:)\textgreater} nodes\argin, \textcolor{red}{\textless class(nodeData)\textgreater} node\argin, \intzero\ isolatedNodeCount\argout, \logicalone\ childIsSubhalo\arginout</arguments>
     !@     <description>Create an array of standard nodes and associated structures.</description>
     !@   </objectMethod>
     !@ </objectMethods>
     final     ::                                  readDestructor
     procedure :: construct                     => readConstruct
     procedure :: enforceSubhaloStatus          => readEnforceSubhaloStatus
     procedure :: scanForSubhaloPromotions      => readScanForSubhaloPromotions
     procedure :: createNodeIndices             => readCreateNodeIndices
     procedure :: nodeLocation                  => readNodeLocation
     procedure :: descendentNodeSortIndex       => readDescendentNodeSortIndex
     procedure :: destroyNodeIndices            => readDestroyNodeIndices
     procedure :: buildDescendentPointers       => readBuildDescendentPointers
     procedure :: buildIsolatedParentPointers   => readBuildIsolatedParentPointers
     procedure :: assignNamedProperties         => readAssignNamedProperties
     procedure :: assignScaleRadii              => readAssignScaleRadii
     procedure :: scanForMergers                => readScanForMergers
     procedure :: assignSpinParameters          => readAssignSpinParameters
     procedure :: assignMergers                 => readAssignMergers
     procedure :: scanForBranchJumps            => readScanForBranchJumps
     procedure :: buildSubhaloMassHistories     => readBuildSubhaloMassHistories
     procedure :: timeUntilMergingSubresolution => readTimeUntilMergingSubresolution
     procedure :: phaseSpacePositionRealize     => readPhaseSpacePositionRealize
     procedure :: timingRecord                  => readTimingRecord
     procedure :: timingReport                  => readTimingReport
     procedure :: rootNodeAffinitiesInitial     => readRootNodeAffinitiesInitial
     procedure :: isOnPushList                  => readIsOnPushList
     procedure :: isOnPullList                  => readIsOnPullList
     procedure :: pushListIndex                 => readPushListIndex
     procedure :: pullListIndex                 => readPullListIndex
     procedure :: pullListCount                 => readPullListCount
     procedure :: assignSplitForestEvents       => readAssignSplitForestEvents
     procedure :: isSubhaloSubhaloMerger        => readIsSubhaloSubhaloMerger
     procedure :: createNodeArray               => readCreateNodeArray
  end type mergerTreeConstructorRead

  interface mergerTreeConstructorRead
     !% Constructors for the {\normalfont \ttfamily read} merger tree constructor class.
     module procedure readConstructorParameters
     module procedure readConstructorInternal
  end interface mergerTreeConstructorRead

  ! Iterator object for iterating over progenitor nodes.
  type :: progenitorIterator
     integer(c_size_t                 )          :: progenitorLocation
     integer(kind_int8                )          :: progenitorIndex   , targetIndex 
     logical                                     :: progenitorsFound
     type   (mergerTreeConstructorRead), pointer :: constructor
   contains
     !@ <objectMethods>
     !@   <object>progenitorIterator</object>
     !@   <objectMethod>
     !@     <method>descendentSet</method>
     !@     <type>\void</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)\textgreater} node\argin, \textcolor{red}{\textless class(nodeData)(:)\textgreater} nodes\argin</arguments>
     !@     <description>Set the target descendent node and initialize the iterator.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>next</method>
     !@     <type>\logicalzero</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)(:)\textgreater} nodes\argin</arguments>
     !@     <description>Move to the next progenitor. Returns true if the next progenitor exists, false otherwise.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>index</method>
     !@     <type>\textcolor{red}{\textless integer(kind=kind\_int8)\textgreater}</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)(:)\textgreater} nodes\argin</arguments>
     !@     <description>Return the index of the current progenitor.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>current</method>
     !@     <type>\textcolor{red}{\textless *class(nodeData)\textgreater}</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)(:)\textgreater} nodes\argin</arguments>
     !@     <description>Return a pointer to the current progenitor.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>exist</method>
     !@     <type>\logicalzero</type>
     !@     <arguments></arguments>
     !@     <description>Return true if any progenitors exist, false otherwise.</description>
     !@   </objectMethod>
     !@ </objectMethods>
     procedure :: descendentSet => progenitorIteratorDescendentSet 
     procedure :: next          => progenitorIteratorNext          
     procedure :: index         => progenitorIteratorIndex         
     procedure :: current       => progenitorIteratorCurrent       
     procedure :: exist         => progenitorIteratorExist         
  end type progenitorIterator

  ! Enumeration of cross-tree event types.
  !# <enumeration>
  !#  <name>pushType</name>
  !#  <description>Cross-tree event type enumeration.</description>
  !#  <entry label="branchJump"      />
  !#  <entry label="subhaloPromotion"/>
  !# </enumeration>

  ! Enumeration of node reachability status.
  !# <enumeration>
  !#  <name>readNodeReachability</name>
  !#  <description>Node reachability status.</description>
  !#  <entry label="unreachable"/>
  !#  <entry label="reachable"  />
  !# </enumeration>

  ! Enumeration of subhalo angular momentum methods.
  !# <enumeration>
  !#  <name>readSubhaloAngularMomentaMethod</name>
  !#  <description>Subhalo angular momentum methods.</description>
  !#  <encodeFunction>yes</encodeFunction>
  !#  <entry label="scale"    />
  !#  <entry label="summation"/>
  !# </enumeration>

  ! Variables used in root-finding.
  class           (nodeComponentDarkMatterProfile     ), pointer :: readDarkMatterProfile                                                             
  class           (nodeComponentBasic                 ), pointer :: readBasic                                                                         
  type            (treeNode                           ), pointer :: readNode                                                                                   
  double precision                                               :: readRadiusHalfMass                                                                                               
  class(mergerTreeConstructorRead), pointer :: readSelf
  !$omp threadprivate(readDarkMatterProfile,readBasic,readNode,readRadiusHalfMass,readSelf)

  ! Counter used to assign unique IDs to split forests.
  type(mpiCounter) :: readSplitForestUniqueID

contains

  function readConstructorParameters(parameters) result(self)
    !% Constructor for the {\normalfont \ttfamily read} merger tree constructor class which takes a parameter set as input.
    use Input_Parameters
    implicit none
    type            (mergerTreeConstructorRead          )                            :: self
    type            (inputParameters                    ), intent(inout)             :: parameters
    class           (cosmologyFunctionsClass            ), pointer                   :: cosmologyFunctions_                                                                              
    class           (mergerTreeImporterClass            ), pointer                   :: mergerTreeImporter_                                                                              
    class           (darkMatterProfileConcentrationClass), pointer                   :: darkMatterProfileConcentration_
    class           (satelliteMergingTimescalesClass    ), pointer                   :: satelliteMergingTimescales_
    class           (darkMatterHaloScaleClass           ), pointer                   :: darkMatterHaloScale_
    class           (darkMatterProfileDMOClass          ), pointer                   :: darkMatterProfileDMO_
    class           (haloSpinDistributionClass          ), pointer                   :: haloSpinDistribution_
    class           (virialOrbitClass                   ), pointer                   :: virialOrbit_
    class           (outputTimesClass                   ), pointer                   :: outputTimes_
    class           (darkMatterProfileScaleRadiusClass  ), pointer                   :: darkMatterProfileScaleRadius_
    type            (varying_string                     ), allocatable, dimension(:) :: fileNames                           , presetNamedReals                    , &
         &                                                                              presetNamedIntegers
    integer                                                                          :: fileCount
    integer         (c_size_t                           )                            :: forestSizeMaximum
    integer         (kind_int8                          )                            :: beginAt
    logical                                                                          :: missingHostsAreFatal                , presetMergerTimes                   , &
         &                                                                              presetMergerNodes                   , presetSubhaloMasses                 , &
         &                                                                              presetSubhaloIndices                , presetPositions                     , &
         &                                                                              presetScaleRadii                    , scaleRadiiFailureIsFatal            , &
         &                                                                              presetUnphysicalSpins               , presetSpins                         , &
         &                                                                              presetSpins3D                       , presetOrbits                        , &
         &                                                                              presetOrbitsSetAll                  , presetOrbitsAssertAllSet            , &
         &                                                                              presetOrbitsBoundOnly               , allowSubhaloPromotions              , &
         &                                                                              treeIndexToRootNodeIndex            , allowBranchJumps
    type            (varying_string                     )                            :: subhaloAngularMomentaMethodText
    double precision                                                                 :: presetScaleRadiiConcentrationMinimum, presetScaleRadiiConcentrationMaximum, &
         &                                                                              presetScaleRadiiMinimumMass         , outputTimeSnapTolerance

    fileCount=parameters%count('fileNames')
    allocate(fileNames(fileCount))
    !# <inputParameter>
    !#   <name>fileNames</name>
    !#   <description>The name of the file(s) from which merger tree data should be read when using the {\normalfont \ttfamily [mergerTreeConstructMethod]}$=${\normalfont \ttfamily read} tree construction method.</description>
    !#   <source>parameters</source>
    !#   <type>string</type>
    !#   <cardinality>1..</cardinality>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>forestSizeMaximum</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>0_c_size_t</defaultValue>
    !#   <description>The maximum number of nodes allowed in a forest before it will be broken up into trees and processed individually. A value of 0 implies that forests should never be split.</description>
    !#   <source>parameters</source>
    !#   <type>integer</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>presetMergerTimes</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>.true.</defaultValue>
    !#   <description>Specifies whether merging times for subhalos should be preset when reading merger trees from a file.</description>
    !#   <source>parameters</source>
    !#   <type>boolean</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>presetMergerNodes</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>.true.</defaultValue>
    !#   <description>Specifies whether the target nodes for mergers should be preset (i.e. determined from descendent nodes). If they are not, merging will be with each satellite's host node.</description>
    !#   <source>parameters</source>
    !#   <type>boolean</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>presetSubhaloMasses</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>.true.</defaultValue>
    !#   <description>Specifies whether subhalo mass should be preset when reading merger trees from a file.</description>
    !#   <source>parameters</source>
    !#   <type>boolean</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>subhaloAngularMomentaMethod</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>var_str('summation')</defaultValue>
    !#   <description>Specifies how to account for subhalo angular momentum when adding subhalo mass to host halo mass.</description>
    !#   <source>parameters</source>
    !#   <type>boolean</type>
    !#   <variable>subhaloAngularMomentaMethodText</variable>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>presetSubhaloIndices</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>.true.</defaultValue>
    !#   <description>Specifies whether subhalo indices should be preset when reading merger trees from a file.</description>
    !#   <source>parameters</source>
    !#   <type>boolean</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>presetPositions</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>.true.</defaultValue>
    !#   <description>Specifies whether node positions should be preset when reading merger trees from a file.</description>
    !#   <source>parameters</source>
    !#   <type>boolean</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>presetScaleRadii</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>.true.</defaultValue>
    !#   <description>Specifies whether node scale radii should be preset when reading merger trees from a file.</description>
    !#   <source>parameters</source>
    !#   <type>boolean</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>scaleRadiiFailureIsFatal</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>.true.</defaultValue>
    !#   <description>Specifies whether failure to set a node scale radii should be regarded as a fatal error. (If not, a fallback method to set scale radius is used in such cases.)</description>
    !#   <source>parameters</source>
    !#   <type>boolean</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>presetScaleRadiiConcentrationMinimum</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>3.0d0</defaultValue>
    !#   <description>The lowest concentration ($c=r_\mathrm{vir}/r_\mathrm{s}$) allowed when setting scale radii, $r_\mathrm{s}$.</description>
    !#   <source>parameters</source>
    !#   <type>boolean</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>presetScaleRadiiConcentrationMaximum</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>60.0d0</defaultValue>
    !#   <description>The largest concentration ($c=r_\mathrm{vir}/r_\mathrm{s}$) allowed when setting scale radii, $r_\mathrm{s}$.</description>
    !#   <source>parameters</source>
    !#   <type>boolean</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>presetScaleRadiiMinimumMass</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>0.0d0</defaultValue>
    !#   <description>The minimum halo mass for which scale radii should be preset (if {\normalfont \ttfamily [presetScaleRadii]}$=${\normalfont \ttfamily true}).</description>
    !#   <source>parameters</source>
    !#   <type>boolean</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>presetUnphysicalSpins</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>.false.</defaultValue>
    !#   <description>When reading merger trees from file and presetting halo spins, detect unphysical (&lt;=0) spins and preset them using the selected halo spin method.</description>
    !#   <source>parameters</source>
    !#   <type>boolean</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>presetSpins</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>.true.</defaultValue>
    !#   <description>Specifies whether node spins should be preset when reading merger trees from a file.</description>
    !#   <source>parameters</source>
    !#   <type>boolean</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>presetSpins3D</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>.false.</defaultValue>
    !#   <description>Specifies whether node 3-D spin vectors should be preset when reading merger trees from a file.</description>
    !#   <source>parameters</source>
    !#   <type>boolean</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>presetOrbits</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>.true.</defaultValue>
    !#   <description>Specifies whether node orbits should be preset when reading merger trees from a file.</description>
    !#   <source>parameters</source>
    !#   <type>boolean</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>presetOrbitsSetAll</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>.true.</defaultValue>
    !#   <description>Forces all orbits to be set. If the computed orbit does not cross the virial radius, then select one at random instead.</description>
    !#   <source>parameters</source>
    !#   <type>boolean</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>presetOrbitsAssertAllSet</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>.true.</defaultValue>
    !#   <description>Asserts that all virial orbits must be preset. If any can not be set, \glc\ will stop.</description>
    !#   <source>parameters</source>
    !#   <type>boolean</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>presetOrbitsBoundOnly</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>.true.</defaultValue>
    !#   <description>Specifies whether only bound node orbits should be set.</description>
    !#   <source>parameters</source>
    !#   <type>boolean</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>beginAt</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>-1_kind_int8</defaultValue>
    !#   <description>Specifies the index of the tree to begin at. (Use -1 to always begin with the first tree.)</description>
    !#   <source>parameters</source>
    !#   <type>integer</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>outputTimeSnapTolerance</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>0.0d0</defaultValue>
    !#   <description>The relative tolerance required to ``snap'' a node time to the closest output time.</description>
    !#   <source>parameters</source>
    !#   <type>real</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>missingHostsAreFatal</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>.true.</defaultValue>
    !#   <description>Specifies whether nodes with missing host nodes should be considered to be fatal---see \S\ref{sec:MergerTreeFileProcessing}.</description>
    !#   <source>parameters</source>
    !#   <type>boolean</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>treeIndexToRootNodeIndex</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>.false.</defaultValue>
    !#   <description>Specifies whether tree indices should always be set to the index of their root node.</description>
    !#   <source>parameters</source>
    !#   <type>boolean</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>allowBranchJumps</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>.true.</defaultValue>
    !#   <description>Specifies whether nodes are allowed to jump between branches.</description>
    !#   <source>parameters</source>
    !#   <type>boolean</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>allowSubhaloPromotions</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>.true.</defaultValue>
    !#   <description>Specifies whether subhalos are permitted to be promoted to being isolated halos.</description>
    !#   <source>parameters</source>
    !#   <type>boolean</type>
    !# </inputParameter>
    allocate(presetNamedReals   (parameters%count('presetNamedReals'   ,zeroIfNotPresent=.true.)))
    if (size(presetNamedReals   ) > 0) then
       !# <inputParameter>
       !#   <name>presetNamedReals</name>
       !#   <description>Names of real datasets to be additionally read and stored in the nodes of the merger tree when using the {\normalfont \ttfamily [mergerTreeConstructMethod]}$=${\normalfont \ttfamily read} tree construction method.</description>
       !#   <source>parameters</source>
       !#   <type>string</type>
       !#   <cardinality>1..</cardinality>
       !# </inputParameter>
    end if
    allocate(presetNamedIntegers(parameters%count('presetNamedIntegers',zeroIfNotPresent=.true.)))
    if (size(presetNamedIntegers) > 0) then
       !# <inputParameter>
       !#   <name>presetNamedIntegers</name>
       !#   <description>Names of integer datasets to be additionally read and stored in the nodes of the merger tree when using the {\normalfont \ttfamily [mergerTreeConstructMethod]}$=${\normalfont \ttfamily read} tree construction method.</description>
       !#   <source>parameters</source>
       !#   <type>string</type>
       !#   <cardinality>1..</cardinality>
       !# </inputParameter>
    end if
    !# <objectBuilder class="cosmologyFunctions"             name="cosmologyFunctions_"             source="parameters"                                                                                  />
    !# <objectBuilder class="mergerTreeImporter"             name="mergerTreeImporter_"             source="parameters"                                                                                  />
    !# <objectBuilder class="darkMatterHaloScale"            name="darkMatterHaloScale_"            source="parameters"                                                                                  />
    !# <objectBuilder class="darkMatterProfileDMO"           name="darkMatterProfileDMO_"           source="parameters"                                                                                  />
    !# <objectBuilder class="darkMatterProfileConcentration" name="darkMatterProfileConcentration_" source="parameters"                                                                                  />
    !# <objectBuilder class="haloSpinDistribution"           name="haloSpinDistribution_"           source="parameters"                                                                                  />
    !# <objectBuilder class="virialOrbit"                    name="virialOrbit_"                    source="parameters"                                                                                  />    
    !# <objectBuilder class="outputTimes"                    name="outputTimes_"                    source="parameters"                                                                                  />
    !# <objectBuilder class="darkMatterProfileScaleRadius"   name="darkMatterProfileScaleRadius_"   source="parameters"                                                                                  />
    !# <objectBuilder class="satelliteMergingTimescales"     name="satelliteMergingTimescales_"     source="parameters" parameterName="satelliteMergingTimescalesSubresolutionMethod" threadPrivate="yes" >
    !#  <default>
    !#   <satelliteMergingTimescalesSubresolutionMethod value="zero"/>
    !#  </default>
    !# </objectBuilder>
    self=mergerTreeConstructorRead(                                                                                                                     &
         &                                                                               fileNames                                                    , &
         &                                                                               outputTimeSnapTolerance                                      , &
         &                                                                               forestSizeMaximum                                            , &
         &                                                                               beginAt                                                      , &
         &                                                                               missingHostsAreFatal                                         , &
         &                                                                               treeIndexToRootNodeIndex                                     , &
         &                         enumerationReadSubhaloAngularMomentaMethodEncode(char(subhaloAngularMomentaMethodText     ),includesPrefix=.false.), &
         &                                                                               allowBranchJumps                                             , &
         &                                                                               allowSubhaloPromotions                                       , &
         &                                                                               presetMergerTimes                                            , &
         &                                                                               presetMergerNodes                                            , &
         &                                                                               presetSubhaloMasses                                          , &
         &                                                                               presetSubhaloIndices                                         , &
         &                                                                               presetPositions                                              , &
         &                                                                               presetScaleRadii                                             , &
         &                                                                               presetScaleRadiiConcentrationMinimum                         , &
         &                                                                               presetScaleRadiiConcentrationMaximum                         , &
         &                                                                               presetScaleRadiiMinimumMass                                  , &
         &                                                                               scaleRadiiFailureIsFatal                                     , &
         &                                                                               presetUnphysicalSpins                                        , &
         &                                                                               presetSpins                                                  , &
         &                                                                               presetSpins3D                                                , &
         &                                                                               presetOrbits                                                 , &
         &                                                                               presetOrbitsSetAll                                           , &
         &                                                                               presetOrbitsAssertAllSet                                     , &
         &                                                                               presetOrbitsBoundOnly                                        , &
         &                                                                               presetNamedReals                                             , &
         &                                                                               presetNamedIntegers                                          , &
         &                                                                               cosmologyFunctions_                                          , &
         &                                                                               mergerTreeImporter_                                          , &
         &                                                                               darkMatterHaloScale_                                         , &
         &                                                                               darkMatterProfileDMO_                                        , &
         &                                                                               darkMatterProfileConcentration_                              , &
         &                                                                               haloSpinDistribution_                                        , &
         &                                                                               satelliteMergingTimescales_                                  , &
         &                                                                               virialOrbit_                                                 , &
         &                                                                               outputTimes_                                                 , &
         &                                                                               darkMatterProfileScaleRadius_                                  &
         &                        )
    !# <inputParametersValidate source="parameters"/>
    !# <objectDestructor name="cosmologyFunctions_"            />
    !# <objectDestructor name="mergerTreeImporter_"            />
    !# <objectDestructor name="darkMatterHaloScale_"           />
    !# <objectDestructor name="darkMatterProfileDMO_"          />
    !# <objectDestructor name="darkMatterProfileConcentration_"/>
    !# <objectDestructor name="haloSpinDistribution_"          />
    !# <objectDestructor name="virialOrbit_"                   />
    !# <objectDestructor name="outputTimes_"                   />
    !# <objectDestructor name="darkMatterProfileScaleRadius_"  />
    !# <objectDestructor name="satelliteMergingTimescales_"    />
    return
  end function readConstructorParameters

  function readConstructorInternal(fileNames,outputTimeSnapTolerance,forestSizeMaximum,beginAt,missingHostsAreFatal,treeIndexToRootNodeIndex,subhaloAngularMomentaMethod,allowBranchJumps,allowSubhaloPromotions,presetMergerTimes,presetMergerNodes,presetSubhaloMasses,presetSubhaloIndices,presetPositions,presetScaleRadii,presetScaleRadiiConcentrationMinimum,presetScaleRadiiConcentrationMaximum,presetScaleRadiiMinimumMass,scaleRadiiFailureIsFatal,presetUnphysicalSpins,presetSpins,presetSpins3D,presetOrbits,presetOrbitsSetAll,presetOrbitsAssertAllSet,presetOrbitsBoundOnly,presetNamedReals,presetNamedIntegers,cosmologyFunctions_,mergerTreeImporter_,darkMatterHaloScale_,darkMatterProfileDMO_,darkMatterProfileConcentration_,haloSpinDistribution_,satelliteMergingTimescales_,virialOrbit_,outputTimes_,darkMatterProfileScaleRadius_) result(self)
    !% Internal constructor for the {\normalfont \ttfamily read} merger tree constructor class.
    !$ use OMP_Lib                      , only : OMP_Init_Lock
    use Galacticus_Nodes                , only : defaultNBodyComponent, nodeComponentNBodyGeneric
    use Galacticus_Error
    use Galacticus_Display
    use Numerical_Constants_Astronomical
    use Numerical_Constants_Boolean
    use Memory_Management
    implicit none
    type            (mergerTreeConstructorRead          )                              :: self
    class           (cosmologyFunctionsClass            ), intent(in   ), target       :: cosmologyFunctions_                                                                              
    class           (mergerTreeImporterClass            ), intent(in   ), target       :: mergerTreeImporter_                                                                              
    class           (darkMatterHaloScaleClass           ), intent(in   ), target       :: darkMatterHaloScale_
    class           (darkMatterProfileDMOClass          ), intent(in   ), target       :: darkMatterProfileDMO_
    class           (darkMatterProfileConcentrationClass), intent(in   ), target       :: darkMatterProfileConcentration_
    class           (haloSpinDistributionClass          ), intent(in   ), target       :: haloSpinDistribution_
    class           (satelliteMergingTimescalesClass    ), intent(in   ), target       :: satelliteMergingTimescales_
    class           (virialOrbitClass                   ), intent(in   ), target       :: virialOrbit_
    class           (outputTimesClass                   ), intent(in   ), target       :: outputTimes_
    class           (darkMatterProfileScaleRadiusClass  ), intent(in   ), target       :: darkMatterProfileScaleRadius_
    type            (varying_string                     ), intent(in   ), dimension(:) :: fileNames                           , presetNamedReals                    , &
         &                                                                                presetNamedIntegers
    integer         (c_size_t                           ), intent(in   )               :: forestSizeMaximum
    integer         (kind_int8                          ), intent(in   )               :: beginAt
    logical                                              , intent(in   )               :: missingHostsAreFatal                , presetMergerTimes                   , &
         &                                                                                presetMergerNodes                   , presetSubhaloMasses                 , &
         &                                                                                presetSubhaloIndices                , presetPositions                     , &
         &                                                                                presetScaleRadii                    , scaleRadiiFailureIsFatal            , &
         &                                                                                presetUnphysicalSpins               , presetSpins                         , &
         &                                                                                presetSpins3D                       , presetOrbits                        , &
         &                                                                                presetOrbitsSetAll                  , presetOrbitsAssertAllSet            , &
         &                                                                                presetOrbitsBoundOnly               , allowSubhaloPromotions              , &
         &                                                                                treeIndexToRootNodeIndex            , allowBranchJumps
    integer                                              , intent(in   )               :: subhaloAngularMomentaMethod
    double precision                                     , intent(in   )               :: presetScaleRadiiConcentrationMinimum, presetScaleRadiiConcentrationMaximum, &
         &                                                                                presetScaleRadiiMinimumMass         , outputTimeSnapTolerance
    integer         (c_size_t                           )                              :: iOutput                             , i
    type            (varying_string                     )                              :: message
    !# <constructorAssign variables="fileNames, outputTimeSnapTolerance, forestSizeMaximum, beginAt, missingHostsAreFatal, treeIndexToRootNodeIndex, subhaloAngularMomentaMethod, allowBranchJumps, allowSubhaloPromotions, presetMergerTimes, presetMergerNodes, presetSubhaloMasses, presetSubhaloIndices, presetPositions, presetScaleRadii,  presetScaleRadiiConcentrationMinimum, presetScaleRadiiConcentrationMaximum, presetScaleRadiiMinimumMass, scaleRadiiFailureIsFatal, presetUnphysicalSpins, presetSpins, presetSpins3D, presetOrbits, presetOrbitsSetAll, presetOrbitsAssertAllSet, presetOrbitsBoundOnly, presetNamedReals, presetNamedIntegers, *cosmologyFunctions_, *mergerTreeImporter_, *darkMatterHaloScale_, *darkMatterProfileDMO_, *darkMatterProfileConcentration_, *haloSpinDistribution_, *satelliteMergingTimescales_, *virialOrbit_, *outputTimes_, *darkMatterProfileScaleRadius_"/>

    ! Initialize statuses.
    self%warningNestedHierarchyIssued           =.false.                                            
    self%warningSplitForestNestedHierarchyIssued=.false.
    ! Initialize split forests counter.
    readSplitForestUniqueID=mpiCounter()
    ! Get array of output times.
    self%outputTimesCount=self%outputTimes_%count()
    call allocateArray(self%outputTimes,[self%outputTimesCount])
    do iOutput=1,self%outputTimesCount
       self%outputTimes(iOutput)=self%outputTimes_%time(iOutput)
    end do
    ! Open the file.
    self%treeNumberOffset=0_c_size_t
    self%fileCurrent     =1
    self%importerOpen    =.true.
    call self%mergerTreeImporter_%open(self%fileNames(self%fileCurrent))
    ! Validate input parameters.
    if (self%presetMergerNodes.and..not.self%presetMergerTimes) then
       message="presetting of merger target nodes requires that merger times also be preset;"//char(10)
       message=message//" try setting [presetMergerTimes]=true."//char(10)
       if (self%mergerTreeImporter_%treesHaveSubhalos() /= booleanTrue) then
          message=message//" Note: presetting merger target nodes and merger times is usually only a good idea when subhalo information is present in the merger trees"
          if (self%mergerTreeImporter_%treesHaveSubhalos() == booleanFalse) then
             message=message//" (which the current trees do not)"
          else
             message=message//" (subhalo presence in the current trees was not specified)"
          end if
       end if
       call Galacticus_Error_Report(message//{introspection:location})
    end if
    ! Warn about lack of branch jumps and subhalo promotions if split forests are being used.
    if (self%forestSizeMaximum > 0_c_size_t .and. .not.(self%allowBranchJumps .and. self%allowSubhaloPromotions)) then
       message='WARNING: large forests may be split for processing but '
       if (                                     .not.self%allowBranchJumps) message=message//' branch jumps'
       if (.not.self%allowSubhaloPromotions.and..not.self%allowBranchJumps) message=message//' and'
       if (.not.self%allowSubhaloPromotions                               ) message=message//' subhalo promotions'          
       message=message//' are not allowed - this can result in inconsistent treatment between split and unsplit forest processing'
       call Galacticus_Warn(message)
    end if
    ! Warn if subhalo promotions are allowed, but branch jumps are not.
    if (self%allowSubhaloPromotions.and..not.self%allowBranchJumps) then
       message='WARNING: allowing subhalo promotions while not allowing branch jumps can lead to deadlocking of trees.'//char(10)
       message=message//'Be sure that your trees have no promotion events for subhalos which survive beyond the end of their original branch'//char(10)
       message=message//'For example, without branch jumping, "a" in the following tree (in which "==>" indicates subhalo host) is stuck in "1", so it cannot evolve to become "b" causing the subhalo promotion "b" to "c" to be unreachable, resulting in a deadlock of the tree:'//char(10)//char(10)
       message=message//' ---   -----'//char(10)
       message=message//' |a|==>| 1 |'//char(10)
       message=message//' ---   -----'//char(10)
       message=message//'  |         '//char(10)
       message=message//' ---   -----'//char(10)
       message=message//' |b|==>| 2 |'//char(10)
       message=message//' ---   -----'//char(10)
       message=message//'  |      |  '//char(10)
       message=message//' ---   -----'//char(10)
       message=message//' |c|   | 3 |'//char(10)
       message=message//' ---   -----'//{introspection:location}//char(10)
       call Galacticus_Warn(message)
    end if
    ! Warn if subhalo promotions are allowed, but branch jumps are not.
    if (self%allowBranchJumps.and..not.self%presetMergerTimes) then
       message='WARNING: allowing branch jumps while not presetting merger times can lead to tree deadlock if merging occurs prior to the jumped-to node time and before an output time which blocks the jumped-to node''s child.'//char(10)
       message=message//'For example, "a" in the following tree (in which "<==" indicates subhalo host) jump from "3" to "1", but cannot merge with "1" since "1" still has a child, and that child, "2", cannot reach one because it is blocked by the output time, resulting in a deadlock of the tree:'//char(10)//char(10)
       message=message//' ---           ---'//char(10)
       message=message//' |1|<==========|a|'//char(10)
       message=message//' ---           ---'//char(10)
       message=message//'  ^             | '//char(10)
       message=message//'  |             | '//char(10)
       message=message//' ~~~output time~~~'//char(10)
       message=message//'  |             | '//char(10)
       message=message//' ~~~merge  time~~~'//char(10)
       message=message//'  |             | '//char(10)
       message=message//' ---     ---   ---'//char(10)
       message=message//' |2|     |3|<==|a|'//char(10)
       message=message//' ---     ---   ---'//{introspection:location}//char(10)
       call Galacticus_Warn(message)
    end if
    ! Perform sanity checks if subhalos are not included.
    if (self%mergerTreeImporter_%treesHaveSubhalos() == booleanFalse) then
       if (self%presetMergerTimes   ) call Galacticus_Error_Report('cannot preset merger times as no subhalos are present; try setting [presetMergerTimes]=false'      //{introspection:location})
       if (self%presetMergerNodes   ) call Galacticus_Error_Report('cannot preset merger nodes as no subhalos are present; try setting [presetMergerNodes]=false'      //{introspection:location})
       if (self%presetSubhaloMasses ) call Galacticus_Error_Report('cannot preset subhalo masses as no subhalos are present; try setting [presetSubhaloMasses]=false'  //{introspection:location})
       if (self%presetSubhaloIndices) call Galacticus_Error_Report('cannot preset subhalo indices as no subhalos are present; try setting [presetSubhaloIndices]=false'//{introspection:location})
    end if
    ! Determine if subhalo masses have been included in halo masses.   
    if (self%mergerTreeImporter_%treesAreSelfContained() == booleanFalse) call Galacticus_Error_Report('only self-contained trees are supported'//{introspection:location})   
    ! Check that position information is present if required.
    if     (                                                                                      &
         &   (                                                                                    &
         &     self%presetPositions                                                               &
         &    .or.                                                                                &
         &     self%presetOrbits                                                                  &
         &   )                                                                                    &
         &  .and.                                                                                 &
         &   .not.self%mergerTreeImporter_%positionsAvailable(positions=.true.,velocities=.true.) &
         & )                                                                                      &
         & call Galacticus_Error_Report(                                                          &
         &                              "presetting positions requires that both position and     &
         &                               velocity datasets be present in merger tree file"   //   &
         &                              {introspection:location}                                  &
         &                             )
    ! Check that half-mass radius information is present if required.
    if     (                                                                                                                                                        &
         &   self%presetScaleRadii                                                                                                                                  &
         &  .and.                                                                                                                                                   &
         &   .not.self%mergerTreeImporter_%scaleRadiiAvailable()                                                                                                    &
         & )  call Galacticus_Error_Report(                                                                                                                         &
         &                                "presetting scale radii requires that at least one of readRadiusHalfMass or scaleRadius datasets be present in merger"//  &
         &                                "tree file; try setting"//char(10)//"  [presetScaleRadii]=false"                                                      //  &
         &                                {introspection:location}                                                                                                  &
         &                               )
    ! Check that angular momentum information is present if required.
    if     (                                                                                                        &
         &   self%presetSpins                                                                                       &
         &  .and.                                                                                                   &
         &   .not.                                                                                                  &
         &        (                                                                                                 &
         &          self%mergerTreeImporter_%          spinAvailable()                                              &
         &         .or.                                                                                             &
         &          self%mergerTreeImporter_%angularMomentaAvailable()                                              &
         &        )                                                                                                 &
         & )                                                                                                        &
         & call Galacticus_Error_Report(                                                                            &
         &                              "presetting spins requires that the spin or angularMomentum datasets        &
         &                               be present in merger tree file; try setting"                            // &
         &                              char(10)                                                                 // &
         &                              " [presetSpins]=false"                                                   // &
         &                                {introspection:location}                                                  &
         &                             )
    if     (                                                                                                        &
         &   self%presetSpins3D                                                                                     &
         &  .and.                                                                                                   &
         &   .not.                                                                                                  &
         &        (                                                                                                 &
         &          self%mergerTreeImporter_%          spin3DAvailable()                                            &
         &         .or.                                                                                             &
         &          self%mergerTreeImporter_%angularMomenta3DAvailable()                                            &
         &        )                                                                                                 &
         & )                                                                                                        &
         & call Galacticus_Error_Report(                                                                            &
         &                              "presetting spin vectors requires that the spin or angularMomentum vector   &
         &                               datasets be present in merger tree file; try setting"                   // &
         &                              char(10)                                                                 // &
         &                              " [presetSpins3D]=false"                                                 // &
         &                                {introspection:location}                                                  &
         &                             )
    ! Create an OpenMP lock that will allow threads to coordinate access to split forest data.
    !$ call OMP_Init_Lock(self%splitForestLock)
    ! Create named datasets if necessary.
    if     (                                    &
         &   size(self%presetNamedReals   ) > 0 &
         &  .or.                                &
         &   size(self%presetNamedIntegers) > 0 &
         &  ) then
       select type (defaultNBodyComponent)
       class is (nodeComponentNBodyGeneric)
          if (size(self%presetNamedReals   ) > 0) then
             allocate(self%indexNamedReals   (size(self%presetNamedReals   )))
             do i=1,size(self%presetNamedReals   )
                self%indexNamedReals   (i)=defaultNBodyComponent%addRealProperty   (char(self%presetNamedReals   (i)))
             end do
          end if
          if (size(self%presetNamedIntegers) > 0) then
             allocate(self%indexNamedIntegers(size(self%presetNamedIntegers)))
             do i=1,size(self%presetNamedIntegers)
                self%indexNamedIntegers(i)=defaultNBodyComponent%addIntegerProperty(char(self%presetNamedIntegers(i)))
             end do
          end if
       class default
          call Galacticus_Error_Report('presetting of named datasets is supported only with the "generic" N-body component'//{introspection:location})
       end select
    end if
    return    
  end function readConstructorInternal

  subroutine readDestructor(self)
    !% Destructor for the {\normalfont \ttfamily read} merger tree constructor class.
    implicit none
    type(mergerTreeConstructorRead), intent(inout) :: self

    if (self%importerOpen) then
       call self%mergerTreeImporter_%close()
       self%importerOpen=.false.
    end if
    !# <objectDestructor name="self%cosmologyFunctions_"            />
    !# <objectDestructor name="self%mergerTreeImporter_"            />
    !# <objectDestructor name="self%darkMatterHaloScale_"           />
    !# <objectDestructor name="self%darkMatterProfileDMO_"          />
    !# <objectDestructor name="self%darkMatterProfileConcentration_"/>
    !# <objectDestructor name="self%haloSpinDistribution_"          />
    !# <objectDestructor name="self%satelliteMergingTimescales_"    />
    !# <objectDestructor name="self%virialOrbit_"                   />
    !# <objectDestructor name="self%outputTimes_"                   />
    !# <objectDestructor name="self%darkMatterProfileScaleRadius_"  />
    return
  end subroutine readDestructor

  function readConstruct(self,treeNumber) result(tree)
    !% Construct a merger tree by reading its definition from file.
    use Galacticus_Nodes       , only : treeNodeList            , defaultDarkMatterProfileComponent, defaultSpinComponent, defaultSatelliteComponent, &
         &                              defaultPositionComponent
    use Galacticus_State
    use Merger_Tree_State_Store
    use Galacticus_Error
    use String_Handling
    use Memory_Management
    use Arrays_Search
    use Array_Utilities
    use Numerical_Comparison
    use Vectors
    use Sort
    use Pseudo_Random
    !$ use OMP_Lib
    implicit none
    type            (mergerTree               ), pointer                             :: tree
    class           (mergerTreeConstructorRead), intent(inout)                       :: self
    integer         (c_size_t                 ), intent(in   )                       :: treeNumber
    integer         (c_size_t                 )                                      :: treeNumberInternal                           
    integer         (kind_int8                ), allocatable, dimension(:  )         :: historyIndex
    double precision                           , allocatable, dimension(:  )         :: historyMass           , historyTime       
    double precision                           , allocatable, dimension(:,:)         :: position              , velocity          
    class           (nodeDataMinimal          ), allocatable, dimension(:  ), target :: nodes
    type            (treeNodeList             ), allocatable, dimension(:  )         :: nodeList                           
    logical                                    , allocatable, dimension(:  )         :: childIsSubhalo                         
    double precision                                        , dimension(3  )         :: relativePosition      , relativeVelocity , &
         &                                                                              orbitalAngularMomentum
    integer         (c_size_t                 ), allocatable, dimension(:  )         :: nodeSubset
    integer                                                                          :: isolatedNodeCount
    integer         (c_size_t                 )                                      :: historyCountMaximum   , iNode            , &
         &                                                                              iOutput               , treeNumberMaximum, &
         &                                                                              treeNumberOffset
    logical                                                                          :: returnSplitForest
    type            (varying_string           )                                      :: message
    double precision                                                                 :: uniformRandom

    ! Snapshot the state of the next tree to read.
    treeStateStoreSequence=treeNumber
    ! Retrieve stored internal state if possible.
    call Galacticus_State_Retrieve()
    ! Recover the state of the next tree to read.
    treeNumberInternal=treeStateStoreSequence
    ! Determine if we have any split forests to return.
    returnSplitForest=allocated(self%splitForestTreeSize)
    ! Find the maximum tree number in the current file.
    treeNumberMaximum=int(self%mergerTreeImporter_%treeCount(),kind=c_size_t)
    ! Check if we need to move to a new file.
    if (treeNumber-self%treeNumberOffset > treeNumberMaximum .and. self%fileCurrent < size(self%fileNames)) then
       self%fileCurrent     =self%fileCurrent     +1
       self%treeNumberOffset=self%treeNumberOffset+treeNumberMaximum
       call self%mergerTreeImporter_%close(                                )
       call self%mergerTreeImporter_%open (self%fileNames(self%fileCurrent))
    end if
    treeNumberOffset=treeNumber-self%treeNumberOffset
    if (treeNumberOffset <= treeNumberMaximum) then
       ! Set tree properties.
       allocate(tree)
       ! treeIndex
       tree%index            =self%mergerTreeImporter_%treeIndex (int(treeNumberOffset))
       ! volumeWeight
       self%treeWeightCurrent=self%mergerTreeImporter_%treeWeight(int(treeNumberOffset))
       tree%volumeWeight     =self%treeWeightCurrent
       ! Initialize no events.
       tree%event            => null()
       tree%initializedUntil =  0.0d0
       call tree%properties%initialize()
       ! Restart the random number sequence for this tree. We use the tree index modulo the largest number representable by
       ! the integer type.
       tree%randomNumberGenerator=pseudoRandom()
       uniformRandom=tree%randomNumberGenerator%uniformSample(ompThreadOffset=.false.,mpiRankOFfset=.false.,incrementSeed=int(mod(tree%index,huge(0))))
       ! Store internal state.
       message='Storing state for tree #'
       message=message//treeStateStoreSequence
       call Galacticus_State_Store(message)          
       ! Check if the size of this forest exceeds the maximum allowed.
       if     (                                                                                    &
            &   .not.returnSplitForest                                                             &
            &  .and.                                                                               &
            &   self%mergerTreeImporter_%nodeCount(int(treeNumberOffset)) > self%forestSizeMaximum &
            &  .and.                                                                               &
            &   0                                                         < self%forestSizeMaximum &
            & ) then
#ifdef USEMPI
          call Galacticus_Error_Report('split forest processing is not supported under MPI'                        //{introspection:location})
#else
          call Galacticus_Error_Report('split forest processing is currently broken until MPI support is completed'//{introspection:location})
#endif
          ! Check if the importer supports reading subsets of halos from a forest.
          if (.not.self%mergerTreeImporter_%canReadSubsets()) call Galacticus_Error_Report('forest exceeds maximum allowed size but importer cannot read subsets of halos'//{introspection:location})
          ! Import nodes, and keep only the minimally required data to map the tree structure.
          call self%mergerTreeImporter_%import(int(treeNumberOffset),nodes,structureOnly=.true.)
          ! Find initial root node affinities of all nodes.
          call self%rootNodeAffinitiesInitial(nodes)
          call Memory_Usage_Record(sizeof(nodes),addRemove=-1)
          deallocate(nodes)
          returnSplitForest      =.true.
          self%splitForestNextTree    =0
          self%splitForestActiveForest=int(treeNumberOffset)
       end if
       ! Determine subset of nodes to read.
       if (returnSplitForest) then
          ! Move to the next tree.
          self%splitForestNextTree=self%splitForestNextTree+1
          allocate(nodeSubset(self%splitForestTreeSize(self%splitForestNextTree)))
          nodeSubset=self%splitForestMapIndex(self%splitForestTreeStart(self%splitForestNextTree):self%splitForestTreeStart(self%splitForestNextTree)+self%splitForestTreeSize(self%splitForestNextTree)-1)
          call Sort_Do(nodeSubset)
       else
          allocate(nodeSubset(1))
          nodeSubset=[-1_c_size_t]
       end if
       ! Read data from the file.
       !# <conditionalCall>
       !# <call>
       !#   call self%mergerTreeImporter_%import(                                                                                                                      &amp;
       !#      &amp;                             int(treeNumberOffset)                                                                                               , &amp;
       !#      &amp;                             nodes                                                                                                               , &amp;
       !#      &amp;                             requireScaleRadii         = self%presetScaleRadii                                                                   , &amp;
       !#      &amp;                             requireAngularMomenta     =(self%presetSpins              .and.self%mergerTreeImporter_%angularMomentaAvailable  ()), &amp;
       !#      &amp;                             requireAngularMomenta3D   =                                                                                           &amp;
       !#      &amp;                                                        (                                                                                          &amp;
       !#      &amp;                                                           self%presetSpins3D                                                                      &amp;
       !#      &amp;                                                          .or.                                                                                     &amp;
       !#      &amp;                                                           (                                                                                       &amp;
       !#      &amp;                                                             self%presetSpins                                                                      &amp;
       !#      &amp;                                                            .and.                                                                                  &amp;
       !#      &amp;                                                             self%subhaloAngularMomentaMethod == readSubhaloAngularMomentaMethodSummation          &amp;
       !#      &amp;                                                           )                                                                                       &amp;
       !#      &amp;                                                         )                                                                                         &amp;
       !#      &amp;                                                        .and.                                                                                      &amp;
       !#      &amp;                                                         self%mergerTreeImporter_%angularMomenta3DAvailable()                                    , &amp;
       !#      &amp;                             requireSpin               =(self%presetSpins              .and.self%mergerTreeImporter_%spinAvailable            ()), &amp;
       !#      &amp;                             requireSpin3D             =(self%presetSpins3D            .and.self%mergerTreeImporter_%spin3DAvailable          ()), &amp;
       !#      &amp;                             requirePositions          =(self%presetPositions          .or. self%presetOrbits                                   ), &amp;
       !#      &amp;                             nodeSubset                =nodeSubset                                                                                 &amp;
       !#      &amp;                             {conditions}                                                                                                          &amp;
       !#      &amp;                            )
       !#  </call>
       !#  <argument name="requireNamedReals"    value="self%presetNamedReals"    condition="size(self%presetNamedReals   ) > 0"/>
       !#  <argument name="requireNamedIntegers" value="self%presetNamedIntegers" condition="size(self%presetNamedIntegers) > 0"/>
       !# </conditionalCall>
       deallocate(nodeSubset)
       select type (nodes)
       class is (nodeData)
          ! Snap node times to output times if a tolerance has been specified.
          if (self%outputTimeSnapTolerance > 0.0d0) then
             ! Loop over all nodes.
             do iNode=1,size(nodes)
                ! Find closest output time to the node time.
                iOutput=Search_Array_For_Closest(self%outputTimes,nodes(iNode)%nodeTime)
                ! Test if this time is sufficiently close that we should snap the node time to it.
                if (Values_Agree(nodes(iNode)%nodeTime,self%outputTimes(iOutput),relTol=self%outputTimeSnapTolerance)) &
                     & nodes(iNode)%nodeTime=self%outputTimes(iOutput)
             end do
          end if
          ! Sort node indices.
          call self%createNodeIndices      (nodes)
          ! Identify subhalos.
          nodes%isSubhalo=nodes%nodeIndex /= nodes%hostIndex
          ! Build pointers to descendent nodes.
          call self%buildDescendentPointers(nodes)
          ! Find cases where something that was a subhalo stops being a subhalo and prevent them if necessary.
          call self%enforceSubhaloStatus   (nodes)
          ! If necessary, add masses and angular momenta of subhalos to host halos.
          if (.not.self%mergerTreeImporter_%angularMomentaIncludeSubhalos().and.self%subhaloAngularMomentaMethod == readSubhaloAngularMomentaMethodScale) then
             ! This method requires angular momenta to be available.
             if (.not.self%mergerTreeImporter_%angularMomentaAvailable()) call Galacticus_Error_Report('scaling parent angular momentum for subhalo masses requires angular momenta availability'//{introspection:location})
             do iNode=1,size(nodes)
                if (nodes(iNode)%host%nodeIndex == nodes(iNode)%nodeIndex) then
                   if (self%presetSpins  )                     &
                        & nodes      (iNode)%angularMomentum   &
                        &      =nodes(iNode)%angularMomentum   &
                        &      /nodes(iNode)%nodeMass
                   if (self%presetSpins3D)                     &
                        & nodes      (iNode)%angularMomentum3D &
                        &      =nodes(iNode)%angularMomentum3D &
                        &      /nodes(iNode)%nodeMass
                end if
             end do
          end if
          if (.not.self%mergerTreeImporter_%massesIncludeSubhalos()) then
             do iNode=1,size(nodes)
                if (nodes(iNode)%host%nodeIndex /= nodes(iNode)%nodeIndex) nodes  (iNode)%host%nodeMass &
                     &                                                      =nodes(iNode)%host%nodeMass &
                     &                                                      +nodes(iNode)%nodeMass
             end do
          end if
          if (.not.self%mergerTreeImporter_%angularMomentaIncludeSubhalos().and.self%subhaloAngularMomentaMethod == readSubhaloAngularMomentaMethodScale) then
             do iNode=1,size(nodes)
                if (nodes(iNode)%host%nodeIndex == nodes(iNode)%nodeIndex) then
                   if (self%presetSpins)                       &
                        & nodes      (iNode)%angularMomentum   &
                        &      =nodes(iNode)%angularMomentum   &
                        &      *nodes(iNode)%nodeMass
                   if (self%presetSpins3D)                     & 
                        & nodes      (iNode)%angularMomentum3D &
                        &      =nodes(iNode)%angularMomentum3D &
                        &      *nodes(iNode)%nodeMass

                end if
             end do
          end if
          if     (                                                                              &
               &  (                                                                             &
               &    self%presetSpins3D                                                          &
               &   .or.                                                                         &
               &    self%presetSpins                                                            &
               &  )                                                                             &
               &  .and.                                                                         &
               &   .not.self%mergerTreeImporter_%angularMomentaIncludeSubhalos()                &
               &  .and.                                                                         &
               &   self%subhaloAngularMomentaMethod == readSubhaloAngularMomentaMethodSummation &
               & ) then
             ! This method requires 3D angular momenta to be available.
             if (.not.self%mergerTreeImporter_%angularMomenta3DAvailable())                                                                             &
                  & call Galacticus_Error_Report(                                                                                                       &
                  &                              'adding subhalo angular momenta to parent angular momentum requires 3D angular momenta availability'// &
                  &                              {introspection:location}                                                                               &
                  &                             )
             do iNode=1,size(nodes)
                if (nodes(iNode)%host%nodeIndex /= nodes(iNode)%nodeIndex) then
                   ! Find relative position and velocity.
                   relativePosition=nodes(iNode)%position-nodes(iNode)%host%position
                   relativeVelocity=nodes(iNode)%velocity-nodes(iNode)%host%velocity
                   ! Update position/velocity for periodicity and Hubble flow.
                   call self%phaseSpacePositionRealize(nodes(iNode)%nodeTime,relativePosition,relativeVelocity)
                   ! Compute orbital angular momentum of subhalo.
                   orbitalAngularMomentum=+nodes(iNode)%nodeMass                             &
                        &                 *Vector_Product(relativePosition,relativeVelocity)
                   ! Sum orbital and internal angular momenta.
                   nodes        (iNode)%host%angularMomentum3D &
                        & =nodes(iNode)%host%angularMomentum3D &
                        & +nodes(iNode)     %angularMomentum3D &
                        & +orbitalAngularMomentum
                end if
             end do
             ! Update scalar angular momenta.
             do iNode=1,size(nodes)
                if (nodes(iNode)%host%nodeIndex == nodes(iNode)%nodeIndex) &
                     & nodes(iNode)%angularMomentum=Vector_Magnitude(nodes(iNode)%angularMomentum3D)
             end do
          end if
          ! Associate parent pointers with the descendent host.
          call readBuildParentPointers         (     nodes                                          )
          ! Create an array of standard nodes.
          call self%createNodeArray            (tree,nodes,nodeList,isolatedNodeCount,childIsSubhalo)
          ! Assign parent pointers and properties.
          call self%buildIsolatedParentPointers(tree,nodes,nodeList                                 )
          ! Now build child and sibling links.
          call readBuildChildAndSiblingLinks   (     nodes,nodeList                  ,childIsSubhalo)
          ! (Re)assign host tree pointers.
          call readAssignHostTreePointers      (tree                                                )
          ! Assign split forest events.
          call self%assignSplitForestEvents    (     nodes,nodeList                                 )
          ! Check that all required properties exist.
          if (self%presetPositions.or.self%presetOrbits) then
             ! Position and velocity methods are required.
             if     (                                                                                                                                                     &
                  &  .not.(                                                                                                                                               &
                  &         defaultPositionComponent%positionIsSettable()                                                                                                 &
                  &        .and.                                                                                                                                          &
                  &         defaultPositionComponent%velocityIsSettable()                                                                                                 &
                  &       )                                                                                                                                               &
                  & )                                                                                                                                                     &
                  & call Galacticus_Error_Report                                                                                                                          &
                  &      (                                                                                                                                                &
                  &       'presetting positions or orbits requires a component that supports position and velocity setting (e.g. set [treeNodeMethodPosition]=preset);'// &
                  &       Galacticus_Component_List(                                                                                                                      &
                  &                                 'position'                                                                                                          , &
                  &                                  defaultPositionComponent        %     positionAttributeMatch(requireSettable=.true.)                                 &
                  &                                 .intersection.                                                                                                        &
                  &                                  defaultPositionComponent        %     velocityAttributeMatch(requireSettable=.true.)                                 &
                  &                                )                                                                                                                   // &
                  &       char(10)                                                                                                                                     // &
                  &       'alternatively setting [presetPositions]=false and [presetOrbits]=false will remove the need to store positions and velocities'              // &
                  &       {introspection:location}                                                                                                                        &
                  & )
          end if
          if (self%presetMergerTimes) then
             ! Time of merging property is required.
             if (.not.defaultSatelliteComponent%timeOfMergingIsSettable      ())                                                                                          &
                  & call Galacticus_Error_Report                                                                                                                          &
                  &      (                                                                                                                                                &
                  &       'presetting merging times requires a component that supports setting of merging times.'                                                      // &
                  &       Galacticus_Component_List(                                                                                                                      &
                  &                                 'satellite'                                                                                                         , &
                  &                                  defaultSatelliteComponent       %timeOfMergingAttributeMatch(requireSettable=.true.)                                 &
                  &                                 )                                                                                                                  // &
                  &       {introspection:location}                                                                                                                        &
                  &      )
          end if
          if (self%presetScaleRadii) then
             ! Scale radius property is required.
             if (.not.defaultDarkMatterProfileComponent%scaleIsSettable      ())                                                                                          &
                  & call Galacticus_Error_Report                                                                                                                          &
                  &      (                                                                                                                                                &
                  &       'presetting scale radii requires a component that supports setting of scale radii.'                                                          // &
                  &       Galacticus_Component_List(                                                                                                                      &
                  &                                 'darkMatterProfile'                                                                                                 , &
                  &                                 defaultDarkMatterProfileComponent%        scaleAttributeMatch(requireSettable=.true.)                                 &
                  &                                )                                                                                                                   // &
                  &       {introspection:location}                                                                                                                        &
                  &      )
          end if
          if (self%presetSpins      ) then
             ! Spin property is required.
             if (.not.defaultSpinComponent             %spinIsSettable       ())                                                                                          &
                  & call Galacticus_Error_Report                                                                                                                          &
                  &      (                                                                                                                                                &
                  &       'presetting spins requires a component that supports setting of spins.'                                                                      // &
                  &       Galacticus_Component_List(                                                                                                                      &
                  &                                 'spin'                                                                                                              , &
                  &                                 defaultSpinComponent             %         spinAttributeMatch(requireSettable=.true.)                                 &
                  &                                )                                                                                                                   // &
                  &       {introspection:location}                                                                                                                        &
                  &      )
          end if
          if (self%presetSpins3D    ) then
             ! Spin property is required.
             if (.not.defaultSpinComponent             %spinVectorIsSettable ())                                                                                          &
                  & call Galacticus_Error_Report                                                                                                                          &
                  &      (                                                                                                                                                &
                  &       'presetting spin vectors requires a component that supports setting of spin vectors.'                                                        // &
                  &       Galacticus_Component_List(                                                                                                                      &
                  &                                 'spinVector'                                                                                                        , &
                  &                                 defaultSpinComponent             %     spinVectorAttributeMatch(requireSettable=.true.)                               &
                  &                                )                                                                                                                   // &
                  &       {introspection:location}                                                                                                                        &
                  &      )
          end if
          if (self%presetOrbits     ) then
             ! Orbit property is required.
             if (.not.defaultSatelliteComponent        %virialOrbitIsSettable())                                                                                          &
                  & call Galacticus_Error_Report                                                                                                                          &
                  &      (                                                                                                                                                &
                  &       'presetting orbits requires a component that supports setting of orbits (e.g. [treeNodeMethodSatelliteOrbit]=preset);'                       // &
                  &       Galacticus_Component_List(                                                                                                                      &
                  &                                 'satellite'                                                                                                         , &
                  &                                 defaultSatelliteComponent        %  virialOrbitAttributeMatch(requireSettable=.true.)                                 &
                  &                                )                                                                                                                   // &
                  &       char(10)                                                                                                                                     // &
                  &       'Alternatively, set [presetOrbits]=false to prevent attempts to set orbits)'                                                                 // &
                  &       {introspection:location}                                                                                                                        &
                  &      )
          end if
          ! Assign named properties.
          if     (                                    &
               &   size(self%presetNamedReals   ) > 0 &
               &  .or.                                &
               &   size(self%presetNamedIntegers) > 0 &
               & )                                    &
               &                                   call self%assignNamedProperties   (nodes,nodeList                    )
          ! Assign scale radii.
          if     ( self%presetScaleRadii         ) call self%assignScaleRadii        (nodes,nodeList                    )
          ! Assign spin parameters.
          if     (                    &
               &   self%presetSpins   &
               &  .or.                &
               &   self%presetSpins3D &
               & )                                 call self%assignSpinParameters    (nodes,nodeList                    )
          ! Assign isolated node indices to subhalos.
          call readAssignIsolatedNodeIndices                                         (nodes                             )
          ! Ensure that isolated nodes with progenitors that descend into subhalos have valid primary progenitors.
          call readValidateIsolatedHalos                                             (nodes                             )
          ! Scan subhalos to determine when and how they merge.
          call self%scanForMergers                                                   (nodes,nodeList,historyCountMaximum)
          ! If a split forest was used, but all trees from it have now been processed, remove the split forest data as we no
          ! longer need it at this point.
          if (returnSplitForest .and. self%splitForestNextTree == size(self%splitForestTreeStart)) then
             call deallocateArray(self%splitForestTreeSize )
             call deallocateArray(self%splitForestTreeStart)
             call deallocateArray(self%splitForestPushTo   )
             call deallocateArray(self%splitForestPullFrom )
             call deallocateArray(self%splitForestPushType )
             call deallocateArray(self%splitForestMapIndex )
          end if
          ! Release the lock on split forest data if necessary as we're finished using it. This allows other threads to begin
          ! using the split forest data.
          !$ if (self%forestSizeMaximum > 0) call OMP_Unset_Lock(self%splitForestLock)
          ! Search for any nodes which were flagged as merging with another node and assign appropriate pointers.
          call self%assignMergers             (nodes,nodeList)
          ! Find cases where something that was a subhalo stops being a subhalo and add events to handle.
          call self%scanForSubhaloPromotions(nodes,nodeList)
          ! Search for subhalos which move between branches/trees.
          call self%scanForBranchJumps      (nodes,nodeList)
          ! Allocate arrays for history building.
          if (allocated(position)) call deallocateArray(position)
          if (allocated(velocity)) call deallocateArray(velocity)
          call allocateArray(historyTime,[int(historyCountMaximum)])
          if (self%presetSubhaloIndices                             ) then
             call allocateArray(historyIndex,[  int(historyCountMaximum)])
          else
             call allocateArray(historyIndex,[                        0 ])
          end if
          if (self%presetSubhaloMasses                              ) then
             call allocateArray(historyMass ,[  int(historyCountMaximum)])
          else
             call allocateArray(historyMass ,[                        0 ])
          end if
          if (self%presetPositions    .or.self%presetOrbits) then
             call allocateArray(position    ,[3,int(historyCountMaximum)])
             call allocateArray(velocity    ,[3,int(historyCountMaximum)])
          else
             call allocateArray(position    ,[0,                      0 ])
             call allocateArray(velocity    ,[0,                      0 ])
          end if
          ! Build subhalo mass histories if required.
          call self%buildSubhaloMassHistories(nodes,nodeList,historyCountMaximum,historyTime,historyIndex,historyMass,position,velocity)
          ! Assign new uniqueIDs to any cloned nodes inserted into the trees.
          call readAssignUniqueIDsToClones(nodeList)
          ! Deallocate history building arrays.
          if (allocated(historyTime)) call deallocateArray(historyTime )
          if (allocated(historyMass)) call deallocateArray(historyIndex)
          if (allocated(historyMass)) call deallocateArray(historyMass )
          if (allocated(position   )) call deallocateArray(position    )
          if (allocated(velocity   )) call deallocateArray(velocity    )
          ! Deallocate the temporary arrays.
          call Memory_Usage_Record(sizeof(nodeList),addRemove=-1)
          deallocate(nodeList)
          ! Destroy sorted node indices.
          call self%destroyNodeIndices()
       class default
          call Galacticus_Error_Report('nodes arrays is of wrong class'//{introspection:location})
       end select
       ! Deallocate nodes.
       call Memory_Usage_Record(sizeof(nodes),addRemove=-1)
       deallocate(nodes)
    else
       nullify(tree)
    end if
    return
  end function readConstruct

  subroutine readCreateNodeIndices(self,nodes)
    !% Create a sorted list of node indices with an index into the original array.
    use Galacticus_Error
    use String_Handling
    use Memory_Management
    use Sort
    implicit none
    class  (mergerTreeConstructorRead), intent(inout)                :: self
    class  (nodeDataMinimal          ), dimension(:) , intent(inout) :: nodes   
    integer                                                          :: iNode   
    type   (varying_string           )                               :: message 
    
    ! Build a sorted list of node indices with an index into the original arrays.
    call allocateArray(self%nodeLocations          ,shape(nodes))
    call allocateArray(self%nodeIndicesSorted      ,shape(nodes))
    call allocateArray(self%descendentLocations    ,shape(nodes))
    call allocateArray(self%descendentIndicesSorted,shape(nodes))
    self%nodeLocations      =Sort_Index_Do(nodes%nodeIndex      )
    self%descendentLocations=Sort_Index_Do(nodes%descendentIndex)
    forall (iNode=1:size(nodes))
       self%nodeIndicesSorted      (iNode)=nodes(self%nodeLocations      (iNode))%nodeIndex
       self%descendentIndicesSorted(iNode)=nodes(self%descendentLocations(iNode))%descendentIndex
    end forall
    do iNode=2,size(nodes)
       if (self%nodeIndicesSorted(iNode) == self%nodeIndicesSorted(iNode-1)) then
          message="WARNING: duplicate node index found in merger tree - this is not allowed ["
          message=message//self%nodeIndicesSorted(iNode)//']'
          call Galacticus_Warn(message)
       end if
    end do
    return
  end subroutine readCreateNodeIndices

  function readNodeLocation(self,nodeIndex)
    !% Return the location in the original array of the given {\normalfont \ttfamily nodeIndex}.
    use Arrays_Search
    implicit none
    integer(c_size_t                 )                :: readNodeLocation
    class  (mergerTreeConstructorRead), intent(inout) :: self
    integer(kind_int8                ), intent(in   ) :: nodeIndex     
    integer(c_size_t                 )                :: iNode         
    
    iNode=Search_Array(self%nodeIndicesSorted,nodeIndex)
    if (iNode < 1 .or. iNode > size(self%nodeIndicesSorted)) then
       readNodeLocation=1
    else
       readNodeLocation=self%nodeLocations(iNode)
    end if
    return
  end function readNodeLocation

  function readDescendentNodeSortIndex(self,descendentIndex)
    !% Return the sort index of the given {\normalfont \ttfamily descendentIndex}.
    use Arrays_Search
    implicit none
    integer(c_size_t                 )                :: readDescendentNodeSortIndex
    class  (mergerTreeConstructorRead), intent(inout) :: self
    integer(kind_int8                ), intent(in   ) :: descendentIndex 
    
    readDescendentNodeSortIndex=Search_Array(self%descendentIndicesSorted,descendentIndex)
    return
  end function readDescendentNodeSortIndex

  subroutine readDestroyNodeIndices(self)
    !% Destroy the sorted list of node indices.
    use Memory_Management
    implicit none
    class(mergerTreeConstructorRead), intent(inout) :: self

    if (allocated(self%nodeLocations          )) call deallocateArray(self%nodeLocations          )
    if (allocated(self%nodeIndicesSorted      )) call deallocateArray(self%nodeIndicesSorted      )
    if (allocated(self%descendentLocations    )) call deallocateArray(self%descendentLocations    )
    if (allocated(self%descendentIndicesSorted)) call deallocateArray(self%descendentIndicesSorted)
    return
  end subroutine readDestroyNodeIndices

  subroutine readBuildDescendentPointers(self,nodes)
    !% Builds pointers from each node to its descendent node.
    use String_Handling
    use Galacticus_Error
    use Galacticus_Display
    implicit none
    class  (mergerTreeConstructorRead), intent(inout)                        :: self
    class  (nodeData                 ), dimension(:) , intent(inout), target :: nodes                 
    integer(c_size_t                 )                                       :: iNode  , nodeLocation 
    type   (varying_string           )                                       :: message               
    
    do iNode=1,size(nodes)
       ! Does this node have a descendent? And is it staying in this tree?
       if (nodes(iNode)%descendentIndex >= 0.and..not.self%isOnPushList(nodes(iNode))) then
          nodeLocation=self%nodeLocation(nodes(iNode)%descendentIndex)
          if (nodes(nodeLocation)%nodeIndex /= nodes(iNode)%descendentIndex) then
             message='failed to find descendent node: '
             message=message//nodes(iNode)%descendentIndex//' of '//nodes(iNode)%nodeIndex
             call Galacticus_Error_Report(message//{introspection:location})
          end if
          nodes(iNode)%descendent => nodes(nodeLocation)
       else
          nodes(iNode)%descendent => null()
       end if
       if (nodes(iNode)%hostIndex       >= 0) then
          nodeLocation=self%nodeLocation(nodes(iNode)%hostIndex      )
          if (nodes(nodeLocation)%nodeIndex /= nodes(iNode)%hostIndex       ) then
             message='failed to find host node: '
             message=message//nodes(iNode)%hostIndex//' of '//nodes(iNode)%nodeIndex
             if (self%missingHostsAreFatal) then
                call Galacticus_Error_Report(message//{introspection:location})
             else
                message=message//" - resetting this node to be an isolated node"
                call Galacticus_Display_Message(message,verbosity=verbosityInfo)
                nodes(iNode)%hostIndex =  nodes(iNode)%nodeIndex
                nodes(iNode)%host      => nodes(iNode)
                nodes(iNode)%isSubhalo =  .false.
             end if
          else
             nodes(iNode)%host    => nodes(nodeLocation)
          end if
       else
          call Galacticus_Error_Report('negative values are not allowed for hostIndex - if node is self-hosting [i.e. not a subhalo] set hostIndex=nodeIndex'//{introspection:location})
       end if
    end do
    return
  end subroutine readBuildDescendentPointers

  subroutine readEnforceSubhaloStatus(self,nodes)
    !% Ensure that any node which was once a subhalo remains a subhalo.
    use Galacticus_Error
    use String_Handling
    implicit none
    class  (mergerTreeConstructorRead), intent(inout)                        :: self
    class  (nodeData                 ), dimension(:) , intent(inout), target :: nodes
    class  (nodeData                 ), pointer                              :: descendentNode, progenitorNode
    integer(c_size_t                 )                                       :: iNode
    logical                                                                  :: failed        , isolatedProgenitorExists 
    type   (varying_string           )                                       :: message
    type   (progenitorIterator       )                                       :: progenitors
    
    ! Return immediately if subhalo promotions are allowed.
    if (self%allowSubhaloPromotions) return
    ! Subhalo promotions are not allowed, so enforce subhalo status.
    do iNode=1,size(nodes)
       if (nodes(iNode)%isSubhalo) then
          descendentNode => nodes(iNode)%descendent
          do while (associated(descendentNode))
             ! Is this node isolated?
             if (.not.descendentNode%isSubhalo) then
                ! Check if there is any isolated node which descends into this node.
                isolatedProgenitorExists=.false.
                call progenitors%descendentSet(self,descendentNode,nodes)
                do while (progenitors%next(nodes) .and. .not.isolatedProgenitorExists)
                   progenitorNode => progenitors%current(nodes)
                   isolatedProgenitorExists=(progenitorNode%nodeIndex == progenitorNode%hostIndex)
                end do
                if (.not.progenitors%exist() .or. .not.isolatedProgenitorExists) then
                   ! Node is isolated, has no isolated node that descends into it. Therefore, our current node is not allowed to
                   ! be a subhalo.
                   nodes(iNode)%isSubhalo=.false.
                   nodes(iNode)%host => nodes(iNode)
                   nodes(iNode)%hostIndex=nodes(iNode)%nodeIndex
                end if
             end if
             descendentNode => descendentNode%descendent
          end do
       end if
    end do
    ! Check that subhalo enforcement was successful.
    failed=.false.
    do iNode=1,size(nodes)
       ! Find nodes which have no isolated node descending into them.       
       isolatedProgenitorExists=.false.
       call progenitors%descendentSet(self,nodes(iNode),nodes)
       do while (progenitors%next(nodes) .and. .not.isolatedProgenitorExists)
          progenitorNode => progenitors%current(nodes)
          isolatedProgenitorExists=(progenitorNode%nodeIndex == progenitorNode%hostIndex)
       end do
       if (progenitors%exist() .and. .not.isolatedProgenitorExists) then
          ! Such nodes must be subhalos. If they are not, report an error
          if (.not.nodes(iNode)%isSubhalo) then
             if (failed) then
                message=message//', '
             else
                message='failed to enforce persistent subhalo status for node ['
             end if
             message=message//nodes(iNode)%nodeIndex
             failed=.true.
          end if
       end if
    end do
    if (failed) then
       message=message//']'
       call Galacticus_Error_Report(message//{introspection:location})
    end if
    return
  end subroutine readEnforceSubhaloStatus

  subroutine readScanForSubhaloPromotions(self,nodes,nodeList)
    !% Scan for cases where a subhalo stops being a subhalo and so must be promoted.
    use Galacticus_Nodes       , only : nodeEvent, treeNodeList, nodeEventSubhaloPromotion
    use Node_Subhalo_Promotions
    implicit none
    class  (mergerTreeConstructorRead), intent(inout)                              :: self
    class  (nodeData                 ), target       , dimension(:), intent(inout) :: nodes                                    
    type   (treeNodeList             )               , dimension(:), intent(inout) :: nodeList                                 
    class  (nodeData                 ), pointer                                    :: descendentNode          , progenitorNode 
    class  (nodeEvent                ), pointer                                    :: newEvent                , pairEvent      
    type   (treeNode                 ), pointer                                    :: promotionNode           , node       
    integer(c_size_t                 )                                             :: iNode                                    
    logical                                                                        :: isolatedProgenitorExists, nodeIsMostMassive
    type   (progenitorIterator       )                                             :: progenitors                              
    
    ! Return immediately if subhalo promotion is not allowed.
    if (.not.self%allowSubhaloPromotions) return
    ! Find subhalos to be promoted.
    do iNode=1,size(nodes)
       if (nodes(iNode)%isSubhalo.and.associated(nodes(iNode)%descendent)) then
          descendentNode => nodes(iNode)%descendent
          ! Is this node isolated?
          if (.not.descendentNode%isSubhalo) then          
             ! Check if there is any isolated node which descends into this node, and also whether this is the most massive
             ! subhalo which descends into the descendent.
             isolatedProgenitorExists=.false.
             nodeIsMostMassive       =.true.
             call progenitors%descendentSet(self,descendentNode,nodes)             
             do while (progenitors%next(nodes))
                progenitorNode => progenitors%current(nodes)
                if (progenitorNode%nodeIndex == progenitorNode%hostIndex) then
                   isolatedProgenitorExists=.true.
                else if (progenitorNode%nodeMass > nodes(iNode)%nodeMass) then
                   nodeIsMostMassive=.false.
                end if
             end do
             if (.not.progenitors%exist() .or. .not.isolatedProgenitorExists) then
                if (nodeIsMostMassive) then
                   ! Node is isolated, has no isolated node that descends into it, and our subhalo is the most massive subhalo which
                   ! descends into it. Therefore, our subhalo must be promoted to become an isolated halo again.
                   node       => nodeList(nodes(inode)  %isolatedNodeIndex)%node
                   promotionNode  => nodeList(descendentNode%isolatedNodeIndex)%node
                   allocate(nodeEventSubhaloPromotion ::  newEvent)
                   allocate(nodeEventSubhaloPromotion :: pairEvent)
                   call node     %attachEvent( newEvent)
                   call promotionNode%attachEvent(pairEvent)
                   newEvent %time =  descendentNode%nodeTime
                   newEvent %node => promotionNode
                   newEvent %task => Node_Subhalo_Promotion
                   pairEvent%time =  descendentNode%nodeTime
                   pairEvent%node => node
                   pairEvent%task => null()
                   pairEvent%ID   =  newEvent%ID
                else if (self%allowBranchJumps) then
                   ! Node is isolated, has no isolated node that descends into it, and our subhalo is not the most massive subhalo
                   ! which descends into it. Therefore, our subhalo must branch jump if this is allowed.
                   call readCreateBranchJumpEvent(                                                 &
                        &                        nodeList(nodes(inode)  %isolatedNodeIndex)%node, &
                        &                        nodeList(descendentNode%isolatedNodeIndex)%node, &
                        &                        descendentNode%nodeTime                          &
                        &                       )
                end if
             end if
          end if
       end if
    end do
    return
  end subroutine readScanForSubhaloPromotions

  subroutine readBuildParentPointers(nodes)
    !% Build pointers to node parents.
    use Galacticus_Error
    use String_Handling
    implicit none
    class  (nodeData      ), dimension(:), intent(inout), target :: nodes      
    class  (nodeData      ), pointer                             :: parentNode 
    integer(c_size_t      )                                      :: iNode      
    type   (varying_string)                                      :: message    
    
    do iNode=1,size(nodes)
       if (associated(nodes(iNode)%descendent)) then
          if (nodes(iNode)%nodeIndex == nodes(iNode)%host%nodeIndex) then
             ! Find an isolated parent node, by repeatedly jumping from host to host.
             parentNode => nodes(iNode)%descendent%host
             do while (parentNode%isSubhalo)
                if (associated(parentNode,parentNode%host)) then
                   message='node ['
                   message=message//parentNode%nodeIndex//'] flagged as subhalo is self-hosting - exiting to avoid infinite loop'
                   call Galacticus_Error_Report(message//{introspection:location})
                end if
                parentNode => parentNode%host
             end do
             nodes(iNode)%parent => parentNode
          else
             nodes(iNode)%parent => null()
          end if
       else
          nodes(iNode)%parent => null()
       end if
    end do
    ! Check for self-parents.
    do iNode=1,size(nodes)
       if (associated(nodes(iNode)%parent)) then
          if (nodes(iNode)%nodeIndex == nodes(iNode)%parent%nodeIndex) then
             message='node ['
             message=message//nodes(iNode)%nodeIndex//'] is its own parent - exiting to avoid infinite loop'
             call Galacticus_Error_Report(message//{introspection:location})
          end if
       end if
    end do
    return
  end subroutine readBuildParentPointers

  subroutine readCreateNodeArray(self,tree,nodes,nodeList,isolatedNodeCount,childIsSubhalo)
    !% Create an array of standard nodes and associated structures.
    use Memory_Management
    use Galacticus_Nodes , only : treeNodeList
    implicit none
    class  (mergerTreeConstructorRead)                           , intent(inout) :: self
    type   (mergerTree               )                           , intent(inout) :: tree                                 
    class  (nodeData                 )             , dimension(:), intent(inout) :: nodes                                    
    type   (treeNodeList             ), allocatable, dimension(:), intent(inout) :: nodeList                                 
    logical                           , allocatable, dimension(:), intent(inout) :: childIsSubhalo                           
    integer                                                      , intent(  out) :: isolatedNodeCount                        
    integer(c_size_t                 )                                           :: iNode                                    
    integer                                                                      :: iIsolatedNode    , initialSatelliteCount 
    logical                                                                      :: createNode                               
    type   (progenitorIterator       )                                           :: progenitors

    ! Determine how many nodes are isolated (i.e. not subhalos).
    isolatedNodeCount=count(.not.nodes%isSubhalo)

    ! Scan here for nodes that are subhalos and have no progenitor. These objects must be
    ! created as satellites within the tree.
    initialSatelliteCount=0
    do iNode=1,size(nodes)
       if (nodes(iNode)%isSubhalo) then
          call progenitors%descendentSet(self,nodes(iNode),nodes)
          if (.not.progenitors%exist()) initialSatelliteCount=initialSatelliteCount+1
      end if
    end do

    ! Allocate nodes.
    allocate(nodeList(isolatedNodeCount+initialSatelliteCount))
    call Memory_Usage_Record(sizeof(nodeList))
    call allocateArray(childIsSubhalo,[isolatedNodeCount+initialSatelliteCount])

    ! Create the nodes.
    iIsolatedNode          =0
    nodes%isolatedNodeIndex=readNodeReachabilityUnreachable
    do iNode=1,size(nodes)
       createNode=.false.
       if (nodes(iNode)%nodeIndex == nodes(iNode)%host%nodeIndex) then
          createNode=.true.
       else if (nodes(iNode)%isSubhalo) then
          call progenitors%descendentSet(self,nodes(iNode),nodes)
          if (.not.progenitors%exist()) createNode=.true.
       end if
       if (createNode) then
          iIsolatedNode=iIsolatedNode+1
          ! Store a record of where this node goes in the isolated node list.
          nodes(iNode)%isolatedNodeIndex=iIsolatedNode
          nodeList(iIsolatedNode)%node => treeNode(hostTree=tree)
          call nodeList(iIsolatedNode)%node%indexSet(nodes(iNode)%nodeIndex)
          nodes(iNode)%node => nodeList(iIsolatedNode)%node
       end if
    end do
    return
  end subroutine readCreateNodeArray

  subroutine readBuildIsolatedParentPointers(self,tree,nodes,nodeList)
    !% Create parent pointer links between isolated nodes and assign times and masses to those nodes.
    use String_Handling
    use Galacticus_Error
    use Pseudo_Random
    use Galacticus_Nodes, only : treeNodeList
    implicit none
    class           (mergerTreeConstructorRead)                       , intent(inout)          :: self
    type            (mergerTree               )                       , intent(inout) , target :: tree
    type            (nodeData                 )         , dimension(:), intent(inout)          :: nodes
    type            (treeNodeList             )         , dimension(:), intent(inout)          :: nodeList
    class           (nodeComponentBasic       ), pointer                                       :: basic
    type            (mergerTree               ), pointer                                       :: treeCurrent
    type            (nodeData                 ), pointer                                       :: parentNode
    integer                                                                                    :: iNode
    integer         (c_size_t                 )                                                :: iIsolatedNode                  
    type            (varying_string           )                                                :: message
    character       (len=12                   )                                                :: label
    logical                                                                                    :: assignLastIsolatedTime
    double precision                                                                           :: uniformRandom
    
    do iNode=1,size(nodes)
       ! Only process if this is an isolated node (or an initial satellite).
       if (nodes(iNode)%isolatedNodeIndex /= readNodeReachabilityUnreachable) then
          iIsolatedNode=nodes(iNode)%isolatedNodeIndex
          ! Check for an isolated node.
          if (nodes(iNode)%nodeIndex == nodes(iNode)%host%nodeIndex) then
             assignLastIsolatedTime=.false.
             if (associated(nodes(iNode)%parent)) then
                nodeList(iIsolatedNode)%node%parent  => nodes(iNode)%parent%node
             else
                nodeList(iIsolatedNode)%node%parent  => null()
                ! Find a tree to attach this base node to. Begin with the original tree passed to us.
                treeCurrent => tree
                ! Check if its baseNode is already assigned.
                do while (associated(treeCurrent%baseNode))
                   ! While it is, create the next tree (unless it already exists), then step to it.
                   if (.not.associated(treeCurrent%nextTree)) then
                      allocate(treeCurrent%nextTree)
                      treeCurrent%nextTree%randomNumberGenerator=pseudoRandom()
                   end if
                   treeCurrent => treeCurrent%nextTree
                end do
                ! Assign this node as the base node of the current tree.
                treeCurrent   %baseNode         => nodeList(iIsolatedNode)%node
                if (self%treeIndexToRootNodeIndex) then
                   treeCurrent%index            =  nodes(iNode        )%nodeIndex
                else
                   treeCurrent%index            =  tree                %index
                end if                
                treeCurrent   %volumeWeight     =  self%treeWeightCurrent
                treeCurrent   %initializedUntil =  0.0d0                
                treeCurrent   %event            => null()
                ! Initialize a new random number sequence for this tree, using the sum of the tree index and base node index as the seed increment.
                if (.not.associated(treeCurrent,tree)) uniformRandom=treeCurrent%randomNumberGenerator%uniformSample(ompThreadOffset=.false.,incrementSeed=int(mod(tree%index+nodes(iNode)%nodeIndex,huge(0))))
             end if
          else
             ! Node is not isolated, so must be an initial satellite.
             assignLastIsolatedTime=.true.
             if (associated(nodes(iNode)%host)) then
                parentNode => nodes(iNode)%host
                do while (parentNode%isSubhalo)
                   parentNode => parentNode%host
                end do
                nodeList(iIsolatedNode)%node%parent => parentNode%node
             else
                call Galacticus_Error_Report('initial satellite has no parent defined'//{introspection:location})
             end if
          end if
          ! Assign mass and time. For the case of satellites we also assign the time at
          ! which the satellite was last isolated. Since we do not know this, we simply
          ! set it equal to the current time (which is, obviously, an upper limit).
          if (nodes(iNode)%nodeMass <= 0.0d0) then
             write (label,'(e12.6)') nodes(iNode)%nodeMass
             message='non-positive mass ['//label//'] found for node '
             message=message//nodeList(iIsolatedNode)%node%index()
             call Galacticus_Error_Report(message//{introspection:location})
          end if
          if (nodes(iNode)%nodeTime <= 0.0d0) then
             write (label,'(e12.6)') nodes(iNode)%nodeTime
             message='non-positive time ['//label//'] found for node '
             message=message//nodeList(iIsolatedNode)%node%index()
             call Galacticus_Error_Report(message//{introspection:location})
          end if
          basic => nodeList(iIsolatedNode)%node%basic(autoCreate=.true.)
          call        basic%massSet            (nodes(iNode)%nodeMass)
          call        basic%timeSet            (nodes(iNode)%nodeTime)
          if (assignLastIsolatedTime) &
               & call basic%timeLastIsolatedSet(nodes(iNode)%nodeTime)
       end if
    end do
    return
  end subroutine readBuildIsolatedParentPointers

  subroutine readBuildChildAndSiblingLinks(nodes,nodeList,childIsSubhalo)
    !% Build child and sibling links between nodes.
    use Memory_Management
    use Galacticus_Nodes , only : treeNodeList
    implicit none
    class  (nodeData          )             , dimension(:), intent(inout) :: nodes                                     
    type   (treeNodeList      )             , dimension(:), intent(inout) :: nodeList                                  
    logical                    , allocatable, dimension(:), intent(inout) :: childIsSubhalo                            
    class  (nodeComponentBasic), pointer                                  :: basic            , basicPrimary 
    integer                                                               :: iNode                                     
    integer(c_size_t          )                                           :: iIsolatedNode                             
    logical                                                               :: descendsToSubhalo                         
    
    childIsSubhalo=.false.
    do iNode=1,size(nodes)
       ! Only process if this is an isolated node.
       if (nodes(iNode)%isolatedNodeIndex /= readNodeReachabilityUnreachable) then
          iIsolatedNode=nodes(iNode)%isolatedNodeIndex
          ! Check for an isolated node.
          if (nodes(iNode)%nodeIndex == nodes(iNode)%host%nodeIndex) then
             ! Check if the node has a parent.
             if (associated(nodeList(iIsolatedNode)%node%parent)) then
                ! Determine if this node definitely descends to a subhalo - in which case it can never be the primary progenitor.
                descendsToSubhalo=nodes(iNode)%descendentIndex /= nodeList(iIsolatedNode)%node%parent%index()
                ! It does, so set the child pointer of the parent appropriately.
                if (associated(nodeList(iIsolatedNode)%node%parent%firstChild)) then
                   ! A child is already associated. Check if current node does not descend to a subhalo and is more massive.
                   basic        => nodeList(iIsolatedNode)%node                  %basic()
                   basicPrimary => nodeList(iIsolatedNode)%node%parent%firstChild%basic()
                   if (.not.descendsToSubhalo                                          &
                        & .and. (                                                      &
                        &        childIsSubhalo(nodes(iNode)%parent%isolatedNodeIndex) &
                        &         .or.                                                 &
                        &        basic%mass() > basicPrimary%mass()                    &
                        &       )                                                      &
                        & ) then
                      ! It is, so make this the main progenitor.
                      nodeList(iIsolatedNode)%node%sibling           => nodeList(iIsolatedNode)%node%parent%firstChild
                      nodeList(iIsolatedNode)%node%parent%firstChild => nodeList(iIsolatedNode)%node
                      ! Record that the main child is now not a subhalo.
                      childIsSubhalo(nodes(iNode)%parent%isolatedNodeIndex)=.false.
                   else
                      ! It is not, so add after the main child.
                      nodeList(iIsolatedNode)%node%sibling                   => nodeList(iIsolatedNode)%node%parent%firstChild%sibling
                      nodeList(iIsolatedNode)%node%parent%firstChild%sibling => nodeList(iIsolatedNode)%node
                   end if
                else
                   ! No child is currently associated. Simply point to the current node.
                   nodeList(iIsolatedNode)%node%parent%firstChild => nodeList(iIsolatedNode)%node
                   ! Record whether or not this child is a known subhalo or not.
                   childIsSubhalo(nodes(iNode)%parent%isolatedNodeIndex)=descendsToSubhalo
                end if
             end if
          else
             ! Node must be an initial satellite.
             if (associated(nodeList(iIsolatedNode)%node%parent%firstSatellite)) then
                ! The parent halo already has some satellites. Add this one to the list.
                nodeList(iIsolatedNode)%node%sibling               => nodeList(iIsolatedNode)%node%parent%firstSatellite
                nodeList(iIsolatedNode)%node%parent%firstSatellite => nodeList(iIsolatedNode)%node
             else
                ! The parent halo does not yet have any satellites. Simply add this one as the first.
                nodeList(iIsolatedNode)%node%sibling               => null()
                nodeList(iIsolatedNode)%node%parent%firstSatellite => nodeList(iIsolatedNode)%node
             end if
          end if
       end if
    end do
    call deallocateArray(childIsSubhalo)
    return
  end subroutine readBuildChildAndSiblingLinks

  subroutine readAssignHostTreePointers(tree)
    !% After tree base nodes have been assigned, walk each tree and set the host tree pointer for each node.
    use Merger_Tree_Walkers
    implicit none
    type(mergerTree              ), intent(inout), target  :: tree
    type(mergerTree              )               , pointer :: treeCurrent
    type(treeNode                )               , pointer :: node
    type(mergerTreeWalkerAllNodes)                         :: treeWalker

    treeCurrent => tree
    do while(associated(treeCurrent))
       treeWalker=mergerTreeWalkerAllNodes(treeCurrent,spanForest=.false.)
       do while (treeWalker%next(node))
          node%hostTree => treeCurrent
       end do
       treeCurrent => treeCurrent%nextTree
    end do
    return
  end subroutine readAssignHostTreePointers

  subroutine readAssignScaleRadii(self,nodes,nodeList)
    !% Assign scale radii to nodes.
    use Root_Finder
    use Galacticus_Nodes          , only : treeNodeList
    use Galacticus_Display
    use Galacticus_Error
    use Input_Parameters
    implicit none
    class           (mergerTreeConstructorRead        ), target                       , intent(inout) :: self
    class           (nodeData                         )                 , dimension(:), intent(inout) :: nodes                                                                 
    type            (treeNodeList                     )                 , dimension(:), intent(inout) :: nodeList                                                              
    double precision                                   , parameter                                    :: scaleRadiusMaximumAllowed    =100.0d0, toleranceAbsolute  =1.0d-9, & 
         &                                                                                               toleranceRelative            =1.0d-9                                 
    logical                                                       , save                              :: excessiveScaleRadiiReported  =.false.                                
    class           (nodeComponentBasic               ), pointer                                      :: basic                                      
    class           (nodeComponentDarkMatterProfile   ), pointer                                      :: darkMatterProfile
    integer                                                                                           :: iNode                                , status                     , &
         &                                                                                               messageVerbosity
    integer         (c_size_t                         )                                               :: iIsolatedNode                                           
    double precision                                                                                  :: radiusScale                                             
    logical                                                                                           :: excessiveHalfMassRadii               , excessiveScaleRadii        , &
         &                                                                                               useFallbackScaleMethod
    type            (rootFinder                       )           , save                              :: finder                                                     
    !$omp threadprivate(finder)
    type            (varying_string                   )                                               :: message
    character       (len=16                           )                                               :: label

    ! Initialize our root finder.
    if (.not.finder%isInitialized()) then
       call finder%rootFunction(readRadiusHalfMassRoot              )
       call finder%tolerance   (toleranceAbsolute,toleranceRelative)
    end if
    readSelf => self
    ! Find the scale radius.
    excessiveScaleRadii   =.false.
    excessiveHalfMassRadii=.false.
    do iNode=1,size(nodes)
       ! Only process if this is an isolated node.
       if (nodes(iNode)%isolatedNodeIndex /= readNodeReachabilityUnreachable) then
          iIsolatedNode=nodes(iNode)%isolatedNodeIndex
          ! Assume that we need to use a fallback method to set halo scale radius.
          useFallbackScaleMethod=.true.
          ! Check if the node is sufficiently massive.
          basic             => nodeList(iIsolatedNode)%node%basic            (                 )
          darkMatterProfile => nodeList(iIsolatedNode)%node%darkMatterProfile(autoCreate=.true.)          
          if (basic%mass() >= self%presetScaleRadiiMinimumMass) then
             ! Check if we have scale radii read directly from file.
             if     (                                                                        &
                  &     nodes(iNode)%scaleRadius                                             &
                  &   >                                                                      &
                  &     0.0d0                                                                &
                  &  .and.                                                                   &
                  &     nodes(iNode)%scaleRadius                                             &
                  &   <                                                                      &
                  &     self%darkMatterHaloScale_%virialRadius(nodeList(iIsolatedNode)%node) &
                  &    /self%presetScaleRadiiConcentrationMinimum                            &
                  &  .and.                                                                   &
                  &     nodes(iNode)%scaleRadius                                             &
                  &   >                                                                      &
                  &     self%darkMatterHaloScale_%virialRadius(nodeList(iIsolatedNode)%node) &
                  &    /self%presetScaleRadiiConcentrationMaximum                            &
                  & ) then
                ! We do, so simply use them to set the scale radii in tree nodes.
                call darkMatterProfile%scaleSet(nodes(iNode)%scaleRadius)
                useFallbackScaleMethod=.false.
             else if (nodes(iNode)%halfMassRadius > 0.0d0) then
                ! We do not have scale radii read directly. Instead, compute them from half-mass radii.
                ! Set the active node and target half mass radius.
                readNode                       => nodeList(iIsolatedNode)%node
                readDarkMatterProfile => readNode%darkMatterProfile()
                readBasic             => readNode%basic            ()
                readRadiusHalfMass                   =  nodes(iNode)%halfMassRadius
                ! Solve for the scale radius.
                call finder%rangeExpand    (                                                                                   &
                     &                      rangeExpandDownward          =0.5d0                                              , &
                     &                      rangeExpandUpward            =2.0d0                                              , &
                     &                      rangeDownwardLimit           = self%darkMatterHaloScale_%virialRadius(readNode)    &
                     &                                                    /self%presetScaleRadiiConcentrationMaximum         , &
                     &                      rangeUpwardLimit             = self%darkMatterHaloScale_%virialRadius(readNode)    &
                     &                                                    /self%presetScaleRadiiConcentrationMinimum         , &
                     &                      rangeExpandDownwardSignExpect=rangeExpandSignExpectPositive                      , &
                     &                      rangeExpandUpwardSignExpect  =rangeExpandSignExpectNegative                      , &
                     &                      rangeExpandType              =rangeExpandMultiplicative                            &
                     &                     )                
                radiusScale=finder%find(rootGuess=readRadiusHalfMass,status=status)
                if (status == errorStatusSuccess) then
                   call darkMatterProfile%scaleSet(radiusScale)
                   ! Check for scale radii exceeding the virial radius.
                   if (radiusScale        > self%darkMatterHaloScale_%virialRadius(readNode)) excessiveScaleRadii   =.true.
                   ! Check for half-mass radii exceeding the virial radius.
                   if (readRadiusHalfMass > self%darkMatterHaloScale_%virialRadius(readNode)) excessiveHalfMassRadii=.true.
                   useFallbackScaleMethod=.false.
                else
                   if (self%scaleRadiiFailureIsFatal) then
                      messageVerbosity=Galacticus_Verbosity_Level()
                   else
                      messageVerbosity=verbosityWarn
                   end if
                   call Galacticus_Display_Indent  ("failed to find scale radius consistent with specified half-mass radius",messageVerbosity)
                   write (label,'(i16)') readNode%hostTree%index
                   message="      tree index: "//trim(label)
                   call Galacticus_Display_Message(message,messageVerbosity)
                    write (label,'(i16)') readNode%index()
                   message="      node index: "//trim(label)
                   call Galacticus_Display_Message(message,messageVerbosity)
                   write (label,'(e12.6)') self%darkMatterHaloScale_%virialRadius(readNode)
                   message="   virial radius: "//trim(label)
                   call Galacticus_Display_Message(message,messageVerbosity)
                   write (label,'(e12.6)') readRadiusHalfMass
                   message="half-mass radius: "//trim(label)
                   call Galacticus_Display_Message(message,messageVerbosity)
                   call Galacticus_Display_Unindent("",messageVerbosity)
                   if (self%scaleRadiiFailureIsFatal) then
                      call Galacticus_Error_Report('problem with half-mass radii - see report above - aborting'//{introspection:location})
                   else 
                     useFallbackScaleMethod=.true.
                   end if
                end if
             end if
          end if
          if (useFallbackScaleMethod) then
             ! The node mass is below the reliability threshold, or no scale information is available. Set the scale radius using
             ! the fallback concentration method.
             readNode => nodeList(iIsolatedNode)%node
             radiusScale=max(                                                                                                         &
                  &          min(                                                                                                     &
                  &              self%darkMatterProfileScaleRadius_%radius(nodeList(iIsolatedNode)%node)                            , &
                  &              self%darkMatterHaloScale_         %virialRadius(readNode)/self%presetScaleRadiiConcentrationMinimum  &
                  &             )                                                                                                   , &
                  &              self%darkMatterHaloScale_         %virialRadius(readNode)/self%presetScaleRadiiConcentrationMaximum  &
                  &         )
             call darkMatterProfile%scaleSet(radiusScale)
          end if
       end if
    end do
    ! Report warning on excessive scale radii if not already done.
    if (excessiveScaleRadii.and..not.excessiveScaleRadiiReported) then
       excessiveScaleRadiiReported=.true.
       call Galacticus_Display_Message('warning - some scale radii exceed the corresponding virial radii - suggests&
            & inconsistent definitions of halo mass/radius'//{introspection:location},verbosityWarn)
    end if

    ! Exit on excessive half mass radii.
    if (excessiveHalfMassRadii) call Galacticus_Error_Report('some half mass radii exceed corresponding virial radii'//{introspection:location})

    return
  end subroutine readAssignScaleRadii

  subroutine readAssignSpinParameters(self,nodes,nodeList)
    !% Assign spin parameters to nodes.
    use Numerical_Constants_Physical
    use Galacticus_Error
    use Galacticus_Nodes            , only : treeNodeList, nodeComponentSpin
    implicit none
    class           (mergerTreeConstructorRead)                       , intent(inout) :: self
    class           (nodeData                 )         , dimension(:), intent(inout) :: nodes              
    type            (treeNodeList             )         , dimension(:), intent(inout) :: nodeList           
    class           (nodeComponentBasic       ), pointer                              :: basic 
    class           (nodeComponentSpin        ), pointer                              :: spin_  
    integer                                                                           :: iNode              
    integer         (c_size_t                 )                                       :: iIsolatedNode      
    double precision                                                                  :: spin
    double precision                                    , dimension(3)                :: spin3D               
    
    do iNode=1,size(nodes)
       ! Only process if this is an isolated node.
       if (nodes(iNode)%isolatedNodeIndex /= readNodeReachabilityUnreachable) then
          iIsolatedNode=nodes(iNode)%isolatedNodeIndex
          ! Get basic and spin components.
          basic => nodeList(iIsolatedNode)%node%basic(                 )
          spin_  => nodeList(iIsolatedNode)%node%spin (autoCreate=.true.)
          if (self%presetSpins  ) then
             if      (self%mergerTreeImporter_%          spinAvailable()) then
                ! If spins are available directly, use them.
                call spin_%spinSet(nodes(iNode)%spin)
             else if (self%mergerTreeImporter_%angularMomentaAvailable()) then
                spin  = spinNormalization()          &
                     & *nodes(iNode)%angularMomentum
                call spin_%spinSet(spin)
             else
                call Galacticus_Error_Report('no method exists to set spins'//{introspection:location})
             end if
             if (self%presetUnphysicalSpins.and.spin_%spin() <= 0.0d0) &
                  & call spin_%spinSet(self%haloSpinDistribution_%sample(nodeList(iIsolatedNode)%node))
          end if
          if (self%presetSpins3D) then
             if      (self%mergerTreeImporter_%          spin3DAvailable()) then
                ! If spins are available directly, use them.
                call spin_%spinVectorSet(nodes(iNode)%spin3D)
             else if (self%mergerTreeImporter_%angularMomenta3DAvailable()) then
                spin3D= spinNormalization()            &
                     & *nodes(iNode)%angularMomentum3D
                call spin_%spinVectorSet(spin3D)
             else
                call Galacticus_Error_Report('no method exists to set vector spins'//{introspection:location})
             end if
          end if
       end if
    end do
    return
    
  contains
    
    double precision function spinNormalization()
      !% Normalization for conversion of angular momentum to spin.
      implicit none
      spinNormalization= sqrt(abs(self%darkMatterProfileDMO_%energy(nodeList(iIsolatedNode)%node))) &
           &            /gravitationalConstantGalacticus                                            &
           &            /basic%mass()**2.5d0
      return
    end function spinNormalization
    
  end subroutine readAssignSpinParameters
  
  subroutine readAssignNamedProperties(self,nodes,nodeList)
    !% Assign named properties to nodes.
    use Galacticus_Error
    use Galacticus_Nodes , only : treeNodeList, nodeComponentNBody, nodeComponentNBodyGeneric
    implicit none
    class  (mergerTreeConstructorRead)                       , intent(inout) :: self
    class  (nodeData                 )         , dimension(:), intent(inout) :: nodes              
    type   (treeNodeList             )         , dimension(:), intent(inout) :: nodeList           
    class  (nodeComponentNBody       ), pointer                              :: nBody
    integer                                                                  :: iNode        , i    
    integer(c_size_t                 )                                       :: iIsolatedNode      

    do iNode=1,size(nodes)
       ! Only process if this is an isolated node.
       if (nodes(iNode)%isolatedNodeIndex /= readNodeReachabilityUnreachable) then
          iIsolatedNode=nodes(iNode)%isolatedNodeIndex
          ! Get N-body component.
          nBody => nodeList(iIsolatedNode)%node%nBody(autoCreate=.true.)
          ! Assign the named properties.
          select type (nBody)
          class is (nodeComponentNBodyGeneric)
             if (size(self%presetNamedReals   ) > 0) then
                do i=1,size(self%presetNamedReals   )
                   call nBody%setRealProperty   (self%indexNamedReals   (i),nodes(iNode)%reals   (i))
                end do
             end if
             if (size(self%presetNamedIntegers) > 0) then
                do i=1,size(self%presetNamedIntegers)
                   call nBody%setIntegerProperty(self%indexNamedIntegers(i),nodes(iNode)%integers(i))
                end do
             end if
          class default
             call Galacticus_Error_Report('presetting of named datasets is supported only with the "generic" N-body component'//{introspection:location})
          end select
       end if
    end do
    return
  end subroutine readAssignNamedProperties
  
  double precision function readRadiusHalfMassRoot(radius)
    !% Function used to find scale radius of dark matter halos given their half-mass radius.
    implicit none
    double precision, intent(in   ) :: radius 

    ! Set scale radius to current guess.
    call readDarkMatterProfile%scaleSet(radius)
    ! Compute difference between mass fraction enclosed at half mass radius and one half.
    readRadiusHalfMassRoot=readSelf%darkMatterProfileDMO_%enclosedMass(readNode,readRadiusHalfMass)/readBasic%mass()-0.50d0
    return
  end function readRadiusHalfMassRoot

  subroutine readAssignIsolatedNodeIndices(nodes)
    !% Assign to each node the number of the corresponding isolated node.
    implicit none
    class  (nodeData), dimension(:), intent(inout) :: nodes         
    class  (nodeData), pointer                     :: node      
    integer(c_size_t)                              :: iIsolatedNode 
    integer                                        :: iNode         
    logical                                        :: endOfBranch   
    
    ! First make a copy of the currently assigned isolated node indices. These will be used
    ! later to reference the nodes which are the primary node associated with objects in nodeList.
    nodes%primaryIsolatedNodeIndex=nodes%isolatedNodeIndex
    ! Iterate over nodes.
    do iNode=1,size(nodes)
       ! Only process if this is an isolated node.
       if (nodes(iNode)%isolatedNodeIndex /= readNodeReachabilityUnreachable) then
          iIsolatedNode=nodes(iNode)%isolatedNodeIndex
          ! Find the subset with descendents.
          if (associated(nodes(iNode)%descendent)) then
             ! Select the subset which have a subhalo as a descendent.
             if (nodes(iNode)%descendent%isSubhalo) then
                ! Trace descendents until merging or final time.
                node   => nodes(iNode)%descendent
                endOfBranch=  .false.
                do while (.not.endOfBranch)
                   ! Record that this node was reachable via descendents of an isolated node.
                   if (node%isolatedNodeIndex == readNodeReachabilityUnreachable) node%isolatedNodeIndex=readNodeReachabilityReachable
                   if (.not.associated(node%descendent)) then
                      ! If there is no descendent then the end of the branch has been reached.
                      endOfBranch=.true.
                   else
                      ! Step to the next descendent.
                      node => node%descendent
                   end if
                end do
             end if
          end if
       end if
    end do
    return
  end subroutine readAssignIsolatedNodeIndices

  subroutine readScanForMergers(self,nodes,nodeList,historyCountMaximum)
    !% Scan for and record mergers between nodes.
    use Vectors
    use Kepler_Orbits
    use String_Handling
    use Galacticus_Error
    use Galacticus_Nodes , only : treeNodeList, nodeComponentSatellite, nodeComponentPosition
    implicit none
    class           (mergerTreeConstructorRead)                         , intent(inout) :: self
    class           (nodeData                 ), target   , dimension(:), intent(inout) :: nodes                                                                
    type            (treeNodeList             )           , dimension(:), intent(inout) :: nodeList                                                             
    integer         (c_size_t                 )                         , intent(  out) :: historyCountMaximum                                                  
    class           (nodeData                 ), pointer                                :: lastSeenNode                      , progenitorNode            , & 
         &                                                                                 node                                                          
    type            (treeNode                 ), pointer                                :: firstProgenitor                   , hostNode                  , & 
         &                                                                                 orbitalPartner                    , satelliteNode                 
    double precision                                      , dimension(3)                :: hostPosition                      , relativePosition          , & 
         &                                                                                 satellitePosition                                                 
    double precision                                      , dimension(3)                :: hostVelocity                      , relativeVelocity          , & 
         &                                                                                 satelliteVelocity                                                 
    logical                                    , parameter                              :: acceptUnboundOrbits       =.false.                                
    integer                                    , parameter                              :: passAssign                =1      , passMerge               =2
    class           (nodeComponentBasic       ), pointer                                :: basicChild                        , basicOrbitalPartner       , & 
         &                                                                                 basicSatellite                    , basic              
    class           (nodeComponentPosition    ), pointer                                :: positionChild                     , positionHost              , & 
         &                                                                                 positionSatellite                 , position           
    class           (nodeComponentSatellite   ), pointer                                :: satelliteSatellite                , satellite          
    type            (keplerOrbit              )                                         :: orbit                                                         
    integer                                                                             :: iNode                             , pass_
    integer         (c_size_t                 )                                         :: historyCount                      , iIsolatedNode                 
    integer         (kind_int8                )                                         :: progenitorMassMaximumIndex
    logical                                                                             :: branchMerges                      , branchTipReached          , & 
         &                                                                                 endOfBranch                       , isolatedProgenitorExists  , & 
         &                                                                                 nodeWillMerge                                                     
    double precision                                                                    :: radiusApocenter                   , radiusPericenter          , & 
         &                                                                                 radiusVirial                      , timeSubhaloMerges         , &
         &                                                                                 progenitorMassMaximum
    type            (varying_string           )                                         :: message                                                              
    type            (progenitorIterator       )                                         :: progenitors                                                          
    
    ! Initialize.
    historyCountMaximum  = 0
    nodes%mergesWithIndex=-1
    ! First pass assigns isolated node indices to all descendents, second pass finds mergers.
    do pass_=passAssign,passMerge
       do iNode=1,size(nodes)
          if (nodes(iNode)%primaryIsolatedNodeIndex /= readNodeReachabilityUnreachable) then
             iIsolatedNode=nodes(iNode)%primaryIsolatedNodeIndex
             ! Find the subset with descendents.
             if (associated(nodes(iNode)%descendent)) then
                ! Flag indicating if this is a node for which a merging time should be set.
                nodeWillMerge=.false.
                ! Select the subset which have a subhalo, or which are an initial subhalo.
                if (nodes(iNode)%descendent%isSubhalo.or.nodes(iNode)%isSubhalo) then
                   ! Trace descendents until merging or final time.
                   endOfBranch     =.false.
                   branchTipReached=.false.
                   branchMerges    =.false.
                   historyCount    =0
                   if (nodes(iNode)%isSubhalo) then
                      node => nodes(iNode)
                   else
                      ! Check for an immediate subhalo-subhalo merger.
                      if (self%isSubhaloSubhaloMerger(nodes,nodes(iNode))) then
                         endOfBranch =.true.
                         branchMerges=.true.
                         nodes(iNode)%mergesWithIndex=nodes(iNode)%descendent%nodeIndex
                         historyCount=historyCount+max(0_kind_int8,self%mergerTreeImporter_%subhaloTraceCount(nodes(iNode)))
                      end if
                      lastSeenNode => nodes(iNode)
                      node     => nodes(iNode)%descendent
                   end if
                   do while (.not.endOfBranch)
                      ! Record which isolated node this node belongs to.
                      node%isolatedNodeIndex=iIsolatedNode
                      ! Increment the history count for this branch.
                      historyCount=historyCount+1
                      ! Test the branch.
                      if (.not.associated(node%descendent)) then
                         ! No descendent, indicating tip of branch has been reached
                         branchTipReached            =.true.
                         endOfBranch                 =.true.
                         historyCount                =historyCount+max(0_kind_int8,self%mergerTreeImporter_%subhaloTraceCount(node))
                      else if (.not.node%descendent%isSubhalo) then
                         ! Descendent is not a subhalo, treat as a merging event or a subhalo promotion.
                         endOfBranch                 =.true.
                         historyCount                =historyCount+max(0_kind_int8,self%mergerTreeImporter_%subhaloTraceCount(node))
                         ! Search for any isolated progenitors of the node's descendent.
                         isolatedProgenitorExists=.false.
                         call progenitors%descendentSet(self,node%descendent,nodes)
                         progenitorMassMaximum=-1.0d0
                         progenitorMassMaximumIndex=-1_kind_int8
                         do while (progenitors%next(nodes) .and. .not.isolatedProgenitorExists)
                            progenitorNode => progenitors%current(nodes)
                            isolatedProgenitorExists=(progenitorNode%nodeIndex == progenitorNode%hostIndex)
                            if (progenitorNode%nodeMass > progenitorMassMaximum) then
                               progenitorMassMaximum     =progenitorNode%nodeMass
                               progenitorMassMaximumIndex=progenitorNode%nodeIndex
                            end if
                         end do
                         ! If an isolated progenitor exists, or this is not the most massive subhalo progenitor, this is a merger
                         ! event. If not, it is a subhalo promotion (which will be handled elsewhere).
                         if (isolatedProgenitorExists .or. progenitorMassMaximumIndex /= node%nodeIndex) then
                            branchMerges                =.true.
                            nodes(iNode)%mergesWithIndex=node%descendent%nodeIndex
                            lastSeenNode                => node
                            node                        => node%descendent
                         end if
                      else
                         ! Merges with another subhalo.
                         call progenitors%descendentSet(self,node%descendent,nodes)
                         do while (progenitors%next(nodes))
                            progenitorNode => progenitors%current(nodes)
                            if     (                                                                          &
                                 &                    progenitorNode%nodeIndex         /= node%nodeIndex      &
                                 &  .and.             progenitorNode%isolatedNodeIndex /= readNodeReachabilityUnreachable   &
                                 &  .and.  associated(progenitorNode%descendent                             ) &
                                 &  .and.             progenitorNode%nodeMass           > node%nodeMass       &
                                 & ) then
                               ! Another node merges into current node's descendent subhalo and is more massive than current
                               ! node. Therefore, class this as a subhalo-subhalo merger.
                               branchMerges                =.true.
                               endOfBranch                 =.true.
                               nodes(iNode)%mergesWithIndex=progenitorNode%descendent%nodeIndex
                               historyCount                =historyCount+max(0_kind_int8,self%mergerTreeImporter_%subhaloTraceCount(node))
                               lastSeenNode                => node
                               node                    => node%descendent
                               exit
                            end if
                         end do
                         ! Step to the next descendent.
                         if (.not.endOfBranch) node => node%descendent
                      end if
                   end do
                   ! If on the isolated node index assigning pass, skip to the next halo.
                   if (pass_ == passAssign) cycle
                   ! Only set a merging time if this node is not the primary progenitor of its parent.
                   if (.not.nodeList(iIsolatedNode)%node%isPrimaryProgenitor()) then
                      ! Record the largest history.
                      historyCountMaximum=max(historyCountMaximum,historyCount)
                      ! Set an appropriate merging time for this subhalo.
                      if      (branchTipReached) then
                         timeSubhaloMerges=satelliteMergeTimeInfinite ! Subhalo never merges, so set merging time to effective infinity.
                      else if (branchMerges    ) then
                         ! Find the time of merging, accounting for any additional (subresolution) time.
                         timeSubhaloMerges=node%nodeTime
                         call self%timeUntilMergingSubresolution(lastSeenNode,nodes,nodeList,iNode,timeSubhaloMerges)
                      else
                         ! Neither the branch tip was reached, not does this branch merge. Therefore, this must be a subhalo which is
                         ! promoted to be an isolated halo. Simply set an infinite merging time as we do not wish this node to merge.
                         timeSubhaloMerges=satelliteMergeTimeInfinite
                      end if
                      ! Flag that this node will merge.
                      nodeWillMerge=.true.
                   end if
                else if (pass_ == passAssign) then
                   ! If on the isolated node index assigning pass, skip to the next halo.
                   cycle
                else if (.not.nodeList(iIsolatedNode)%node%isPrimaryProgenitor()) then
                   ! Descendent is not a subhalo but this node is not the primary progenitor. Assume instantaneous merging.
                   basic => nodeList(iIsolatedNode)%node%basic()
                   timeSubhaloMerges=basic%time()
                   ! Flag that this node will merge.
                   nodeWillMerge=.true.
                   ! Record the node with which the merger occurs.
                   nodes(iNode)%mergesWithIndex=nodes(iNode)%descendent%nodeIndex
                   ! Ensure the history arrays will be large enough to hold data for this node.
                   historyCountMaximum=max(historyCountMaximum,max(0_kind_int8,self%mergerTreeImporter_%subhaloTraceCount(nodes(iNode))))
                   ! Account for any subresolution merging time.
                   call self%timeUntilMergingSubresolution(nodes(iNode),nodes,nodeList,iNode,timeSubhaloMerges)
                end if               
                ! Set a merging time and/or orbit if this node will merge.
                if (self%presetMergerTimes) then
                   ! If the node does not merge set an infinite merging time.
                   if (.not.nodeWillMerge) timeSubhaloMerges=satelliteMergeTimeInfinite
                   ! Store the time of merging for this node and all of its primary progenitors.
                   firstProgenitor => nodeList(iIsolatedNode)%node
                   do while (associated(firstProgenitor))
                      satellite => firstProgenitor%satellite(autoCreate=.true.)
                      call satellite%timeOfMergingSet(timeSubhaloMerges)
                      firstProgenitor => firstProgenitor%firstChild
                   end do
                end if            
             end if
             ! Handle cases where a node jumps to another tree.
             if (pass_ == passMerge .and. self%isOnPushList(nodes(iNode)) .and. self%presetMergerTimes) then
                ! Merger times are to be preset, but this node will be pushed to another tree. We must set its merging time to be
                ! infinite in this case.
                firstProgenitor => nodeList(iIsolatedNode)%node
                do while (associated(firstProgenitor))                   
                   satellite => firstProgenitor%satellite(autoCreate=.true.)
                   call satellite%timeOfMergingSet(satelliteMergeTimeInfinite)
                   firstProgenitor => firstProgenitor%firstChild
                end do
             end if
             ! Set position and velocity if required.
             if (self%presetPositions) then
                position => nodeList(iIsolatedNode)%node%position(autoCreate=.true.)
                call position%positionSet(nodes(iNode)%position)
                call position%velocitySet(nodes(iNode)%velocity)
                ! Detect if the node parent has no isolated child - in which case one will have been made for it using a
                ! direct copy of itself. Note that this is an ugly solution - once trees can handle nodes with no primary
                ! progenitor (but with secondary progenitors) a cleaner test could be used here.
                if (associated(nodeList(iIsolatedNode)%node%firstChild)) then
                   basic      => nodeList(iIsolatedNode)%node           %basic()
                   basicChild => nodeList(iIsolatedNode)%node%firstChild%basic()
                   if (nodeList(iIsolatedNode)%node%uniqueID() == nodeList(iIsolatedNode)%node%firstChild%uniqueID()) then
                      ! Set the position and velocity of the pseudo-primary progenitor here also.
                      positionChild => nodeList(iIsolatedNode)%node%firstChild%position(autoCreate=.true.)
                      call positionChild%positionSet(nodes(iNode)%position)
                      call positionChild%velocitySet(nodes(iNode)%velocity)
                   end if
                end if
             end if
          end if
       end do
    end do
    ! Set orbits.
    if (self%presetOrbits) then
       iIsolatedNode=0
       do iNode=1,size(nodes)
         if (nodes(iNode)%primaryIsolatedNodeIndex /= readNodeReachabilityUnreachable) then
             iIsolatedNode=nodes(iNode)%primaryIsolatedNodeIndex
             ! Set the orbit for this halo.
             satelliteNode => nodeList(iIsolatedNode)%node
             if (associated(satelliteNode%parent).and..not.satelliteNode%isPrimaryProgenitor()) then
                ! Find the orbital partner.
                hostNode => satelliteNode%parent%firstChild
                ! If the parent node has no progenitors, then we are forced to use the parent node
                ! itself as the orbital partner.
                if (associated(hostNode)) then
                   orbitalPartner => hostNode     %parent
                else
                   hostNode       => satelliteNode%parent
                   orbitalPartner => hostNode
                end if
                ! Get components.
                basicSatellite      => satelliteNode             %basic    (                 )
                positionSatellite   => satelliteNode             %position (                 )
                satelliteSatellite  => satelliteNode             %satellite(autoCreate=.true.)
                positionHost        => hostNode                  %position (                 )
                basicOrbitalPartner => orbitalPartner            %basic    (                 )
                ! Get position and velocity.
                satellitePosition            =  positionSatellite%position (                 )
                satelliteVelocity            =  positionSatellite%velocity (                 )
                hostPosition                 =       positionHost%position (                 )
                hostVelocity                 =       positionHost%velocity (                 )
                ! Find relative position and velocity.
                relativePosition=satellitePosition-hostPosition
                relativeVelocity=satelliteVelocity-hostVelocity
                ! Update position/velocity for periodicity and Hubble flow.
                call self%phaseSpacePositionRealize(basicSatellite%time(),relativePosition,relativeVelocity)
                ! Catch zero separation halos.
                if (Vector_Magnitude(relativePosition) == 0.0d0) then
                   if (self%presetOrbitsSetAll) then
                      ! The satellite and host have zero separation, so no orbit can be
                      ! computed. Since all orbits must be set, choose an orbit at random.
                      orbit=self%virialOrbit_%orbit(satelliteNode,hostNode,acceptUnboundOrbits)
                      call satelliteSatellite%virialOrbitSet(orbit)
                   else
                      message='merging halos ['
                      message=message//satelliteNode%index()//' & '//hostNode%index()//'] have zero separation'
                      call Galacticus_Error_Report(message//{introspection:location})
                   end if
                else
                   ! Create the orbit.
                   orbit=readOrbitConstruct(basicSatellite%mass(),basicOrbitalPartner%mass(),relativePosition,relativeVelocity)
                   ! Propagate to the virial radius.
                   radiusPericenter=orbit               %radiusPericenter(              )
                   radiusApocenter =orbit               %radiusApocenter (              )
                   radiusVirial    =self%darkMatterHaloScale_%virialRadius    (orbitalPartner)
                   ! Check if the orbit intersects the virial radius.
                   if     (                                                                      &
                        &    radiusVirial >= radiusPericenter                                    &
                        &  .and.                                                                 &
                        &   (radiusVirial <= radiusApocenter          .or. .not.orbit%isBound()) &
                        &  .and.                                                                 &
                        &   (.not.self%presetOrbitsBoundOnly .or.      orbit%isBound()) &
                        & ) then
                      call orbit%propagate(radiusVirial,infalling=.true.)
                      ! Set the orbit.
                      call satelliteSatellite%virialOrbitSet(orbit)
                      ! If the satellite component supports full phase-space position, set that
                      ! also.
                      if (satelliteSatellite%positionIsSettable()) call satelliteSatellite%positionSet(relativePosition)
                      if (satelliteSatellite%velocityIsSettable()) call satelliteSatellite%velocitySet(relativeVelocity)
                   else if (self%presetOrbitsSetAll) then
                      ! The given orbit does not cross the virial radius. Since all orbits must be set, choose an orbit at random.
                      orbit=self%virialOrbit_%orbit(satelliteNode,hostNode,acceptUnboundOrbits)
                      call satelliteSatellite%virialOrbitSet(orbit)
                   else if (self%presetOrbitsAssertAllSet) then
                      message='virial orbit could not be set for node '
                      message=message//satelliteNode%index()//char(10)
                      message=message//' -> set [presetOrbitsAssertAllSet]=false to ignore this problem'//char(10)
                      message=message//'    (this may lead to other problems)'
                      call Galacticus_Error_Report(message//{introspection:location})
                   end if
                end if
             end if
          end if
       end do
    end if
    return
  end subroutine readScanForMergers

  subroutine readAssignMergers(self,nodes,nodeList)
    !% Assign pointers to merge targets.
    use Galacticus_Error
    use String_Handling
    use Galacticus_Nodes, only : treeNodeList
    implicit none
    class  (mergerTreeConstructorRead)              , intent(inout) :: self
    class  (nodeData                 ), dimension(:), intent(inout) :: nodes    
    type   (treeNodeList             ), dimension(:), intent(inout) :: nodeList 
    integer                                                         :: iNode    
    integer(c_size_t                 )                              :: jNode    
    type   (varying_string           )                              :: message  
    
    if (self%presetMergerNodes) then
       do iNode=1,size(nodes)
          ! Check if this node was flagged as merging with another node.
          if (nodes(iNode)%mergesWithIndex /= -1) then
             ! Search for the node that it merges with.
             jNode=self%nodeLocation(nodes(iNode)%mergesWithIndex)
             if (nodes(jNode)%isolatedNodeIndex <= 0) then
                ! This node does not belong to any isolated halo - this should not happen.
                message='subhalo-subhalo ['
                message=message//nodes(iNode)%nodeIndex//":"//nodes(jNode)%nodeIndex
                message=message//'] merger in which subhalo has no isolated node progenitor - this should not happen'
                call Galacticus_Error_Report(message//{introspection:location})
             else
                ! Set pointer from merging node (a.k.a. the "mergee") to node that will be merged with.
                nodeList(nodes(iNode)%isolatedNodeIndex)%node%mergeTarget => nodeList(nodes(jNode)%isolatedNodeIndex)%node
                ! Make a backward pointer from the merge target to the mergee. Check if the target already has mergees associated with it.
                if (associated(nodeList(nodes(jNode)%isolatedNodeIndex)%node%firstMergee)) then
                   ! It does: unlink them and attached to the "siblingMergee" pointer of the current mergee.
                   nodeList(nodes(iNode)%isolatedNodeIndex)%node%siblingMergee => nodeList(nodes(jNode)%isolatedNodeIndex)%node%firstMergee
                else
                   ! It does not: simply nullify the next mergee pointer of the mergee.
                   nodeList(nodes(iNode)%isolatedNodeIndex)%node%siblingMergee => null()
                end if
                ! Append the mergee as the first mergee on the target node.
                nodeList(nodes(jNode)%isolatedNodeIndex)%node%firstMergee => nodeList(nodes(iNode)%isolatedNodeIndex)%node
             end if
          end if
       end do
    end if
    return
  end subroutine readAssignMergers

  subroutine readScanForBranchJumps(self,nodes,nodeList)
    !% Search for subhalos which move between branches/trees.
    use ISO_Varying_String
    use String_Handling
    use Galacticus_Display
    use Galacticus_Nodes  , only : treeNodeList
    implicit none
    class           (mergerTreeConstructorRead)              , intent(inout)          :: self
    class           (nodeData                 ), dimension(:), intent(inout), target  :: nodes                                                        
    type            (treeNodeList             ), dimension(:), intent(inout)          :: nodeList                                                     
    class           (nodeData                 )                             , pointer :: currentHost  , descendentNode  , hostDescendent      , jumpToHost, & 
         &                                                                               previousNode , isolatedHostNode, isolatedHostHostNode                                             
    integer                                                                           :: iNode                                                        
    integer         (c_size_t                 )                                       :: iIsolatedNode                                                
    logical                                                                           :: isMergerEvent, subhaloJumps    , wasMergerEvent                
    double precision                                                                  :: timeOfJump                                                   
    type            (varying_string           )                                       :: message                                                      
    
    ! If branch jumps are not allowed, simply return.
    if (.not.self%allowBranchJumps) return
    ! Search for subhalos whose descendents live in a different host than that to which their
    ! host descends. These subhalos are jumping between tree branches (or between trees). Add
    ! an event to such nodes to handle the jump.
    do iNode=1,size(nodes)
       ! Only process if this is an isolated node (or an initial satellite).
       if (nodes(iNode)%primaryIsolatedNodeIndex /= readNodeReachabilityUnreachable) then
          iIsolatedNode=nodes(iNode)%primaryIsolatedNodeIndex
          ! Find those which are a subhalo, or whose descendent is a subhalo.
          descendentNode => null()
          if      (           nodes(iNode)%isSubhalo  ) then
             descendentNode => nodes(iNode)
             previousNode   => nodes(iNode)
          else if (associated(nodes(iNode)%descendent)) then
             if (nodes(iNode)%descendent%isSubhalo) then
                descendentNode => nodes(iNode)%descendent
                previousNode   => nodes(iNode)
             end if
          end if
          ! Check for an immediate subhalo-subhalo merger. If found, nullify the descendent,
          ! so we do not attempt to process this branch.
          if (self%isSubhaloSubhaloMerger(nodes,nodes(iNode))) then
             descendentNode => null()
             currentHost    => readLastHostDescendent(nodes(iNode))
             ! Add a jump if the tree ends before the descendent time.
             if (currentHost%nodeTime <= nodes(iNode)%descendent%nodeTime) then
                timeOfJump     =  currentHost%nodeTime
                jumpToHost     => nodes(iNode)%descendent%host
                do while (jumpToHost%isSubhalo)
                   if (.not.self%warningNestedHierarchyIssued) then
                      message='nested hierarchy detected [node '
                      message=message//nodes(iNode)%descendent%nodeIndex//']'
                      message=message//char(10)//'ignoring as not currently supported'
                      message=message//char(10)//'warning will not be issued again'
                      call Galacticus_Display_Message(message,verbosityWarn)
                      self%warningNestedHierarchyIssued=.true.
                   end if
                   jumpToHost => jumpToHost%host
                end do
                call readCreateBranchJumpEvent(                                                    &
                     &                        nodeList(iIsolatedNode                      )%node, &
                     &                        nodeList(jumpToHost%primaryIsolatedNodeIndex)%node, &
                     &                        timeOfJump                                          &
                     &                       )
             end if
          end if
          ! If a subhalo was found, follow its descent.
          wasMergerEvent=.false.
          do while (associated(descendentNode))
             subhaloJumps=.false.
             timeOfJump  =-1.0d0
             if (descendentNode%isSubhalo.and.associated(descendentNode%descendent)) then
                ! Determine if this is actually a merger event rather than a branch jump.
                ! Assume it is not a merger initially.
                isMergerEvent=.false.
                if (descendentNode%descendent%isSubhalo) then
                   ! Descendent is a subhalo. Check for subhalo-subhalo merger.
                   if (self%isSubhaloSubhaloMerger(nodes,previousNode)) isMergerEvent=.true.
                else
                   ! Descendent is not a subhalo, so this must be a merger event.
                   isMergerEvent=.true.
                end if
                ! If this is a merger event, then check that the current descendent's host has a
                ! descendent that exists beyond the time of the merger. If it does not, then we
                ! still need to allow our node to jump branches (if necessary) as it will not be
                ! able to evolve in the descendentless host.
                wasMergerEvent=isMergerEvent
                if (isMergerEvent) then
                   currentHost => readLastHostDescendent(descendentNode)
                   if (currenthost%nodeTime <= descendentNode%descendent%nodeTime) then
                      isMergerEvent=.false.
                      timeOfJump=currentHost%nodeTime
                   endif
                end if
                ! Proceed only if this is not a merger event.
                if (.not.isMergerEvent) then
                   ! Does this subhalo's descendent live in the host to which the subhalo's host descends.
                   if (.not.associated(descendentNode%host%descendent)) then
                      ! Host has no descendent, so this must be a branch jump.
                      subhaloJumps=.true.
                   else
                      ! In nested hierarchies we must find the isolated node which hosts our node and our node's host.
                      isolatedHostNode     => descendentNode     %descendent%host
                      do while (associated(isolatedHostNode    %host).and..not.associated(isolatedHostNode    %host,isolatedHostNode    ))
                         isolatedHostNode     => isolatedHostNode    %host
                      end do
                      isolatedHostHostNode => descendentNode%host%descendent%host
                      do while (associated(isolatedHostHostNode%host).and..not.associated(isolatedHostHostNode%host,isolatedHostHostNode))
                         isolatedHostHostNode => isolatedHostHostNode%host
                      end do
                      if (isolatedHostNode%nodeIndex /= isolatedHostHostNode%nodeIndex) then
                         ! Host has a descendent, but its host is not the same as our descendent's host.
                         subhaloJumps=.true.
                         ! Check that is not simply a case of the subhalo skipping one or more timesteps before
                         ! reappearing in the expected host.
                         hostDescendent => isolatedHostHostNode
                         if (isolatedHostNode%nodeTime > hostDescendent%nodeTime) then
                            ! Handle cases where the subhalo skipped one or more timesteps.
                            do while (isolatedHostNode%nodeTime > hostDescendent%nodeTime)
                               if (associated(hostDescendent%descendent)) then
                                  hostDescendent => hostDescendent%descendent%host
                                  ! In nested hierarchies, find the isolated host node.
                                  do while (associated(hostDescendent%host).and..not.associated(hostDescendent%host,hostDescendent))
                                     hostDescendent => hostDescendent%host
                                  end do
                               else
                                  exit
                               end if
                            end do
                         else if (isolatedHostNode%nodeTime < hostDescendent%nodeTime) then
                            ! Handle cases where the host skipped one or more timesteps.
                            do while (isolatedHostNode%nodeTime < hostDescendent%nodeTime)
                               if (associated(isolatedHostNode%descendent)) then
                                  isolatedHostNode => isolatedHostNode%descendent%host
                                  ! In nested hierarchies, find the isolated host node.
                                  do while (associated(isolatedHostNode%host).and..not.associated(isolatedHostNode%host,isolatedHostNode))
                                     isolatedHostNode => isolatedHostNode%host
                                  end do
                               else
                                  exit
                               end if
                            end do
                         end if
                         ! Subhalo reappeared in the expected host. This is not a branch jump.
                         if (isolatedHostNode%nodeIndex == hostDescendent%nodeIndex) subhaloJumps=.false.
                      end if
                   end if
                else
                   ! Since this is a merger event, we're finished checking this branch.
                   exit
                end if
             end if
             ! If a jump was detected, create an event.
             if (subhaloJumps) then
                if (timeOfJump < 0.0d0)                   &
                     & timeOfJump=descendentNode%nodeTime
                jumpToHost => descendentNode%descendent%host                
                ! Find an isolated host.
                do while (jumpToHost%isSubhalo)
                   jumpToHost => jumpToHost%host
                end do
                call readCreateBranchJumpEvent(                                                    &
                     &                        nodeList(iIsolatedNode                      )%node, &
                     &                        nodeList(jumpToHost%primaryIsolatedNodeIndex)%node, &
                     &                        timeOfJump                                          &
                     &                       )
             end if
             ! Move to the descendent.
             previousNode   => descendentNode
             descendentNode => descendentNode%descendent
             ! If the descendent is not a subhalo, then we're finished checking this branch.
             if (associated(descendentNode)) then
                if (.not.descendentNode%isSubhalo) exit
             end if
             ! If this was a merger event, then we're finished checking this branch.
             if (wasMergerEvent) exit
          end do
       end if
    end do
    return
  end subroutine readScanForBranchJumps

  function readLastHostDescendent(node) result (currentHost)
    !% Return a pointer to the last descendent that can be reached from {\normalfont \ttfamily node} when descending through hosts.
    implicit none
    class(nodeData), pointer               :: currentHost 
    class(nodeData), intent(inout), target :: node    
    
    currentHost => node%host
    do while(associated(currentHost%descendent))
       currentHost => currentHost%descendent%host
    end do
    return
  end function readLastHostDescendent

  subroutine readCreateBranchJumpEvent(node,jumpToHost,timeOfJump)
    !% Create a matched-pair of branch jump events in the given nodes.
    use Galacticus_Nodes , only : nodeEvent, nodeEventBranchJump
    use Node_Branch_Jumps
    implicit none
    type            (treeNode ), intent(inout), pointer :: jumpToHost, node  
    double precision           , intent(in   )          :: timeOfJump            
    class           (nodeEvent)               , pointer :: newEvent  , pairEvent 

    allocate(nodeEventBranchJump ::  newEvent)
    allocate(nodeEventBranchJump :: pairEvent)
    call node  %attachEvent( newEvent)
    call jumpToHost%attachEvent(pairEvent)
    newEvent %time =  timeOfJump
    newEvent %node => jumpToHost
    newEvent %task => Node_Branch_Jump
    pairEvent%time =  timeOfJump
    pairEvent%node => node
    pairEvent%task => null()
    pairEvent%ID   =  newEvent%ID
    return
  end subroutine readCreateBranchJumpEvent

  subroutine readBuildSubhaloMassHistories(self,nodes,nodeList,historyCountMaximum,historyTime,historyIndex,historyMass,position,velocity)
    !% Build and attached bound mass histories to subhalos.
    use Galacticus_Error
    use String_Handling
    use Histories
    use Galacticus_Nodes, only : treeNodeList, nodeComponentSatellite, nodeComponentPosition, defaultSatelliteComponent
    implicit none
    class           (mergerTreeConstructorRead)                         , intent(inout) :: self
    class           (nodeData                 ), target , dimension(:  ), intent(inout) :: nodes                                    
    type            (treeNodeList             )         , dimension(:  ), intent(inout) :: nodeList                                 
    integer         (kind_int8                )         , dimension(:  ), intent(inout) :: historyIndex
    integer         (c_size_t                 )                         , intent(in   ) :: historyCountMaximum
    double precision                                    , dimension(:  ), intent(inout) :: historyMass        , historyTime   
    double precision                                    , dimension(:,:), intent(inout) :: position           , velocity      
    class           (nodeData                 ), pointer                                :: progenitorNode     , node      
    class           (nodeComponentSatellite   ), pointer                                :: satellite             
    class           (nodeComponentPosition    ), pointer                                :: position_             
    integer         (c_size_t                 )                                         :: historyCount       , iIsolatedNode 
    integer                                                                             :: iNode                                    
    logical                                                                             :: endOfBranch                              
    type            (varying_string           )                                         :: message                                  
    type            (history                  )                                         :: subhaloHistory                           
    type            (longIntegerHistory       )                                         :: subhaloIndexHistory                           
    type            (progenitorIterator       )                                         :: progenitors
    
    if (self%presetSubhaloMasses.or.self%presetPositions.or.self%presetSubhaloIndices) then
       ! Check that preset subhalo masses are supported.
       if (self%presetSubhaloMasses .and..not.defaultSatelliteComponent%boundMassHistoryIsSettable()) &
            & call Galacticus_Error_Report('presetting subhalo masses requires a component that supports setting of node bound mass histories'//{introspection:location})
       ! Check that preset subhalo masses are supported.
       if (self%presetSubhaloIndices.and..not.defaultSatelliteComponent%nodeIndexHistoryIsSettable()) &
            & call Galacticus_Error_Report('presetting subhalo indices requires a component that supports setting of node index histories'//{introspection:location})
       ! Get the default cosmology functions object.
       historyBuildNodeLoop: do iNode=1,size(nodes)
          historyBuildIsolatedSelect: if (nodes(iNode)%primaryIsolatedNodeIndex /= readNodeReachabilityUnreachable) then
             iIsolatedNode=nodes(iNode)%primaryIsolatedNodeIndex
             ! Find the subset with descendents.
             historyBuildHasDescendentSelect: if (associated(nodes(iNode)%descendent)) then
                ! Set a pointer to the current node - this will be updated if any descendents are traced.
                node => nodes(iNode)
                ! Set initial number of times in the history to zero.
                historyCount=0
                ! Select the subset which have a subhalo as a descendent and are not the primary progenitor or are initial subhalos. Also skip immediate subhalo-subhalo mergers.
                historyBuildSubhaloSelect: if ((nodes(iNode)%descendent%isSubhalo.or.nodes(iNode)%isSubhalo).and..not.self%isSubhaloSubhaloMerger(nodes,nodes(iNode))) then
                   ! Trace descendents until merging or final time.
                   if (nodes(iNode)%isSubhalo) then
                      node => nodes(iNode)
                   else
                      node => nodes(iNode)%descendent
                   end if
                   endOfBranch =.false.
                   historyBuildBranchWalk: do while (.not.endOfBranch)
                      ! Increment the history count for this branch.
                      historyCount=historyCount+1
                      ! Check for history count array size being exceeded.
                      if (historyCount > historyCountMaximum) then
                         message='history array length exceeded for node ['
                         message=message//nodes(iNode)%nodeIndex//'] - this should not happen'
                         call Galacticus_Error_Report(message//{introspection:location})
                      end if
                      ! Store the history.
                      historyTime(historyCount)=node%nodeTime
                      if (self%presetSubhaloIndices) historyIndex(  historyCount)=node%nodeIndex
                      if (self%presetSubhaloMasses ) historyMass (  historyCount)=node%nodeMass
                      if (self%presetPositions     ) position    (:,historyCount)=node%position
                      if (self%presetPositions     ) velocity    (:,historyCount)=node%velocity
                      ! Test the branch.
                      if (.not.associated(node%descendent).or..not.node%descendent%isSubhalo) then
                         ! End of branch reached.
                         endOfBranch=.true.
                      else
                         ! Check if merges with another subhalo.
                         call progenitors%descendentSet(self,node%descendent,nodes)
                         do while (progenitors%next(nodes))
                            progenitorNode => progenitors%current(nodes)
                            if     (                                                                          &
                                 &                    progenitorNode%nodeIndex         /= node%nodeIndex      &
                                 &  .and.             progenitorNode%isolatedNodeIndex /= readNodeReachabilityUnreachable   &
                                 &  .and.  associated(progenitorNode%descendent                             ) &
                                 &  .and.             progenitorNode%nodeMass           > node%nodeMass       &
                                 & ) then
                               ! Subhalo-subhalo merger.
                               endOfBranch =.true.
                               exit
                            end if
                         end do
                         ! Step to the next descendent.
                         if (.not.endOfBranch) node => node%descendent
                      end if
                   end do historyBuildBranchWalk
                   ! Set the mass history for this node.
                   if (self%presetSubhaloMasses) then
                      call subhaloHistory%destroy()
                      call subhaloHistory%create(1,int(historyCount))
                      subhaloHistory%time(:  )=historyTime(1:historyCount)
                      subhaloHistory%data(:,1)=historyMass(1:historyCount)
                      satellite => nodeList(iIsolatedNode)%node%satellite()
                      call satellite%boundMassHistorySet(subhaloHistory)
                   end if
                   ! Set the node index history for this node.
                   if (self%presetSubhaloIndices) then
                      call subhaloIndexHistory%destroy()
                      call subhaloIndexHistory%create(1,int(historyCount))
                      subhaloIndexHistory%time(:  )=historyTime (1:historyCount)
                      subhaloIndexHistory%data(:,1)=historyIndex(1:historyCount)
                      satellite       => nodeList(iIsolatedNode)%node%satellite()
                      call satellite%nodeIndexHistorySet(subhaloIndexHistory)
                   end if
                end if historyBuildSubhaloSelect
                ! Set the position history for this node.
                if (self%presetPositions.and..not.nodeList(iIsolatedNode)%node%isPrimaryProgenitor()) then
                   ! Check if particle data is available for this node.
                   if (self%mergerTreeImporter_%subhaloTraceCount(node) > 0) then
                      ! Check that arrays are large enough to hold particle data. They should be. If they are not, it's a
                      ! bug.
                      if (historyCount+self%mergerTreeImporter_%subhaloTraceCount(node) > size(historyTime)) then
                         message='history arrays are too small to hold data for node '
                         message=message//nodeList(iIsolatedNode)%node%index()//': ['//historyCount//'+'//self%mergerTreeImporter_%subhaloTraceCount(node)//']='//(historyCount+self%mergerTreeImporter_%subhaloTraceCount(node))//'>'//size(historyTime)
                         call Galacticus_Error_Report(message//{introspection:location})
                      end if
                      ! Read subhalo position trace data.
                      call self%mergerTreeImporter_%subhaloTrace                                                           &
                           & (                                                                                    &
                           &  node                                                                              , &
                           &  historyTime(  historyCount+1:historyCount+self%mergerTreeImporter_%subhaloTraceCount(node)), &
                           &  position   (:,historyCount+1:historyCount+self%mergerTreeImporter_%subhaloTraceCount(node)), &
                           &  velocity   (:,historyCount+1:historyCount+self%mergerTreeImporter_%subhaloTraceCount(node))  &
                           & )
                      ! Increment the history count for this node.
                      historyCount=historyCount+self%mergerTreeImporter_%subhaloTraceCount(node)
                   end if
                   if (historyCount > 0) then
                      call subhaloHistory%destroy()
                      call subhaloHistory%create(6,int(historyCount))
                      subhaloHistory%time(:    )=          historyTime(    1:historyCount)
                      subhaloHistory%data(:,1:3)=transpose(position   (1:3,1:historyCount))
                      subhaloHistory%data(:,4:6)=transpose(velocity   (1:3,1:historyCount))
                      position_ => nodeList(iIsolatedNode)%node%position()
                      call position_%positionHistorySet(subhaloHistory)
                   end if
                end if

             end if historyBuildHasDescendentSelect
          end if historyBuildIsolatedSelect
       end do historyBuildNodeLoop
    end if
    return
  end subroutine readBuildSubhaloMassHistories

  subroutine readValidateIsolatedHalos(nodes)
    !% Ensure that nodes have valid primary progenitors.
    implicit none
    class  (nodeData          ), dimension(:), intent(inout) :: nodes                            
    type   (treeNode          ), pointer                     :: nodeNew          , nodeSatellite 
    class  (nodeComponentBasic), pointer                     :: newBasicComponent                
    integer                                                  :: iNode                            
    integer(c_size_t          )                              :: iIsolatedNode                    
    
    ! Search for cases where a node has no progenitors which do not descend into subhalos.
    do iNode=1,size(nodes)
       ! Only process if this is an isolated node.
       if (nodes(iNode)%isolatedNodeIndex /= readNodeReachabilityUnreachable .and. .not.nodes(iNode)%isSubhalo) then
          iIsolatedNode=nodes(iNode)%isolatedNodeIndex
          ! Select nodes with parents.
          if (associated(nodes(iNode)%node%parent)) then
             ! Select nodes with subhalo descendents which are also the primary progenitor of their parent.
             if (nodes(iNode)%descendent%isSubhalo.and.associated(nodes(iNode)%node%parent%firstChild,nodes(iNode)%node)) then
                ! Insert a copy of the parent node as its own primary progenitor. This avoids current node being promoted into its
                ! parent even though it is intended to descend into a subhalo. The copy is shifted to a very slightly earlier
                ! time to avoid having two identical halos existing simultaneously (which can be problematic if outputting
                ! quantities which use the node index as a label in dataset names for example).
                allocate(nodeNew)
                call nodes(iNode)%node%parent%copyNodeTo(nodeNew)
                nodeNew%sibling                         => nodes(iNode)%node
                nodeNew%parent                          => nodes(iNode)%node%parent
                nodeNew%firstChild                      => null()
                nodeNew%mergeTarget                     => null()
                nodeNew%siblingMergee                   => null()
                nodes(iNode)%node%parent%firstChild     => nodeNew
                newBasicComponent                       => nodeNew%basic()
                call newBasicComponent%timeSet(newBasicComponent%time()*(1.0d0-1.0d-6))
                ! Events remain attached to the original and we do not want to duplicate them.
                nodeNew%event => null()
                ! Any satellites are now attached to the copy.
                nodes(iNode)%node%parent%firstSatellite => null()
                nodeSatellite => nodeNew%firstSatellite
                do while (associated(nodeSatellite))
                   nodeSatellite%parent => nodeNew
                   nodeSatellite        => nodeSatellite%sibling
                end do
             end if
          end if
       end if
    end do
    return
  end subroutine readValidateIsolatedHalos

  subroutine readAssignUniqueIDsToClones(nodeList)
    !% Assign new uniqueID values to any cloned nodes inserted into the trees.
    use Galacticus_Nodes, only : treeNodeList
    implicit none
    type   (treeNodeList), dimension(:), intent(inout) :: nodeList 
    integer                                            :: iNode    
    
    do iNode=1,size(nodeList)
       if (associated(nodeList(iNode)%node%firstChild)) then
          if (nodeList(iNode)%node%uniqueID() == nodeList(iNode)%node%firstChild%uniqueID()) &
               &  call nodeList(iNode)%node%firstChild%uniqueIDSet()
       end if
    end do
    return
  end subroutine readAssignUniqueIDsToClones

  logical function readIsSubhaloSubhaloMerger(self,nodes,node)
    !% Returns true if {\normalfont \ttfamily node} undergoes a subhalo-subhalo merger.
    implicit none
    class(mergerTreeConstructorRead)              , intent(inout) :: self
    class(nodeData                 ), dimension(:), intent(inout) :: nodes          
    class(nodeData                 )              , intent(in   ) :: node       
    class(nodeData                 ), pointer                     :: progenitorNode 
    type (progenitorIterator       )                              :: progenitors    
    
    readIsSubhaloSubhaloMerger=.false.
    ! Return immediately if there is no descendent. (Since there can be no merger if there is no descendent.)
    if (.not.associated(node%descendent          )) return
    ! Return immediately if descendent is not a subhalo, as this could then not be a subhalo-subhalo merger.
    if (.not.           node%descendent%isSubhalo ) return
    ! Check if node's descendent has any progenitor nodes.
    call progenitors%descendentSet(self,node%descendent,nodes)
    do while (progenitors%next(nodes))
       progenitorNode => progenitors%current(nodes)
       if     (                                                                          &
            &                    progenitorNode%nodeIndex         /= node%nodeIndex  &
            &  .and.             progenitorNode%isolatedNodeIndex /= readNodeReachabilityUnreachable   &
            &  .and.  associated(progenitorNode%descendent                             ) &
            &  .and.             progenitorNode%nodeMass           > node%nodeMass   &
            & ) then
          ! It does, so this is a subhalo-subhalo merger.
          readIsSubhaloSubhaloMerger =.true.
          exit
       end if
    end do
    return
  end function readIsSubhaloSubhaloMerger

  !$GLC function attributes unused :: readDumpTree
  subroutine readDumpTree(nodes,highlightNodes,branchRoot)
    !% Dumps the tree structure to a file in a format suitable for processing with \href{http://www.graphviz.org/}{\normalfont \scshape dot}.
    implicit none
    class    (nodeData      ), dimension(:), intent(in   ), target   :: nodes                 
    integer  (kind=kind_int8), dimension(:), intent(in   ), optional :: highlightNodes        
    integer  (kind=kind_int8)              , intent(in   ), optional :: branchRoot            
    class    (nodeData      ), pointer                               :: node              
    integer                                                          :: fileUnit      , iNode 
    character(len=20        )                                        :: color         , style 
    logical                                                          :: outputNode
    integer  (kind=kind_int8)                                        :: branchRootHost
    
    ! Open an output file and write the GraphViz opening.
    open(newunit=fileUnit,file='mergerTreeConstructReadTree.gv',status='unknown',form='formatted')
    write (fileUnit,*) 'digraph Tree {'

    ! Identify the host of the branch root.
    if (present(branchRoot)) then
       branchRootHost =  branchRoot
       node       => null()
       do iNode=1,size(nodes)
          if (nodes(iNode)%nodeIndex == branchRootHost) node => nodes(iNode)
       end do
       if (associated(node)) then
          do while (associated(node%host).and..not.associated(node%host,node))
             node => node%host
          end do
          branchRootHost=node%nodeIndex
       end if
    else
       branchRootHost=-1_kind_int8
    end if
    
    ! Loop over all nodes.
    do iNode=1,size(nodes)
       ! Determine if node is in the branch to be output.
       if (present(branchRoot)) then
          outputNode=.false.
          node => nodes(iNode)
          do while (associated(node%host).and..not.associated(node%host,node))
             node => node%host
          end do
          outputNode=node%nodeIndex == branchRootHost
          do while (.not.outputNode.and.associated(node%descendent))
             node => node%descendent
             do while (associated(node%host).and..not.associated(node%host,node))                
                node => node%host
             end do
             outputNode=node%nodeIndex == branchRootHost
          end do
       else
          outputNode=.true.
       end if
       if (outputNode) then
          ! Write each node, setting the node shape to a box for subhalos and a circle for halos. Node label consists of the node
          ! index plus the time, separated by a colon.
          ! Determine node color.
          if (present(highlightNodes)) then
             if (any(highlightNodes == nodes(iNode)%nodeIndex)) then
                color='green'
                style='filled'
             else
                color='black'
                style='solid'
             end if
          else
             color='black'
             style='solid'
          end if
          if (nodes(iNode)%isSubhalo) then
             write (fileUnit,'(a,i20.20,a,i20.20,a,f5.2,a,a,a,a,a,f5.2,a)') '"',nodes(iNode)%nodeIndex,'" [shape=box   , label="',nodes(iNode)%nodeIndex,':',nodes(iNode)%nodeTime,'", color=',trim(color),', style=',trim(style),', z=',nodes(iNode)%nodeTime,'];'
             ! If a host node is given, add a link to it as a red line.
             if (associated(nodes(iNode)%host)) write (fileUnit,'(a,i20.20,a,i20.20,a)') '"',nodes(iNode)%nodeIndex,'" -> "',nodes(iNode)%host%nodeIndex,'" [color=red];'
          else
             write (fileUnit,'(a,i20.20,a,i20.20,a,f5.2,a,a,a,a,a,f5.2,a)') '"',nodes(iNode)%nodeIndex,'" [shape=circle, label="',nodes(iNode)%nodeIndex,':',nodes(iNode)%nodeTime,'", color=',trim(color),', style=',trim(style),', z=',nodes(iNode)%nodeTime,'];'
          endif
          ! Make a link to the descendent node using a black line.
          if (associated(nodes(iNode)%descendent)) write (fileUnit,'(a,i20.20,a,i20.20,a)') '"',nodes(iNode)%nodeIndex,'" -> "',nodes(iNode)%descendent%nodeIndex,'" ;'
       end if
    end do

    ! Close the file.
    write (fileUnit,*) '}'
    close(fileUnit)
    return
  end subroutine readDumpTree
  
  subroutine readTimeUntilMergingSubresolution(self,lastSeenNode,nodes,nodeList,iNode,timeSubhaloMerges)
    !% Compute the additional time until merging after a subhalo is lost from the tree (presumably due to limited resolution).
    use Vectors
    use Kepler_Orbits
    use Galacticus_Error
    use String_Handling
    use Galacticus_Display
    use Galacticus_Nodes , only : treeNodeList, nodeComponentPosition
    implicit none
    class           (mergerTreeConstructorRead)                       , intent(inout) :: self
    class           (nodeData                 )                       , intent(in   ) :: lastSeenNode                                                                      
    class           (nodeData                 ), target , dimension(:), intent(inout) :: nodes                                     
    type            (treeNodeList             )         , dimension(:), intent(inout) :: nodeList
    integer                                                           , intent(in   ) :: iNode                                                                             
    double precision                                                  , intent(inout) :: timeSubhaloMerges                                                                 
    class           (nodeData                 ), pointer                              :: primaryProgenitor    , progenitorNode  , & 
         &                                                                               node
    class           (nodeComponentBasic       ), pointer                              :: basic
    class           (nodeComponentPosition    ), pointer                              :: position
    type            (treeNode                 ), pointer                              :: hostNode             , satelliteNode
    double precision                                    , dimension(3)                :: relativePosition     , relativeVelocity           
    type            (keplerOrbit              )                                       :: orbit                                         
    double precision                                                                  :: primaryProgenitorMass, timeUntilMerging           
    type            (progenitorIterator       )                                       :: progenitors                                                                       
    character       (len=42                   )                                       :: coordinateLabel                                                                   
    type            (varying_string           )                                       :: message                                                                   
    logical                                                                           :: parentIsCloned

    ! Find the nodes that descend into our target node's descendent.
    call progenitors%descendentSet(self,lastSeenNode%descendent,nodes)
    if (progenitors%exist()) then
       ! Determine if the parent node has a clone primary progenitor.
       parentIsCloned=(nodeList(lastSeenNode%isolatedNodeIndex)%node%parent%uniqueID() == nodeList(lastSeenNode%isolatedNodeIndex)%node%parent%firstChild%uniqueID())
       ! If parent is cloned, we need to make a temporary progenitor node.
       if (parentIsCloned) then
          allocate(primaryProgenitor)
          basic                       => nodeList(lastSeenNode%isolatedNodeIndex)%node%parent%firstChild%basic   ()
          position                    => nodeList(lastSeenNode%isolatedNodeIndex)%node%parent%firstChild%position()
          primaryProgenitor%nodeIndex =  nodeList(lastSeenNode%isolatedNodeIndex)%node%parent%firstChild%index   ()
          primaryProgenitor%nodeMass  =  basic                                                          %mass    ()
          primaryProgenitor%position  =  position                                                       %position()
          primaryProgenitor%velocity  =  position                                                       %velocity()
       else
          primaryProgenitor     => null()
          primaryProgenitorMass =  0.0d0
          do while (progenitors%next(nodes))
             progenitorNode => progenitors%current(nodes)
             if (progenitorNode%nodeIndex /= lastSeenNode%nodeIndex .and. progenitorNode%nodeMass > primaryProgenitorMass) then
                primaryProgenitorMass =  progenitorNode%nodeMass
                primaryProgenitor     => progenitorNode
             end if
          end do
       end if
       ! Initialize time until merging to zero.
       timeUntilMerging=0.0d0
       ! If position information is available, compute the subresolution orbit.
       if (self%presetPositions) then
          ! Find relative position and velocity.
          relativePosition=lastSeenNode%position-primaryProgenitor%position
          relativeVelocity=lastSeenNode%velocity-primaryProgenitor%velocity
          ! Update position/velocity for periodicity and Hubble flow.
          call self%phaseSpacePositionRealize(lastSeenNode%nodeTime,relativePosition,relativeVelocity)
          ! Catch zero separation halos.
          if (Vector_Magnitude(relativePosition) == 0.0d0) then
             message='merging halos ['
             message=message//lastSeenNode%nodeIndex//' & '//primaryProgenitor%nodeIndex//'] have zero separation'
             call Galacticus_Display_Indent  (message                          ,verbosityWarn)
             write (coordinateLabel,'("[",e12.6,",",e12.6,",",e12.6,"]")') primaryProgenitor%position
             message="position [primary  ] = "//trim(coordinateLabel)
             call Galacticus_Display_Message (message                          ,verbosityWarn)
             write (coordinateLabel,'("[",e12.6,",",e12.6,",",e12.6,"]")') lastSeenNode     %position
             message="position [satellite] = "//trim(coordinateLabel)
             call Galacticus_Display_Message (message                          ,verbosityWarn)
             write (coordinateLabel,'("[",e12.6,",",e12.6,",",e12.6,"]")') primaryProgenitor%velocity
             message="velocity [primary  ] = "//trim(coordinateLabel)
             call Galacticus_Display_Message (message                          ,verbosityWarn)
             write (coordinateLabel,'("[",e12.6,",",e12.6,",",e12.6,"]")') lastSeenNode     %velocity
             message="velocity [satellite] = "//trim(coordinateLabel)
             call Galacticus_Display_Message (message                          ,verbosityWarn)
             call Galacticus_Display_Unindent('assuming instantaneous merging' ,verbosityWarn)
          else
             ! Create the orbit.
             orbit=readOrbitConstruct(lastSeenNode%nodeMass,primaryProgenitor%nodeMass,relativePosition,relativeVelocity)
             ! Construct temporary nodes.
             satelliteNode                => treeNode()
             hostNode                     => treeNode()
             call    nodeList(lastSeenNode     %isolatedNodeIndex)%node                  %copyNodeTo(satelliteNode,skipEvent=.true.)
             if (parentIsCloned) then
                call nodeList(lastSeenNode     %isolatedNodeIndex)%node%parent%firstChild%copyNodeTo(hostNode     ,skipEvent=.true.)
             else
                call nodeList(primaryProgenitor%isolatedNodeIndex)%node                  %copyNodeTo(hostNode     ,skipEvent=.true.)
             end if
             satelliteNode%parent         => hostNode
             hostNode     %firstSatellite => satelliteNode             
             ! Determine the time until merging.
             timeUntilMerging=self%satelliteMergingTimescales_%timeUntilMerging(satelliteNode,orbit)
             ! Clean up.
             call satelliteNode%destroy()
             call hostNode     %destroy()
             deallocate(satelliteNode)
             deallocate(hostNode     )
          end if
       end if
       ! Find the new merging time, and the node with which the merging will occur.
       node              => lastSeenNode%descendent
       timeSubhaloMerges =  timeSubhaloMerges+timeUntilMerging
       do while (associated(node%descendent))
          if (node%descendent%nodeTime > timeSubhaloMerges) then
             nodes(iNode)%mergesWithIndex=node%nodeIndex
             exit
          else
             node => node%descendent
          end if
       end do
       ! Merging time is beyond the end of the tree. Set merging time to infinity.
       if (.not.associated(node%descendent)) nodes(iNode)%mergesWithIndex=node%nodeIndex
       ! Clean up any temporary progenitor.
       if (parentIsCloned) deallocate(primaryProgenitor)
    else
       call Galacticus_Error_Report('no descendents found'//{introspection:location})
    end if
    return
  end subroutine readTimeUntilMergingSubresolution

  function readOrbitConstruct(mass1,mass2,position,velocity) result(orbit)
    !% Construct a Keplerian orbit given body masses, positions, and relative velocities.
    use Kepler_Orbits
    use Vectors
    implicit none
    type            (keplerOrbit)                              :: orbit           
    double precision                           , intent(in   ) :: mass1   , mass2    
    double precision             , dimension(3), intent(in   ) :: position, velocity 
    
    call orbit%reset()
    call orbit%massesSet            (       &
         &                           mass1, &
         &                           mass2  &
         &                          )
    call orbit%radiusSet            (                                                   Vector_Magnitude(position))
    call orbit%velocityRadialSet    (                    Dot_Product(velocity,position)/Vector_Magnitude(position))
    call orbit%velocityTangentialSet(Vector_Magnitude(Vector_Product(velocity,position)/Vector_Magnitude(position)))
    return
  end function readOrbitConstruct

  subroutine readPhaseSpacePositionRealize(self,time,position,velocity)
    !% Modify relative positions and velocities to account for both any periodicity of the simulated volume, and for Hubble flow.
    use Cosmology_Functions
    use Numerical_Constants_Boolean
    implicit none
    class           (mergerTreeConstructorRead)              , intent(inout) :: self
    double precision                                         , intent(in   ) :: time                                
    double precision                           , dimension(3), intent(inout) :: position           , velocity 
    double precision                                                         :: lengthSimulationBox                 
    
    ! Account for periodicity.
    if (self%mergerTreeImporter_%positionsArePeriodic() /= booleanFalse) then
       lengthSimulationBox=self%mergerTreeImporter_%cubeLength(time)
       position=mod(position+0.5d0*lengthSimulationBox,lengthSimulationBox)-0.5d0*lengthSimulationBox
       position=mod(position-0.5d0*lengthSimulationBox,lengthSimulationBox)+0.5d0*lengthSimulationBox
    end if
    ! Account for Hubble flow.
    if (self%mergerTreeImporter_%velocitiesIncludeHubbleFlow() /= booleanTrue) then
       velocity=velocity                                                    &
            &  +position                                                    &
            &  *self%cosmologyFunctions_%hubbleParameterEpochal(time=time)
    end if
    return
  end subroutine readPhaseSpacePositionRealize

  subroutine progenitorIteratorDescendentSet(self,constructor,node,nodes)
    !% Initialize a progenitor iterator object by storing the index of the taget {\normalfont \ttfamily node} and finding the location of the first
    !% progenitor (if any).
    implicit none
    class(progenitorIterator       )              , intent(inout) :: self
    type (mergerTreeConstructorRead), target      , intent(in   ) :: constructor
    class(nodeData                 )              , intent(in   ) :: node  
    class(nodeData                 ), dimension(:), intent(in   ) :: nodes 

    ! Store a pointer to the tree constructor.
    self%constructor => constructor
    ! Store the index of the target node.
    self%targetIndex     =node%nodeIndex
    ! Assume no progenitors descendants by default.
    self%progenitorsFound=.false.
    ! Find the index of matching nodes in the list sorted by descendent index.
    self%progenitorIndex=self%constructor%descendentNodeSortIndex(node%nodeIndex)
    if (self%progenitorIndex > 0 .and. self%progenitorIndex <= size(nodes)) then
       ! Progenitors may exist, store the location of the first progenitor if found.
       self%progenitorLocation=self%constructor%descendentLocations(self%progenitorIndex)
       if (associated(nodes(self%progenitorLocation)%descendent)) &
            & self%progenitorsFound=(nodes(self%progenitorLocation)%descendent%nodeIndex == node%nodeIndex)
       ! Increment the initial index so that the first call to get the next progenitor can find the first progenitor by
       ! subtracting one from this index.
       self%progenitorIndex=self%progenitorIndex+1
    end if
    return
  end subroutine progenitorIteratorDescendentSet
  
  logical function progenitorIteratorNext(self,nodes)
    !% Move to the next progenitor using a progenitor iterator object, returning true if the next progenitor exists, false if it
    !% does not.
    implicit none
    class(progenitorIterator)              , intent(inout) :: self  
    class(nodeData          ), dimension(:), intent(in   ) :: nodes 
    
    if (self%progenitorsFound) then
       progenitorIteratorNext=.true.
       self%progenitorLocation=-1
       do while (self%progenitorIndex > 0)
          self%progenitorIndex=self%progenitorIndex-1
          if (self%progenitorIndex <= 0) exit
          self%progenitorLocation=self%constructor%descendentLocations(self%progenitorIndex)
          if (associated(nodes(self%progenitorLocation)%descendent)) exit
       end do
       if (.not.associated(nodes(self%progenitorLocation)%descendent)) then
          progenitorIteratorNext=.false.
          return
       end if
       if (      self%progenitorIndex                          == 0               ) progenitorIteratorNext=.false.
       if (nodes(self%progenitorLocation)%descendent%nodeIndex /= self%targetIndex) progenitorIteratorNext=.false.
    else
       progenitorIteratorNext=.false.
    end if
    return
  end function progenitorIteratorNext
  
  function progenitorIteratorIndex(self,nodes)
    !% Return the node index of the current progenitor in a progenitor iterator object.
    implicit none
    integer(kind=kind_int8    )                              :: progenitorIteratorIndex 
    class  (progenitorIterator)              , intent(in   ) :: self                    
    class  (nodeData          ), dimension(:), intent(in   ) :: nodes                   
    
    progenitorIteratorIndex=nodes(self%progenitorLocation)%nodeIndex
    return
  end function progenitorIteratorIndex
  
  function progenitorIteratorCurrent(self,nodes)
    !% Return a pointer to the current progenitor in a progenitor iterator object.
    implicit none
    class(nodeData          ), pointer                             :: progenitorIteratorCurrent 
    class(progenitorIterator)              , intent(in   )         :: self                      
    class(nodeData          ), dimension(:), intent(in   ), target :: nodes                     
    
    progenitorIteratorCurrent => nodes(self%progenitorLocation)
    return
  end function progenitorIteratorCurrent
  
  logical function progenitorIteratorExist(self)
    !% Return true if progenitors exist, false otherwise.
    implicit none
    class(progenitorIterator), intent(in   ) :: self 
    
    progenitorIteratorExist=self%progenitorsFound
    return
  end function progenitorIteratorExist
  
  subroutine readTimingRecord(self,label)
    !% Record timing data.
    implicit none
    class    (mergerTreeConstructorRead), intent(inout)               :: self
    character(len=*                    ), intent(in   )               :: label
    real                                , allocatable  , dimension(:) :: timingTimesTmp
    type     (varying_string           ), allocatable  , dimension(:) :: timingLabelsTmp
    real                                                              :: timeNow
    
    call CPU_Time(timeNow)
    if (allocated(self%timingTimes)) then
       call Move_Alloc(self%timingTimes ,timingTimesTmp )
       call Move_Alloc(self%timingLabels,timingLabelsTmp)
       allocate(self%timingTimes (size(timingTimesTmp )+1))
       allocate(self%timingLabels(size(timingLabelsTmp)+1))
       self%timingTimes (1:size(timingTimesTmp ))=timingTimesTmp
       self%timingLabels(1:size(timingLabelsTmp))=timingLabelsTmp
       deallocate(timingTimesTmp )
       deallocate(timingLabelsTmp)
    else
      allocate(self%timingTimes (1))
      allocate(self%timingLabels(1))
    end if
    self%timingTimes (size(self%timingTimes ))=timeNow
    self%timingLabels(size(self%timingLabels))=trim(label)
    return
  end subroutine readTimingRecord
    
  subroutine readTimingReport(self)
    !% Report on time taken in various steps of processing merger trees read from file.
    use Galacticus_Display
    implicit none
    class    (mergerTreeConstructorRead), intent(inout) :: self
    integer                                             :: i        , lengthMaximum
    type     (varying_string           )                :: message
    character(len=12                   )                :: timeTaken

    call Galacticus_Display_Indent("Merger tree read processing report:")
    if (allocated(self%timingTimes).and.size(self%timingTimes) > 1) then
       lengthMaximum=maxval(len(self%timingLabels))
       do i=2,size(self%timingTimes)
          write (timeTaken,'(f10.2)') self%timingTimes(i)-self%timingTimes(i-1)
          message=repeat(" ",lengthMaximum-len(self%timingLabels(i)))//self%timingLabels(i)//": "//trim(adjustl(timeTaken))//" s"
          call Galacticus_Display_Message(message)
       end do
    end if
    call Galacticus_Display_Unindent("done")
    return
  end subroutine readTimingReport

  subroutine readRootNodeAffinitiesInitial(self,nodes)
    !% Find initial root node affinities for all nodes.
    use Memory_Management
    use Sort
    use ISO_Varying_String
    use Galacticus_Display
    use String_Handling
    implicit none
    class  (mergerTreeConstructorRead)                        , intent(inout) :: self
    class  (nodeDataMinimal          ), dimension(         : ), intent(inout) :: nodes
    integer(kind_int8                ), dimension(size(nodes))                :: rootAffinity
    integer(c_size_t                 )                                        :: i                , j                       , &
         &                                                                       treeCount        , pushCount               , &
         &                                                                       k                , progenitorLocation      , &
         &                                                                       forestSizeI      , forestSizeJ
    integer(kind_int8                )                                        :: treeIndexPrevious, treeStartPrevious       , &
         &                                                                       progenitorIndex
    type   (varying_string           )                                        :: message
    logical                                                                   :: nodeIsMostMassive, isolatedProgenitorExists, &
         &                                                                       nodeIsPrimary
    
    ! Get a unique ID for this split forest.
    self%splitForestUniqueID=readSplitForestUniqueID%increment()
    ! Build sorted indices into nodes.
    call self%createNodeIndices(nodes)
    ! Initialize root affinities to impossible value.
    rootAffinity=-1_kind_int8
    ! Iterate over nodes.
    do i=1,size(nodes)
       ! Trace through hosts until a self-hosting node is found.
       j=i
       do while (nodes(j)%nodeIndex /= nodes(j)%hostIndex)
          j=self%nodeLocation(nodes(j)%hostIndex)
       end do
       ! Trace descendents until a root node is reached.
       do while (nodes(j)%descendentIndex >= 0)
          ! Jump to descendent.
          if (nodes(j)%descendentIndex >= 0) j=self%nodeLocation(nodes(j)%descendentIndex)
          ! Trace through hosts until a self-hosting node is found.
          do while (nodes(j)%nodeIndex /= nodes(j)%hostIndex)
             j=self%nodeLocation(nodes(j)%hostIndex)
          end do
       end do
       ! Store root affinity.
       rootAffinity(i)=nodes(j)%nodeIndex
    end do
    ! Search for nodes which have a descendent or host with different root affinity and attempt to regroup trees into subforests
    ! of the original forest.
    do i=1,size(nodes)
       ! Process only nodes with a descendent.       
       if (nodes(i)%descendentIndex >= 0) then
          ! Check for different root affinity in descendent.
          do k=1,2
             select case (k)
             case (1)
                j=self%nodeLocation(nodes(i)%descendentIndex)
             case (2)
                j=self%nodeLocation(nodes(i)%      hostIndex)
             end select
             if (rootAffinity(i) /= rootAffinity(j)) then
                forestSizeI=count(rootAffinity == rootAffinity(i))
                if (forestSizeI             >= self%forestSizeMaximum) cycle                
                forestSizeJ=count(rootAffinity == rootAffinity(j))
                if (forestSizeI+forestSizeJ >  self%forestSizeMaximum) cycle
                where (rootAffinity == rootAffinity(j))
                   rootAffinity=rootAffinity(i)
                end where
              end if
          end do
       end if
    end do
    ! Get a sorted index into the root node affinities.
    call allocateArray(self%splitForestMapIndex,shape(nodes))
    self%splitForestMapIndex=Sort_Index_Do(rootaffinity)
    ! Count trees in the forest.
    treeCount        = 0
    treeIndexPrevious=-1
    do i=1,size(nodes)
       if (rootAffinity(self%splitForestMapIndex(i)) /= treeIndexPrevious) then
          treeCount        =treeCount                           +1
          treeIndexPrevious=rootAffinity(self%splitForestMapIndex(i))
       end if
    end do
    ! Identify tree size and start offsets.
    call allocateArray(self%splitForestTreeSize ,[treeCount])
    call allocateArray(self%splitForestTreeStart,[treeCount])
    treeIndexPrevious=-1
    treeStartPrevious= 0
    treeCount        = 0
    do i=1,size(nodes)
       if (rootAffinity(self%splitForestMapIndex(i)) /= treeIndexPrevious) then
          treeCount                      =treeCount                           +1
          treeIndexPrevious              =rootAffinity(self%splitForestMapIndex(i))
          self%splitForestTreeStart(treeCount)=                                 i
       end if
    end do
    if (treeCount > 1) then
       do i=1,treeCount-1
          self%splitForestTreeSize(i)=self%splitForestTreeStart(i+1)-self%splitForestTreeStart(i)
       end do
    end if
    self%splitForestTreeSize(treeCount)=size(nodes)+1-self%splitForestTreeStart(treeCount)   
    ! Report.
    call Galacticus_Display_Indent('Breaking forest into trees:',verbosityInfo)
    do i=1,treeCount
       message="Tree "
       message=message//i//" of "//treeCount//" contains "//self%splitForestTreeSize(i)//" node"
       if (self%splitForestTreeSize(i) > 1) message=message//"s"
       call Galacticus_Display_Message(message,verbosityInfo)
    end do
    ! Search for nodes which have a descendent with different root affinity.
    pushCount=0
    do i=1,size(nodes)
       ! Process only nodes with a descendent.       
       if (nodes(i)%descendentIndex >= 0) then
          ! Check for different root affinity in descendent.
          j=self%nodeLocation(nodes(i)%descendentIndex)
          k=self%nodeLocation(nodes(j)%      hostIndex)
          if     (                                    &
               &   rootAffinity(i) /= rootAffinity(j) &
               &  .or.                                &
               &   rootAffinity(i) /= rootAffinity(k) &
               & ) then
             ! Descendent has different root affinity - this is a cross-tree subhalo promotion event or cross-tree branch jump
             ! event.
             pushCount=pushCount+1
          end if
       end if
    end do
    message="Found "
    message=message//pushCount//" links between trees"
    call Galacticus_Display_Message(message,verbosityInfo)
    ! Build a list of push and pull links.
    call allocateArray(self%splitForestPushTo   ,[pushCount])
    call allocateArray(self%splitForestPullFrom ,[pushCount])
    call allocateArray(self%splitForestPushType ,[pushCount])
    call allocateArray(self%splitForestPushTime ,[pushCount])
    call allocateArray(self%splitForestIsPrimary,[pushCount])
    call allocateArray(self%splitForestPushDone ,[pushCount])
    call allocateArray(self%splitForestPullDone ,[pushCount])
    pushCount=0
    do i=1,size(nodes)
       ! Process only nodes with a descendent.
       if (nodes(i)%descendentIndex >= 0) then
          ! Check for different root affinity in descendent.
          j=self%nodeLocation(nodes(i)%descendentIndex)
          ! Test for an inter-tree event. These are identified by a node having a different initial root affinity than its descendent.
          if (rootAffinity(i) /= rootAffinity(j)) then     
             ! Determine if our node is the primary progenitor and if an isolated progenitor exists.
             isolatedProgenitorExists=.false.
             nodeIsMostMassive       =.true.
             progenitorIndex         =self%descendentNodeSortIndex(nodes(i)%descendentIndex)
             if (progenitorIndex > 0 .and. progenitorIndex <= size(nodes)) then
                progenitorLocation=self%descendentLocations(progenitorIndex)
                do while (nodes(progenitorLocation)%descendentIndex == nodes(i)%descendentIndex)
                   ! Determine progenitor status.
                   if (nodes(progenitorLocation)%nodeIndex /= nodes(progenitorLocation)%hostIndex) then
                      if     (                                                           &
                           &   nodes(progenitorLocation)%nodeIndex /= nodes(i)%nodeIndex &
                           &  .and.                                                      &
                           &   nodes(progenitorLocation)%nodeMass  >  nodes(i)%nodeMass  &
                           & ) nodeIsMostMassive=.false.
                   else
                      isolatedProgenitorExists=.true.
                   end if
                   ! Move to the next progenitor.
                   progenitorIndex=progenitorIndex-1
                   if (progenitorIndex > 0) then
                      progenitorLocation=self%descendentLocations(progenitorIndex)
                   else
                      exit
                   end if
                end do
             end if
             nodeIsPrimary=nodeIsMostMassive.and..not.isolatedProgenitorExists             
             ! Determine the type of event. If the descendent is a subhalo, then this is an inter-tree branch jump. If the
             ! descendent is not a subhalo this is an inter-tree subhalo promotion.
             pushCount=pushCount+1
             if (nodes(j)%nodeIndex == nodes(j)%hostIndex) then
                ! Inter-tree subhalo promotion.
                self%splitForestPushTime (pushCount)=nodes(j)%      nodeTime
                self%splitForestPushTo   (pushCount)=nodes(i)%      nodeIndex
                self%splitForestPullFrom (pushCount)=nodes(i)%descendentIndex
                self%splitForestIsPrimary(pushCount)=nodeIsPrimary
                self%splitForestPushType (pushCount)=pushTypeSubhaloPromotion
                self%splitForestPushDone (pushCount)=.false.
                self%splitForestPullDone (pushCount)=.false.                
             else
                ! For non-primary progenitors, detect nested subhalo hierarchy. The descendent node is a subhalo. As nested hierarchies are not currently
                ! handled, we must instead find the isolated host of the descendent and push to that node instead.
                if (.not.nodeIsPrimary) then
                   if (.not.self%warningSplitForestNestedHierarchyIssued) then
                      message='nested hierarchy in split forests detected [node '
                      message=message//nodes(j)%nodeIndex//']'
                      message=message//char(10)//'ignoring as not currently supported'
                      message=message//char(10)//'warning will not be issued again'
                      call Galacticus_Display_Message(message,verbosityWarn)
                      self%warningSplitForestNestedHierarchyIssued=.true.
                   end if
                   do while (nodes(j)%nodeIndex /= nodes(j)%hostIndex)
                      j=self%nodeLocation(nodes(j)%hostIndex)
                   end do
                end if
                ! Inter-tree branch jump.
                k                              =self%nodeLocation(nodes(i)%hostIndex)
                self%splitForestPushTime (pushCount)=              nodes(k)%nodeTime
                self%splitForestPushTo   (pushCount)=              nodes(i)%nodeIndex
                self%splitForestPullFrom (pushCount)=              nodes(j)%nodeIndex
                self%splitForestIsPrimary(pushCount)=nodeIsPrimary
                self%splitForestPushType (pushCount)=pushTypeBranchJump
                self%splitForestPushDone (pushCount)=.false.
                self%splitForestPullDone (pushCount)=.false.
             end if
          end if
       end if
    end do
    call Galacticus_Display_Unindent('done',verbosityInfo)
    return
  end subroutine readRootNodeAffinitiesInitial

  logical function readIsOnPushList(self,node)
    !% Return true if the given node is on the current ``push-to'' list of nodes for split forests.
    implicit none
    class(mergerTreeConstructorRead), intent(inout) :: self
    class(nodeData                 ), intent(in   ) :: node

    if (allocated(self%splitForestPushTo)) then
       readIsOnPushList=any(self%splitForestPushTo == node%nodeIndex)
    else
       readIsOnPushList=.false.
    end if
    return
  end function readIsOnPushList
  
  logical function readIsOnPullList(self,node)
    !% Return true if the given node is on the current ``pull-from'' list of nodes for split forests.
    implicit none
    class(mergerTreeConstructorRead), intent(inout) :: self
    class(nodeData                 ), intent(in   ) :: node

    if (allocated(self%splitForestPullFrom)) then
       readIsOnPullList=any(self%splitForestPullFrom == node%nodeIndex)
    else
       readIsOnPullList=.false.
    end if
    return
  end function readIsOnPullList
  
  function readPushListIndex(self,node)
    !% Return the index of the given node in the ``push-to'' list of nodes for split forests.
    implicit none
    class  (mergerTreeConstructorRead), intent(inout) :: self
    integer(c_size_t                 )                :: readPushListIndex
    class  (nodeData                 ), intent(in   ) :: node
    integer(c_size_t                 )                :: i

    readPushListIndex=-1_c_size_t
    do i=1,size(self%splitForestPushTo)
       if (self%splitForestPushTo(i) == node%nodeIndex) then
          readPushListIndex=i
          exit
       end if
    end do
    return
  end function readPushListIndex
  
  function readPullListIndex(self,node,iPull)
    !% Return the index of the given node in the ``pull-from'' list of nodes for split forests.
    implicit none
    class  (mergerTreeConstructorRead), intent(inout) :: self
    integer(c_size_t                 )                :: readPullListIndex
    class  (nodeData                 ), intent(in   ) :: node
    integer(c_size_t                 ), intent(in   ) :: iPull
    integer(c_size_t                 )                :: i                , matchesRemaining
    
    readPullListIndex   =-1_c_size_t
    matchesRemaining=iPull
    do i=1,size(self%splitForestPullFrom)
       if (self%splitForestPullFrom(i) == node%nodeIndex) then
          matchesRemaining=matchesRemaining-1
          if (matchesRemaining == 0) then
             readPullListIndex   =i
             exit
          end if
       end if
    end do
    return
  end function readPullListIndex
  
  function readPullListCount(self,node)
    !% Return the number of the given node in the ``pull-from'' list of nodes for split forests.
    implicit none
    class  (mergerTreeConstructorRead), intent(inout) :: self
    integer(c_size_t                 )                :: readPullListCount
    class  (nodeData                 ), intent(in   ) :: node

    if (allocated(self%splitForestPullFrom)) then
       readPullListCount=count(self%splitForestPullFrom == node%nodeIndex)
    else
       readPullListCount=0
    end if
    return
  end function readPullListCount

  subroutine readAssignSplitForestEvents(self,nodes,nodeList)
    !% Assign events to nodes if they jump between trees in a forest.
    use Galacticus_Display
    use Galacticus_Error
    use String_Handling
    use Node_Events_Inter_Tree
    use Galacticus_Nodes      , only : treeNodeList, nodeEvent, nodeEventSubhaloPromotionInterTree, nodeEventBranchJumpInterTree
    implicit none
    class           (mergerTreeConstructorRead)              , intent(inout), target :: self
    class           (nodeData                 ), dimension(:), intent(inout), target :: nodes
    type            (treeNodeList             ), dimension(:), intent(inout)         :: nodeList
    class           (nodeEvent                ), pointer                             :: newEvent
    class           (nodeData                 ), pointer                             :: node
    type            (treeNode                 ), pointer                             :: nodeNew          , satellite
    class           (nodeComponentBasic       ), pointer                             :: basicNew
    integer                                                                          :: iNode
    integer         (c_size_t                 )                                      :: iIsolatedNode    , progenitorLocation, &
         &                                                                              iPull
    integer         (kind_int8                )                                      :: progenitorIndex
    type            (varying_string           )                                      :: message
    character       (len=12                   )                                      :: label
    logical                                                                          :: nodeIsMostMassive

    !! TODO: Handle cases where branch jumps and/or subhalo promotions are disallowed.
    
    call Galacticus_Display_Indent('Assigning inter-tree events',verbosityInfo)
    do iNode=1,size(nodes)
       ! Process only isolated nodes.
       if (nodes(iNode)%isolatedNodeIndex == readNodeReachabilityUnreachable) cycle
       ! Trace through subhalo descendents.
       node => nodes(iNode)
       newEvent => null (     )
       do while (.true.)
          if (self%isOnPushList(node)) then
             iIsolatedNode =  nodes(iNode)%isolatedNodeIndex             
             if (.not.self%splitForestPushDone(self%pushListIndex(node))) then
                select case (self%splitForestPushType(self%pushListIndex(node)))
                case (pushTypeSubhaloPromotion)
                   allocate(nodeEventSubhaloPromotionInterTree :: newEvent)
                case (pushTypeBranchJump      )
                   allocate(nodeEventBranchJumpInterTree       :: newEvent)
                end select
                call nodeList(iIsolatedNode)%node%attachEvent(newEvent)
                newEvent%time =  self%splitForestPushTime(self%pushListIndex(node))
                newEvent%node => null()
                newEvent%task => Node_Push_From_Tree
                select type (newEvent)
                type is (nodeEventSubhaloPromotionInterTree)
                   newEvent%splitForestUniqueID =  self%splitForestUniqueID
                   newEvent%pairedNodeID        =  self%splitForestPushTo(self%pushListIndex(node))
                   newEvent%mergeTimeSet        => null()
                type is (nodeEventBranchJumpInterTree      )
                   newEvent%splitForestUniqueID =  self%splitForestUniqueID
                   newEvent%pairedNodeID        =  self%splitForestPushTo(self%pushListIndex(node))
                   newEvent%mergeTimeSet        => null()
                end select
                self%splitForestPushDone(self%pushListIndex(node))=.true.
                write (label,'(f12.8)') self%splitForestPushTime(self%pushListIndex(node))
                message="Attaching push event ["
                message=message//newEvent%ID//"] to node "//node%nodeIndex//" [-->"//self%splitForestPullFrom(self%pushListIndex(node))//"] {ref:"//self%splitForestPushTo(self%pushListIndex(node))//"} at time "//label//" Gyr"
                call Galacticus_Display_Message(message,verbosityInfo)             
             end if
          end if
          if (self%isOnPullList(node)) then             
             do iPull=1,self%pullListCount(node)
                if (.not.self%splitForestPullDone(self%pullListIndex(node,iPull))) then
                   select case (self%splitForestPushType(self%pullListIndex(node,iPull)))
                   case (pushTypeSubhaloPromotion)
                      allocate(nodeEventSubhaloPromotionInterTree :: newEvent)
                   case (pushTypeBranchJump      )
                      allocate(nodeEventBranchJumpInterTree       :: newEvent)
                   case default
                      call Galacticus_Error_Report('unknown push type'//{introspection:location})
                   end select
                   iIsolatedNode=nodes(iNode)%isolatedNodeIndex
                   if (self%splitForestIsPrimary(self%pullListIndex(node,iPull))) then
                      ! For a subhalo promotion primary progenitor, create a temporary primary progenitor node (unless we have
                      ! previously done so) to which we attach the event. This will later be replaced with our node.
                      if (self%splitForestPushType(self%pullListIndex(node,iPull)) == pushTypeBranchJump) then
                         nodeNew => nodeList(iIsolatedNode)%node
                      else
                         allocate                                    (nodeNew)
                         call nodeList(iIsolatedNode)%node%copyNodeTo(nodeNew)
                         nodeNew%sibling                         => nodeList(iIsolatedNode)%node%firstChild
                         nodeNew%parent                          => nodeList(iIsolatedNode)%node
                         nodeNew%firstChild                      => null()
                         nodeNew%mergeTarget                     => null()
                         nodeNew%siblingMergee                   => null()
                         nodeList(iIsolatedNode)%node%firstChild => nodeNew
                         basicNew                                => nodeNew%basic()
                         call basicNew%timeSet(basicNew%time()*(1.0d0-1.0d-6))
                         ! Events remain attached to the original and we do not want to duplicate them.
                         nodeNew%event => null()
                         ! Any satellites are now attached to the copy.
                         nodeList(iIsolatedNode)%node%firstSatellite => null()
                         satellite => nodeNew%firstSatellite
                         do while (associated(satellite))
                            satellite%parent => nodeNew
                            satellite        => satellite%sibling
                         end do
                      end if
                      select type (newEvent)
                      type is (nodeEventSubhaloPromotionInterTree)
                         newEvent%mergeTimeSet => null()
                      type is (nodeEventBranchJumpInterTree      )
                         newEvent%mergeTimeSet => null()
                         class default
                         call Galacticus_Error_Report('unknown event type'//{introspection:location})
                      end select
                      call nodeNew%attachEvent(newEvent)
                   else
                      ! For a non-primary progenitor, attach the event to the primary progenitor of the node, such that our node
                      ! can later be added as a sibling. If the primary progenitor has no child, create a clone.
                      if (.not.associated(nodeList(iIsolatedNode)%node%firstChild)) then
                         allocate                                    (nodeNew)
                         call nodeList(iIsolatedNode)%node%copyNodeTo(nodeNew)
                         nodeNew%parent                          => nodeList(iIsolatedNode)%node
                         nodeNew%sibling                         => null()
                         nodeNew%firstChild                      => null()
                         nodeNew%mergeTarget                     => null()
                         nodeNew%siblingMergee                   => null()
                         nodeList(iIsolatedNode)%node%firstChild => nodeNew
                         basicNew                                => nodeNew%basic()
                         call basicNew%timeSet(basicNew%time()*(1.0d0-1.0d-6))
                         ! Events remain attached to the original and we do not want to duplicate them.
                         nodeNew%event => null()
                         ! Any satellites are now attached to the copy.
                         nodeList(iIsolatedNode)%node%firstSatellite => null()
                         satellite => nodeNew%firstSatellite
                         do while (associated(satellite))
                            satellite%parent => nodeNew
                            satellite        => satellite%sibling
                         end do
                      end if
                      select type (newEvent)
                      type is (nodeEventSubhaloPromotionInterTree)
                         newEvent%mergeTimeSet => readInterTreeMergeTimeSet
                         newEvent%creator      => self
                      type is (nodeEventBranchJumpInterTree      )
                         newEvent%mergeTimeSet => readInterTreeMergeTimeSet
                         newEvent%creator      => self
                      class default
                         call Galacticus_Error_Report('unknown event type'//{introspection:location})
                      end select
                      call nodeList(iIsolatedNode)%node%firstChild%attachEvent(newEvent)
                   end if
                   newEvent%time =  self%splitForestPushTime(self%pullListIndex(node,iPull))
                   newEvent%node => null()
                   newEvent%task => Node_Pull_From_Tree
                   select type (newEvent)
                   type is (nodeEventSubhaloPromotionInterTree)
                      newEvent%splitForestUniqueID=self%splitForestUniqueID
                      newEvent%pairedNodeID       =self%splitForestPushTo      (self%pullListIndex(node,iPull))
                      newEvent%isPrimary          =self%splitForestIsPrimary   (self%pullListIndex(node,iPull))
                   type is (nodeEventBranchJumpInterTree      )
                      newEvent%splitForestUniqueID=self%splitForestUniqueID
                      newEvent%pairedNodeID       =self%splitForestPushTo      (self%pullListIndex(node,iPull))
                      newEvent%isPrimary          =self%splitForestIsPrimary   (self%pullListIndex(node,iPull))
                   class default
                      call Galacticus_Error_Report('unknown event type'//{introspection:location})
                   end select
                   self%splitForestPullDone(self%pullListIndex(node,iPull))=.true.
                   write (label,'(f12.8)') self%splitForestPushTime(self%pullListIndex(node,iPull))
                   message="Attaching pull event ["
                   message=message//newEvent%ID//"] to node "//node%nodeIndex//" [<--"//self%splitForestPushTo(self%pullListIndex(node,iPull))//"] {ref:"//self%splitForestPushTo(self%pullListIndex(node,iPull))//"} at time "//label//" Gyr"
                   call Galacticus_Display_Message(message,verbosityInfo)
                end if
             end do
          end if
          ! Is this the primary progenitor of its descendent?
          nodeIsMostMassive=.true.
          progenitorIndex  =self%descendentNodeSortIndex(node%descendentIndex)
          if (progenitorIndex > 0 .and. progenitorIndex <= size(nodes)) then
             progenitorLocation=self%descendentLocations(progenitorIndex)
             do while (nodes(progenitorLocation)%descendentIndex == node%descendentIndex)
                ! Determine progenitor status.
                if     (                                                           &
                     &   nodes(progenitorLocation)%nodeIndex /= node%nodeIndex &
                     &  .and.                                                      &
                     &   nodes(progenitorLocation)%nodeMass  >  node%nodeMass  &
                     & ) nodeIsMostMassive=.false.                 
                ! Move to the next progenitor.
                progenitorIndex=progenitorIndex-1
                if (progenitorIndex > 0) then
                   progenitorLocation=self%descendentLocations(progenitorIndex)
                else
                   exit
                end if
             end do
          end if
          ! Move to a subhalo descendent.
          if (associated(node%descendent).and.node%descendent%isSubhalo.and.nodeIsMostMassive) then
             node => node%descendent
             ! If we've reached an isolated node, stop as we will process it in another pass through the loop.
             if (node%isolatedNodeIndex /= readNodeReachabilityUnreachable) exit
          else
             exit
          end if
       end do
    end do
    call Galacticus_Display_Unindent('done',verbosityInfo)   
    return
  end subroutine readAssignSplitForestEvents

  subroutine readInterTreeMergeTimeSet(self,nodeSatellite,nodeHost)
    !% Set the merging time for a node undergoing and inter-tree transfer.
    use Kepler_Orbits
    use Galacticus_Error
    use String_Handling
    use Galacticus_Nodes , only : nodeComponentSatellite, nodeComponentPosition
    implicit none
    class           (*                       ), intent(inout)          :: self
    type            (treeNode                ), intent(inout), target  :: nodeSatellite               , nodeHost
    type            (treeNode                )               , pointer :: nodeTarget
    class           (nodeComponentSatellite  )               , pointer :: satelliteSatellite
    class           (nodeComponentBasic      )               , pointer :: basicSatellite              , basicHost       , &
         &                                                                basicTarget
    class           (nodeComponentPosition   )               , pointer :: positionSatellite           , positionHost
    logical                                   , parameter              :: acceptUnboundOrbits =.false.                                  
    double precision                          , dimension(3)           :: relativePosition            , relativeVelocity
    double precision                                                   :: timeUntilMerging            , radiusPericenter, &
         &                                                                radiusApocenter             , radiusVirial 
    type            (keplerOrbit             )                         :: orbit                                                            
    type            (varying_string          )                         :: message

    select type (self)
    class is (mergerTreeConstructorRead)
       if (self%presetMergerTimes) then
          ! If merger times are to preset, compute subresolution merging time.
          basicSatellite     => nodeSatellite%basic    (                 )
          basicHost          => nodeHost     %basic    (                 )
          positionSatellite  => nodeSatellite%position (                 )
          positionHost       => nodeHost     %position (                 )
          satelliteSatellite => nodeSatellite%satellite(autoCreate=.true.)
          relativePosition   =  positionSatellite%position()-positionHost%position()
          relativeVelocity   =  positionSatellite%velocity()-positionHost%velocity()
          orbit              =  readOrbitConstruct(basicSatellite%mass(),basicHost%mass(),relativePosition,relativeVelocity)
          timeUntilMerging   =  self%satelliteMergingTimescales_%timeUntilMerging(nodeSatellite,orbit)
          call satelliteSatellite%mergeTimeSet(timeUntilMerging)
          ! Set target node.
          nodeTarget => nodeHost
          do while (.true.)
             basicTarget => nodeTarget%basic()
             if (basicTarget%time() <= satelliteSatellite%timeOfMerging() .or. .not.associated(nodeTarget%parent)) exit
             nodeTarget => nodeTarget%parent
          end do
          nodeSatellite%mergeTarget   => nodeTarget
          nodeSatellite%siblingMergee => nodeTarget   %firstMergee
          nodeTarget   %firstMergee   => nodeSatellite
          ! Assign virial orbit if necessary.
          if (self%presetOrbits) then
             ! Propagate orbit to the virial radius.
             radiusPericenter     =  orbit               %radiusPericenter   (        )
             radiusApocenter      =  orbit               %radiusApocenter    (        )
             radiusVirial         =  self%darkMatterHaloScale_%virialRadius       (nodeHost)
             ! Check if the orbit intersects the virial radius.
             if     (                                                                      &
                  &    radiusVirial >= radiusPericenter                                    &
                  &  .and.                                                                 &
                  &   (radiusVirial <= radiusApocenter          .or. .not.orbit%isBound()) &
                  &  .and.                                                                 &
                  &   (.not.self%presetOrbitsBoundOnly .or.      orbit%isBound()) &
                  & ) then
                call orbit%propagate(radiusVirial,infalling=.true.)
                ! Set the orbit.
                call satelliteSatellite%virialOrbitSet(orbit)
                ! If the satellite component supports full phase-space position, set that also.
                if (satelliteSatellite%positionIsSettable()) call satelliteSatellite%positionSet(relativePosition)
                if (satelliteSatellite%velocityIsSettable()) call satelliteSatellite%velocitySet(relativeVelocity)
             else if (self%presetOrbitsSetAll) then
                ! The given orbit does not cross the virial radius. Since all orbits must be set, choose an orbit at random.
                orbit=self%virialOrbit_%orbit(nodeSatellite,nodeHost,acceptUnboundOrbits)
                call satelliteSatellite%virialOrbitSet(orbit)
             else if (self%presetOrbitsAssertAllSet) then
                message='virial orbit could not be set for node '
                message=message//nodeSatellite%index()//char(10)
                message=message//' -> set [presetOrbitsAssertAllSet]=false to ignore this problem'//char(10)
                message=message//'    (this may lead to other problems)'
                call Galacticus_Error_Report(message//{introspection:location})
             end if
          end if
       else if (self%presetMergerNodes) then
          ! If merger nodes are to be set, set that now.
          nodeSatellite%mergeTarget   => nodeHost
          nodeSatellite%siblingMergee => nodeHost     %firstMergee
          nodeHost     %firstMergee   => nodeSatellite
       end if
    class default
       call Galacticus_Error_Report('incorrect class'//{introspection:location})
    end select
    return
  end subroutine readInterTreeMergeTimeSet
