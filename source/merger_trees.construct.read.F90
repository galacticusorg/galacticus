! Copyright 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017
!!    Andrew Benson <abenson@carnegiescience.edu>
!!
!! This file is part of Galacticus.
!!
!!    Galacticus is free software: you can redistribute it and/or modify
!!    it under the terms of the GNU General Public License as published by
!!    the Free Software Foundation, either version 3 of the License, or
!!    (at your option) any later version.
!!
!!    Galacticus is distributed in the hope that it will be useful,
!!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!!    GNU General Public License for more details.
!!
!!    You should have received a copy of the GNU General Public License
!!    along with Galacticus.  If not, see <http://www.gnu.org/licenses/>.

!% Contains a module which implements reading of merger trees from a file.

module Merger_Tree_Read
  !% Implements reading of merger trees from a file.
  use, intrinsic :: ISO_C_Binding
  use            :: OMP_Lib
  use            :: Galacticus_Nodes
  use            :: ISO_Varying_String
  use            :: Kind_Numbers
  use            :: Merger_Tree_Read_Importers
  use            :: Dark_Matter_Profiles_Concentration
  use            :: Satellite_Merging_Timescales
  implicit none
  private
  public :: Merger_Tree_Read_Initialize, Merger_Tree_Read_Close

  ! The name of the file from which to read merger trees and its internal object.
  integer                                                                                              :: mergerTreeReadFileCount
  integer                                                                                              :: mergerTreeReadFileCurrent
  type            (varying_string                ), allocatable, dimension(:)                          :: mergerTreeReadFileName                                                                       
  class           (mergerTreeImporterClass       )                                           , pointer :: defaultImporter                                                                              
  logical                                                                                              :: importerOpen                             =.false.
  
  ! Index of the next merger tree to read.
  integer                                                                                              :: nextTreeToRead                           =0
  integer                                                                                              :: nextTreeToReadThread                     =0
  !$omp threadprivate(nextTreeToReadThread)
    
  ! Index of the first tree to process.
  integer         (kind=kind_int8                )                                                     :: mergerTreeReadBeginAt                                                                        
  
  ! Volume weight factor for trees.
  double precision                                                                                     :: treeVolumeWeightCurrent                                                                      
  !$omp threadprivate(treeVolumeWeightCurrent)

  ! Flag indicating if the same tree should always be assigned to the same thread.
  logical                                                                                              :: mergerTreeReadFixedThreadAssignment
  
  ! Flag indicating whether branch jumps are allowed.
  logical                                                                                              :: mergerTreeReadAllowBranchJumps                                                               
  
  ! Flag indicating whether subhalo promotions are allowed.
  logical                                                                                              :: mergerTreeReadAllowSubhaloPromotions                                                         

  ! Maximum size of forests to be processed as whole rather than as individual trees.
  integer         (c_size_t                      )                                                     :: mergerTreeReadForestSizeMaximum
  
  ! Flags indicating whether or not to preset subhalo properties.
  logical                                                                                              :: mergerTreeReadPresetMergerTimes                                                              
  logical                                                                                              :: mergerTreeReadPresetMergerNodes                                                              
  logical                                                                                              :: mergerTreeReadPresetSubhaloMasses                                                            
  logical                                                                                              :: mergerTreeReadPresetSubhaloIndices
  logical                                                                                              :: mergerTreeReadPresetPositions                                                                
  logical                                                                                              :: mergerTreeReadPresetScaleRadii                    , mergerTreeReadPresetScaleRadiiFailureIsFatal
  double precision                                                                                     :: mergerTreeReadPresetScaleRadiiMinimumMass         , mergerTreeReadPresetScaleRadiiConcentrationMinimum, &
       &                                                                                                  mergerTreeReadPresetScaleRadiiConcentrationMaximum
  logical                                                                                              :: mergerTreeReadPresetSpins                         , mergerTreeReadPresetSpins3D                       , &
       &                                                                                                  mergerTreeReadPresetUnphysicalSpins
  logical                                                                                              :: mergerTreeReadPresetOrbits                        , mergerTreeReadPresetOrbitsAssertAllSet            , & 
       &                                                                                                  mergerTreeReadPresetOrbitsBoundOnly               , mergerTreeReadPresetOrbitsSetAll          
  logical                                                                                              :: mergerTreeReadPresetParticleCounts                , mergerTreeReadPresetVelocityMaxima                , &
       &                                                                                                  mergerTreeReadPresetVelocityDispersions
  integer                                                                                              :: mergerTreeReadSubhaloAngularMomentaMethod
  integer                                                                         , parameter          :: mergerTreeReadSubhaloAngularMomentaScale    =0
  integer                                                                         , parameter          :: mergerTreeReadSubhaloAngularMomentaSummation=1

  ! Option controlling fatality of missing host node condition.
  logical                                                                                              :: mergerTreeReadMissingHostsAreFatal
  
  ! Option controlling whether tree indices should always be set to the corresponding node index.
  logical                                                                                              :: mergerTreeReadTreeIndexToRootNodeIndex                                                       
  
  ! Labels used for node properties.
  integer                                                                         , parameter          :: nodeIsUnreachable                        =-1                                                 
  integer                                                                         , parameter          :: nodeIsReachable                          = 0                                                  
  
  ! Internal list of output times and the relative tolerance used to "snap" nodes to output times.
  integer         (c_size_t                           )                                                :: outputTimesCount                                                                             
  double precision                                                                                     :: mergerTreeReadOutputTimeSnapTolerance                                                        
  double precision                                     , allocatable, dimension(:)                     :: outputTimes                                                                                  
  
  ! Node used in root finding.
  class           (nodeComponentDarkMatterProfile     )                                      , pointer :: darkMatterProfileActive                                                             
  class           (nodeComponentBasic                 )                                      , pointer :: basicActive                                                                         
  type            (treeNode                           )                                      , pointer :: activeNode                                                                                   
  double precision                                                                                     :: halfMassRadius                                                                                               
  !$omp threadprivate(darkMatterProfileActive,basicActive,activeNode,halfMassRadius)

  ! Sorted node index list.
  integer         (c_size_t                           ), allocatable, dimension(:)                     :: descendentLocations                              , nodeLocations                             
  integer         (kind=kind_int8                     ), allocatable, dimension(:)                     :: descendentIndicesSorted                          , nodeIndicesSorted                         
  !$omp threadprivate(descendentLocations,nodeLocations,descendentIndicesSorted,nodeIndicesSorted)

  ! Split forest data.
  !$ integer      (omp_lock_kind                      )                                                :: splitForestLock
  integer                                                                                              :: splitForestActiveForest
  integer         (c_size_t                           )                                                :: splitForestNextTree                              , splitForestUniqueID
  integer         (c_size_t                           ), allocatable, dimension(:)                     :: splitForestTreeSize                              , splitForestTreeStart, &
       &                                                                                                  splitForestMapIndex
  integer         (kind=kind_int8                     ), allocatable, dimension(:)                     :: splitForestPushTo                                , splitForestPullFrom
  integer                                              , allocatable, dimension(:)                     :: splitForestPushType
  double precision                                     , allocatable, dimension(:)                     :: splitForestPushTime
  logical                                              , allocatable, dimension(:)                     :: splitForestIsPrimary                             , splitForestPushDone , &
       &                                                                                                  splitForestPullDone

  ! Enumeration of cross-tree event types.
  !# <enumeration>
  !#  <name>pushType</name>
  !#  <description>Cross-type event type enumeration.</description>
  !#  <entry label="branchJump"               />
  !#  <entry label="subhaloPromotion"         />
  !# </enumeration>
  
  ! Concentration class to use when concentration can not be constructed from imported data.
  class           (darkMatterProfileConcentrationClass)                                      , pointer :: fallbackConcentration
  
  ! Record of warnings issued.
  logical                                                                                              :: warningNestedHierarchyIssued             =.false.                                            
  logical                                                                                              :: warningSplitForestNestedHierarchyIssued  =.false.                                            

  ! Timing data.
  real                                                 , allocatable, dimension(:)                     :: timingTimes
  type            (varying_string                     ), allocatable, dimension(:)                     :: timingLabels

  ! Subresolution merging.
  logical                                                                                              :: subresolutionMergingInitialized          =.false.
  class           (satelliteMergingTimescalesClass    ), pointer                                       :: subresolutionSatelliteMergingTimescales                                               

  ! Iterator object for iterating over progenitor nodes.
  type :: progenitorIterator
     integer(c_size_t      ) :: progenitorLocation
     integer(kind=kind_int8) :: progenitorIndex   , targetIndex 
     logical                 :: progenitorsFound                                  
   contains
     !@ <objectMethods>
     !@   <object>progenitorIterator</object>
     !@   <objectMethod>
     !@     <method>descendentSet</method>
     !@     <type>\void</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)\textgreater} node\argin, \textcolor{red}{\textless class(nodeData)(:)\textgreater} nodes\argin</arguments>
     !@     <description>Set the target descendent node and initialize the iterator.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>next</method>
     !@     <type>\logicalzero</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)(:)\textgreater} nodes\argin</arguments>
     !@     <description>Move to the next progenitor. Returns true if the next progenitor exists, false otherwise.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>index</method>
     !@     <type>\textcolor{red}{\textless integer(kind=kind\_int8)\textgreater}</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)(:)\textgreater} nodes\argin</arguments>
     !@     <description>Return the index of the current progenitor.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>current</method>
     !@     <type>\textcolor{red}{\textless *class(nodeData)\textgreater}</type>
     !@     <arguments>\textcolor{red}{\textless class(nodeData)(:)\textgreater} nodes\argin</arguments>
     !@     <description>Return a pointer to the current progenitor.</description>
     !@   </objectMethod>
     !@   <objectMethod>
     !@     <method>exist</method>
     !@     <type>\logicalzero</type>
     !@     <arguments></arguments>
     !@     <description>Return true if any progenitors exist, false otherwise.</description>
     !@   </objectMethod>
     !@ </objectMethods>
     procedure :: descendentSet=>progenitorIteratorDescendentSet 
     procedure :: next         =>progenitorIteratorNext          
     procedure :: index        =>progenitorIteratorIndex         
     procedure :: current      =>progenitorIteratorCurrent       
     procedure :: exist        =>progenitorIteratorExist         
  end type progenitorIterator

contains

  !# <mergerTreeConstructMethod>
  !#  <unitName>Merger_Tree_Read_Initialize</unitName>
  !# </mergerTreeConstructMethod>
  subroutine Merger_Tree_Read_Initialize(mergerTreeConstructMethod,Merger_Tree_Construct)
    !% Initializes the merger tree reading module.
    use, intrinsic :: ISO_C_Binding
    use Input_Parameters
    use Input_Parameters
    use Galacticus_Error
    use Galacticus_Display
    use Galacticus_Output_Times
    use Numerical_Constants_Astronomical
    use Numerical_Constants_Boolean
    use Memory_Management
    implicit none
    type     (varying_string          ), intent(in   )          :: mergerTreeConstructMethod 
    procedure(Merger_Tree_Read_Do     ), intent(inout), pointer :: Merger_Tree_Construct     
    integer  (c_size_t                )                         :: iOutput                   
    type     (varying_string          )                         :: message                  ,  mergerTreeReadSubhaloAngularMomentaMethodText
    type     (inputParameters         )                         :: subParameters
    
    ! Check if our method is to be used.
    if (mergerTreeConstructMethod == 'read') then
       ! Assign pointer to our merger tree construction subroutine.
       Merger_Tree_Construct => Merger_Tree_Read_Do
       ! Read parameters for halo mass sampling.
       mergerTreeReadFileCount=globalParameters%count('mergerTreeReadFileName')
       allocate(mergerTreeReadFileName(mergerTreeReadFileCount))
       !# <inputParameter>
       !#   <name>mergerTreeReadFileName</name>
       !#   <description>The name of the file(s) from which merger tree data should be read when using the {\normalfont \ttfamily [mergerTreeConstructMethod]}$=${\normalfont \ttfamily read} tree construction method.</description>
       !#   <type>string</type>
       !#   <cardinality>1..</cardinality>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadForestSizeMaximum</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>huge(0_c_size_t)</defaultValue>
       !#   <description>The maximum number of nodes allowed in a forest before it will be broken up into trees and processed individually.</description>
       !#   <source>globalParameters</source>
       !#   <type>integer</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadFixedThreadAssignment</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>.false.</defaultValue>
       !#   <description>If true, assignment of trees to OpenMP threads will be done deterministically. Otherwise, assignment is on a first-come-first-served basis.</description>
       !#   <source>globalParameters</source>
       !#   <type>boolean</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadPresetMergerTimes</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>.true.</defaultValue>
       !#   <description>Specifies whether merging times for subhalos should be preset when reading merger trees from a file.</description>
       !#   <source>globalParameters</source>
       !#   <type>boolean</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadPresetMergerNodes</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>.true.</defaultValue>
       !#   <description>Specifies whether the target nodes for mergers should be preset (i.e. determined from descendent nodes). If they are not, merging will be with each satellite's host node.</description>
       !#   <source>globalParameters</source>
       !#   <type>boolean</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadPresetSubhaloMasses</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>.true.</defaultValue>
       !#   <description>Specifies whether subhalo mass should be preset when reading merger trees from a file.</description>
       !#   <source>globalParameters</source>
       !#   <type>boolean</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadSubhaloAngularMomentaMethod</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>var_str('summation')</defaultValue>
       !#   <description>Specifies how to account for subhalo angular momentum when adding subhalo mass to host halo mass.</description>
       !#   <source>globalParameters</source>
       !#   <type>boolean</type>
       !#   <variable>mergerTreeReadSubhaloAngularMomentaMethodText</variable>
       !# </inputParameter>
       select case (char(mergerTreeReadSubhaloAngularMomentaMethodText))
       case ("scale"    )
          mergerTreeReadSubhaloAngularMomentaMethod=mergerTreeReadSubhaloAngularMomentaScale
       case ("summation")
          mergerTreeReadSubhaloAngularMomentaMethod=mergerTreeReadSubhaloAngularMomentaSummation
       case default
          call Galacticus_Error_Report('[mergerTreeReadSubhaloAngularMomentaMethod] must be either "scale" or "summation"'//{introspection:location})
       end select       
       !# <inputParameter>
       !#   <name>mergerTreeReadPresetSubhaloIndices</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>.true.</defaultValue>
       !#   <description>Specifies whether subhalo indices should be preset when reading merger trees from a file.</description>
       !#   <source>globalParameters</source>
       !#   <type>boolean</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadPresetPositions</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>.true.</defaultValue>
       !#   <description>Specifies whether node positions should be preset when reading merger trees from a file.</description>
       !#   <source>globalParameters</source>
       !#   <type>boolean</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadPresetScaleRadii</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>.true.</defaultValue>
       !#   <description>Specifies whether node scale radii should be preset when reading merger trees from a file.</description>
       !#   <source>globalParameters</source>
       !#   <type>boolean</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadPresetScaleRadiiFailureIsFatal</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>.true.</defaultValue>
       !#   <description>Specifies whether failure to set a node scale radii should be regarded as a fatal error. (If not, a fallback method to set scale radius is used in such cases.)</description>
       !#   <source>globalParameters</source>
       !#   <type>boolean</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadPresetScaleRadiiConcentrationMinimum</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>3.0d0</defaultValue>
       !#   <description>The lowest concentration ($c=r_{\mathrm vir}/r_{\mathrm s}$) allowed when setting scale radii, $r_{\mathrm s}$.</description>
       !#   <source>globalParameters</source>
       !#   <type>boolean</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadPresetScaleRadiiConcentrationMaximum</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>60.0d0</defaultValue>
       !#   <description>The largest concentration ($c=r_{\mathrm vir}/r_{\mathrm s}$) allowed when setting scale radii, $r_{\mathrm s}$.</description>
       !#   <source>globalParameters</source>
       !#   <type>boolean</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadPresetScaleRadiiMinimumMass</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>0.0d0</defaultValue>
       !#   <description>The minimum halo mass for which scale radii should be preset (if {\normalfont \ttfamily [mergerTreeReadPresetScaleRadii]}$=${\normalfont \ttfamily true}).</description>
       !#   <source>globalParameters</source>
       !#   <type>boolean</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadPresetUnphysicalSpins</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>.false.</defaultValue>
       !#   <description>When reading merger trees from file and presetting halo spins, detect unphysical (&lt;=0) spins and preset them using the selected halo spin method.</description>
       !#   <source>globalParameters</source>
       !#   <type>boolean</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadPresetSpins</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>.true.</defaultValue>
       !#   <description>Specifies whether node spins should be preset when reading merger trees from a file.</description>
       !#   <source>globalParameters</source>
       !#   <type>boolean</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadPresetSpins3D</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>.false.</defaultValue>
       !#   <description>Specifies whether node 3-D spin vectors should be preset when reading merger trees from a file.</description>
       !#   <source>globalParameters</source>
       !#   <type>boolean</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadPresetOrbits</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>.true.</defaultValue>
       !#   <description>Specifies whether node orbits should be preset when reading merger trees from a file.</description>
       !#   <source>globalParameters</source>
       !#   <type>boolean</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadPresetOrbitsSetAll</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>.true.</defaultValue>
       !#   <description>Forces all orbits to be set. If the computed orbit does not cross the virial radius, then select one at random instead.</description>
       !#   <source>globalParameters</source>
       !#   <type>boolean</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadPresetOrbitsAssertAllSet</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>.true.</defaultValue>
       !#   <description>Asserts that all virial orbits must be preset. If any can not be set, \glc\ will stop.</description>
       !#   <source>globalParameters</source>
       !#   <type>boolean</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadPresetOrbitsBoundOnly</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>.true.</defaultValue>
       !#   <description>Specifies whether only bound node orbits should be set.</description>
       !#   <source>globalParameters</source>
       !#   <type>boolean</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadPresetParticleCounts</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>.false.</defaultValue>
       !#   <description>Specifies whether node particle counts should be preset when reading merger trees from a file.</description>
       !#   <source>globalParameters</source>
       !#   <type>boolean</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadPresetVelocityMaxima</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>.false.</defaultValue>
       !#   <description>Specifies whether node rotation curve velocity maxima should be preset when reading merger trees from a file.</description>
       !#   <source>globalParameters</source>
       !#   <type>boolean</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadPresetVelocityDispersions</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>.false.</defaultValue>
       !#   <description>Specifies whether node velocity dispersions should be preset when reading merger trees from a file.</description>
       !#   <source>globalParameters</source>
       !#   <type>boolean</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadBeginAt</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>-1_kind_int8</defaultValue>
       !#   <description>Specifies the index of the tree to begin at. (Use -1 to always begin with the first tree.)</description>
       !#   <source>globalParameters</source>
       !#   <type>integer</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadOutputTimeSnapTolerance</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>0.0d0</defaultValue>
       !#   <description>The relative tolerance required to ``snap'' a node time to the closest output time.</description>
       !#   <source>globalParameters</source>
       !#   <type>real</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadMissingHostsAreFatal</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>.true.</defaultValue>
       !#   <description>Specifies whether nodes with missing host nodes should be considered to be fatal---see \S\ref{sec:MergerTreeFileProcessing}.</description>
       !#   <source>globalParameters</source>
       !#   <type>boolean</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadTreeIndexToRootNodeIndex</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>.false.</defaultValue>
       !#   <description>Specifies whether tree indices should always be set to the index of their root node.</description>
       !#   <source>globalParameters</source>
       !#   <type>boolean</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadAllowBranchJumps</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>.true.</defaultValue>
       !#   <description>Specifies whether nodes are allowed to jump between branches.</description>
       !#   <source>globalParameters</source>
       !#   <type>boolean</type>
       !# </inputParameter>
       !# <inputParameter>
       !#   <name>mergerTreeReadAllowSubhaloPromotions</name>
       !#   <cardinality>1</cardinality>
       !#   <defaultValue>.true.</defaultValue>
       !#   <description>Specifies whether subhalos are permitted to be promoted to being isolated halos.</description>
       !#   <source>globalParameters</source>
       !#   <type>boolean</type>
       !# </inputParameter>

       ! Get fallback concentration method.
       if (globalParameters%isPresent('mergerTreeReadConcentrationFallbackMethod')) then
          subParameters=globalParameters%subParameters('mergerTreeReadConcentrationFallbackMethod')
          fallbackConcentration => darkMatterProfileConcentration(subParameters)
       else
          fallbackConcentration => darkMatterProfileConcentration(             )
       end if
              
       ! Get array of output times.
       outputTimesCount=Galacticus_Output_Time_Count()
       call allocateArray(outputTimes,[outputTimesCount])
       do iOutput=1,outputTimesCount
          outputTimes(iOutput)=Galacticus_Output_Time(iOutput)
       end do

       ! Open the file.
       defaultImporter => mergerTreeImporter()
       mergerTreeReadFileCurrent=1
       call defaultImporter%open(mergerTreeReadFileName(mergerTreeReadFileCurrent))
       importerOpen=.true.

       ! Validate input parameters.
       if (mergerTreeReadPresetMergerNodes.and..not.mergerTreeReadPresetMergerTimes) then
          message="presetting of merger target nodes requires that merger times also be preset;"//char(10)
          message=message//" try setting [mergerTreeReadPresetMergerTimes]=true."//char(10)
          if (defaultimporter%treesHaveSubhalos() /= booleanTrue) then
             message=message//" Note: presetting merger target nodes and merger times is usually only a good idea when subhalo information is present in the merger trees"
             if (defaultimporter%treesHaveSubhalos() == booleanFalse) then
                message=message//" (which the current trees do not)"
             else
                message=message//" (subhalo presence in the current trees was not specified)"
             end if
          end if
          call Galacticus_Error_Report(message//{introspection:location})
       end if

       ! Warn about lack of branch jumps and subhalo promotions if split forests are being used.
       if (mergerTreeReadForestSizeMaximum > 0_c_size_t .and. .not.(mergerTreeReadAllowBranchJumps .and. mergerTreeReadAllowSubhaloPromotions)) then
          message='WARNING: large forests may be split for processing but '
          if (                                              .not.mergerTreeReadAllowBranchJumps) message=message//' branch jumps'
          if (.not.mergerTreeReadAllowSubhaloPromotions.and..not.mergerTreeReadAllowBranchJumps) message=message//' and'
          if (.not.mergerTreeReadAllowSubhaloPromotions                                        ) message=message//' subhalo promotions'          
          message=message//' are not allowed - this can result in inconsistent treatment between split and unsplit forest processing'
          call Galacticus_Warn(message)
       end if
       
       ! Fixed thread assignment currently not possible with multiple files.
       if (mergerTreeReadFixedThreadAssignment .and. mergerTreeReadFileCount > 1) call Galacticus_Error_Report("fixed thread assignment is not possible with multiple tree files"//{introspection:location})
       
       ! Warn if subhalo promotions are allowed, but branch jumps are not.
       if (mergerTreeReadAllowSubhaloPromotions.and..not.mergerTreeReadAllowBranchJumps) then
          message='WARNING: allowing subhalo promotions while not allowing branch jumps can lead to deadlocking of trees.'//char(10)
          message=message//'Be sure that your trees have no promotion events for subhalos which survive beyond the end of their original branch'//char(10)
          message=message//'For example, without branch jumping, "a" in the following tree (in which "==>" indicates subhalo host) is stuck in "1", so it cannot evolve to become "b" causing the subhalo promotion "b" to "c" to be unreachable, resulting in a deadlock of the tree:'//char(10)//char(10)
          message=message//' ---   -----'//char(10)
          message=message//' |a|==>| 1 |'//char(10)
          message=message//' ---   -----'//char(10)
          message=message//'  |         '//char(10)
          message=message//' ---   -----'//char(10)
          message=message//' |b|==>| 2 |'//char(10)
          message=message//' ---   -----'//char(10)
          message=message//'  |      |  '//char(10)
          message=message//' ---   -----'//char(10)
          message=message//' |c|   | 3 |'//char(10)
          message=message//' ---   -----'//{introspection:location}//char(10)
          call Galacticus_Warn(message)
       end if

       ! Warn if subhalo promotions are allowed, but branch jumps are not.
       if (mergerTreeReadAllowBranchJumps.and..not.mergerTreeReadPresetMergerTimes) then
          message='WARNING: allowing branch jumps while not presetting merger times can lead to tree deadlock if merging occurs prior to the jumped-to node time and before an output time which blocks the jumped-to node''s child.'//char(10)
          message=message//'For example, "a" in the following tree (in which "<==" indicates subhalo host) jump from "3" to "1", but cannot merge with "1" since "1" still has a child, and that child, "2", cannot reach one because it is blocked by the output time, resulting in a deadlock of the tree:'//char(10)//char(10)
          message=message//' ---           ---'//char(10)
          message=message//' |1|<==========|a|'//char(10)
          message=message//' ---           ---'//char(10)
          message=message//'  ^             | '//char(10)
          message=message//'  |             | '//char(10)
          message=message//' ~~~output time~~~'//char(10)
          message=message//'  |             | '//char(10)
          message=message//' ~~~merge  time~~~'//char(10)
          message=message//'  |             | '//char(10)
          message=message//' ---     ---   ---'//char(10)
          message=message//' |2|     |3|<==|a|'//char(10)
          message=message//' ---     ---   ---'//{introspection:location}//char(10)
          call Galacticus_Warn(message)
       end if

       ! Perform sanity checks if subhalos are not included.
       if (defaultimporter%treesHaveSubhalos() == booleanFalse) then
          if (mergerTreeReadPresetMergerTimes   ) call Galacticus_Error_Report('cannot preset merger times as no subhalos are present; try setting [mergerTreeReadPresetMergerTimes]=false'//{introspection:location})
          if (mergerTreeReadPresetMergerNodes   ) call Galacticus_Error_Report('cannot preset merger nodes as no subhalos are present; try setting [mergerTreeReadPresetMergerNodes]=false'//{introspection:location})
          if (mergerTreeReadPresetSubhaloMasses ) call Galacticus_Error_Report('cannot preset subhalo masses as no subhalos are present; try setting [mergerTreeReadPresetSubhaloMasses]=false'//{introspection:location})
          if (mergerTreeReadPresetSubhaloIndices) call Galacticus_Error_Report('cannot preset subhalo indices as no subhalos are present; try setting [mergerTreeReadPresetSubhaloIndices]=false'//{introspection:location})
       end if
       ! Determine if subhalo masses have been included in halo masses.   
       if (defaultImporter%treesAreSelfContained() == booleanFalse) call Galacticus_Error_Report('only self-contained trees are supported'//{introspection:location})   
       ! Check that position information is present if required.
       if     (                                                                                    &
            &   (                                                                                  &
            &     mergerTreeReadPresetPositions                                                    &
            &    .or.                                                                              &
            &     mergerTreeReadPresetOrbits                                                       &
            &   )                                                                                  &
            &  .and.                                                                               &
            &   .not.defaultImporter%positionsAvailable(positions=.true.,velocities=.true.)        &
            & )                                                                                    &
            & call Galacticus_Error_Report(                                                        &
            &                              "presetting positions requires that both position and   &
            &                               velocity datasets be present in merger tree file"   // &
            &                              {introspection:location}                                &
            &                             )
       ! Check that half-mass radius information is present if required.
       if     (                                                                                                                                                    &
            &   mergerTreeReadPresetScaleRadii                                                                                                                     &
            &  .and.                                                                                                                                               &
            &   .not.defaultImporter%scaleRadiiAvailable()                                                                                                         &
            & )  call Galacticus_Error_Report(                                                                                                                     &
            &                                "presetting scale radii requires that at least one of halfMassRadius or scaleRadius datasets be present in merger"//  &
            &                                "tree file; try setting"//char(10)//"  [mergerTreeReadPresetScaleRadii]=false"                                    //  &
            &                                {introspection:location}                                                                                              &
            &                               )
       ! Check that particle count information is present if required.
       if (                                                                                                                                   &
            &   mergerTreeReadPresetParticleCounts                                                                                            &
            &  .and.                                                                                                                          &
            &   .not.defaultImporter%particleCountAvailable()                                                                                 &
            & )  call Galacticus_Error_Report(                                                                                                &
            &                                "presetting particle counts requires that the particleCount dataset be present in the merger"//  &
            &                                "tree file; try setting"//char(10)//"  [mergerTreeReadPresetParticleCount]=false"            //  &
            &                                {introspection:location}                                                                         &
            &                               )
       ! Check that velocity maximum information is present if required.
       if (                                                                                                                                     &
            &   mergerTreeReadPresetVelocityMaxima                                                                                              &
            &  .and.                                                                                                                            &
            &   .not.defaultImporter%velocityMaximumAvailable()                                                                                 &
            & )  call Galacticus_Error_Report(                                                                                                  &
            &                                "presetting velocity maxima requires that the velocityMaximum dataset be present in the merger"//  &
            &                                "tree file; try setting"//char(10)//"  [mergerTreeReadPresetVelocityMaxima]=false"             //  &
            &                                {introspection:location}                                                                           &
            &                               )
       ! Check that velocity dispersion information is present if required.
       if (                                                                                                                                             &
            &   mergerTreeReadPresetVelocityDispersions                                                                                                 &
            &  .and.                                                                                                                                    &
            &   .not.defaultImporter%velocityDispersionAvailable()                                                                                      &
            & )  call Galacticus_Error_Report(                                                                                                          &
            &                                "presetting velocity dispersions requires that the velocityDispersion dataset be present in the merger"//  &
            &                                "tree file; try setting"//char(10)//"  [mergerTreeReadPresetVelocityDispersions]=false"                //  &
            &                                {introspection:location}                                                                                   &
            &                               )
       ! Check that angular momentum information is present if required.
       if     (                                                                                                        &
            &   mergerTreeReadPresetSpins                                                                              &
            &  .and.                                                                                                   &
            &   .not.                                                                                                  &
            &        (                                                                                                 &
            &          defaultImporter%          spinAvailable()                                                       &
            &         .or.                                                                                             &
            &          defaultImporter%angularMomentaAvailable()                                                       &
            &        )                                                                                                 &
            & )                                                                                                        &
            & call Galacticus_Error_Report(                                                                            &
            &                              "presetting spins requires that the spin or angularMomentum datasets        &
            &                               be present in merger tree file; try setting"                            // &
            &                              char(10)                                                                 // &
            &                              " [mergerTreeReadPresetSpins]=false"                                     // &
            &                                {introspection:location}                                                  &
            &                             )
       if     (                                                                                                        &
            &   mergerTreeReadPresetSpins3D                                                                            &
            &  .and.                                                                                                   &
            &   .not.                                                                                                  &
            &        (                                                                                                 &
            &          defaultImporter%          spin3DAvailable()                                                     &
            &         .or.                                                                                             &
            &          defaultImporter%angularMomenta3DAvailable()                                                     &
            &        )                                                                                                 &
            & )                                                                                                        &
            & call Galacticus_Error_Report(                                                                            &
            &                              "presetting spin vectors requires that the spin or angularMomentum vector   &
            &                               datasets be present in merger tree file; try setting"                   // &
            &                              char(10)                                                                 // &
            &                              " [mergerTreeReadPresetSpins3D]=false"                                   // &
            &                                {introspection:location}                                                  &
            &                             )
       ! Create an OpenMP lock that will allow threads to coordinate access to split forest data.
       !$ call OMP_Init_Lock(splitForestLock)
    end if
    return
  end subroutine Merger_Tree_Read_Initialize

  !# <hdfPreCloseTask>
  !# <unitName>Merger_Tree_Read_Close</unitName>
  !# </hdfPreCloseTask>
  subroutine Merger_Tree_Read_Close()
    !% Close the importer object.
    implicit none

    ! Close the importer.
    if (importerOpen) then
       call defaultImporter%close()
       importerOpen=.false.
    end if
    return
  end subroutine Merger_Tree_Read_Close
  
  subroutine Merger_Tree_Read_Do(tree,skipTree)
    !% Read a merger tree from file.
    use Galacticus_State
    use Cosmology_Functions
    use Galacticus_Error
    use String_Handling
    use Memory_Management
    use Arrays_Search
    use Array_Utilities
    use Numerical_Comparison
    use Vectors
    use Sort
    !$ use OMP_Lib
    implicit none
    type            (mergerTree                    )                             , intent(inout), target :: tree                               
    logical                                                                      , intent(in   )         :: skipTree                               
    integer         (kind=kind_int8                ), allocatable, dimension(:  )                        :: historyIndex
    double precision                                , allocatable, dimension(:  )                        :: historyMass           , historyTime       
    double precision                                , allocatable, dimension(:,:)                        :: position              , velocity          
    class           (nodeDataMinimal               ), allocatable, dimension(:  )               , target :: nodes
    type            (treeNodeList                  ), allocatable, dimension(:  )                        :: nodeList                           
    logical                                         , allocatable, dimension(:  )                        :: childIsSubhalo                         
    double precision                                             , dimension(3  )                        :: relativePosition      , relativeVelocity , &
         &                                                                                                  orbitalAngularMomentum
    integer         (c_size_t                      ), allocatable, dimension(:  )                        :: nodeSubset
    integer                                                                                              :: isolatedNodeCount 
    integer         (c_size_t                      )                                                     :: historyCountMaximum   , iNode            , &
         &                                                                                                  iOutput
    logical                                                                                              :: haveTree              , processTree      , &
         &                                                                                                  newTreeFileRequired   , returnSplitForest
    type            (varying_string                )                                                     :: message
    integer                                                                                              :: nextTreeToReadActual
    double precision                                                                                     :: uniformRandom
    
    ! Obtain a lock on split forest data if necessary.
    !$ if (mergerTreeReadForestSizeMaximum > 0) call OMP_Set_Lock(splitForestLock)
    ! Enter loop which suspends threads when a new tree file is needed.
    newTreeFileRequired=.true.
    treeFile : do while (newTreeFileRequired)
       newTreeFileRequired=.false.
       !$omp critical(mergerTreeReadTree)
       ! Determine if we have any split forests to return.
       returnSplitForest=allocated(splitForestTreeSize)
       ! If no split forests exists presently, get the next forest to read.
       if (.not.returnSplitForest) then
          ! Increment the tree to read index.
          !$ if (mergerTreeReadFixedThreadAssignment) then
          !$    nextTreeToReadThread=nextTreeToReadThread+1
          !$    nextTreeToReadActual=nextTreeToReadThread
          !$ else
          nextTreeToRead      =nextTreeToRead      +1
          nextTreeToReadActual=nextTreeToRead
          !$ end if
          ! Move to the next tree file if necessary.
          if (nextTreeToReadActual > defaultImporter%treeCount()) then
             newTreeFileRequired=.true.
          else
             ! Keep incrementing the tree index until we find the first tree to process (if we haven't done so already). Also skip trees
             ! that contain 1 or fewer nodes and these are unprocessable.
             if (nextTreeToReadActual <= defaultImporter%treeCount()) then
                do while (                                                                            &
                     &     (                                                                          &
                     &       mergerTreeReadBeginAt                           > 0                      &
                     &      .and.                                                                     &
                     &       defaultImporter%treeIndex(nextTreeToReadActual) /= mergerTreeReadBeginAt &
                     &     )                                                                          &
                     &    .or.                                                                        &
                     &       defaultImporter%nodeCount(nextTreeToReadActual) <= 1                     &
                     !$ &    .or.                                                                        &
                     !$ &     (                                                                          &
                     !$ &       mergerTreeReadFixedThreadAssignment                                      &
                     !$ &      .and.                                                                     &
                     !$ &       mod(nextTreeToReadActual,omp_get_num_threads()) /= omp_get_thread_num()  &
                     !$ &     )                                                                          &
                     &   )
                   nextTreeToReadActual=nextTreeToReadActual+1
                   ! If the end of the list has been reached, exit.
                   if (nextTreeToReadActual > defaultImporter%treeCount()) then
                      newTreeFileRequired=.true.                   
                      exit
                   end if
                end do
                ! Record if we've now found the first merger tree to process.
                if     (                                                                          &
                     &   mergerTreeReadBeginAt                           >  0                     &
                     &  .and.                                                                     &
                     &   defaultImporter%treeIndex(nextTreeToReadActual) == mergerTreeReadBeginAt &
                     & ) mergerTreeReadBeginAt=-1
                !$ if (mergerTreeReadFixedThreadAssignment) then       
                !$    nextTreeToReadThread=nextTreeToReadActual
                !$ else
                nextTreeToRead=nextTreeToReadActual
                !$ end if
             end if
          end if
          if (nextTreeToReadActual > defaultImporter%treeCount())  then
             ! Flag that we do not have a tree.
             haveTree=.false.
          else
             ! Flag that we do have a tree.
             haveTree=.true.
          end if
       else
          ! We have a split forest to process.
          nextTreeToReadActual=splitForestActiveForest
          haveTree            =.true.
       end if
       ! Continue only if we have a tree.
       processTree=.false.
       if (haveTree) then
          ! Retrieve stored internal state if possible.
          call Galacticus_State_Retrieve
          ! Take a snapshot of the internal state and store it.
          call Galacticus_State_Snapshot
          message='Storing state for tree #'
          message=message//nextTreeToReadActual
          call Galacticus_State_Store(message)          
          ! If the tree is to be skipped, do not read it.
          if (skipTree) then
             ! Simply allocate a base node to indicate that the tree exists.
             tree%baseNode => treeNode(hostTree=tree)
          else
             ! Set tree properties.
             ! treeIndex
             tree%index=defaultImporter%treeIndex(nextTreeToReadActual)
             ! volumeWeight
             treeVolumeWeightCurrent=defaultImporter%treeWeight(nextTreeToReadActual)
             tree%volumeWeight=treeVolumeWeightCurrent
             ! Initialize no events.
             tree%event => null()
             ! Restart the random number sequence for this tree. We use the tree index modulo the largest number representable by
             ! the integer type.
             call tree%randomNumberGenerator%initialize()
             uniformRandom=tree%randomNumberGenerator%sample(ompThreadOffset=.false.,incrementSeed=int(mod(tree%index,huge(0))))
             ! Check if the size of this forest exceeds the maximum allowed.
             if     (                                                                                   &
                  &   .not.returnSplitForest                                                            &
                  &  .and.                                                                              &
                  &   defaultImporter%nodeCount(nextTreeToReadActual) > mergerTreeReadForestSizeMaximum &
                  &  .and.                                                                              &
                  &   0                                               < mergerTreeReadForestSizeMaximum &
                  & ) then
                ! Check if the importer supports reading subsets of halos from a forest.
                if (.not.defaultImporter%canReadSubsets()) call Galacticus_Error_Report('forest exceeds maximum allowed size but importer cannot read subsets of halos'//{introspection:location})
                ! Import nodes, and keep only the minimally required data to map the tree structure.
                call defaultImporter%import(nextTreeToReadActual,nodes,structureOnly=.true.)
                ! Find initial root node affinities of all nodes.
                call Root_Node_Affinities_Initial(nodes)
                call Memory_Usage_Record(sizeof(nodes),addRemove=-1)
                deallocate(nodes)
                returnSplitForest      =.true.
                splitForestNextTree    =0
                splitForestActiveForest=nextTreeToReadActual
             end if
             
             ! Determine subset of nodes to read.
             if (returnSplitForest) then
                ! Move to the next tree.
                splitForestNextTree=splitForestNextTree+1
                allocate(nodeSubset(splitForestTreeSize(splitForestNextTree)))
                nodeSubset=splitForestMapIndex(splitForestTreeStart(splitForestNextTree):splitForestTreeStart(splitForestNextTree)+splitForestTreeSize(splitForestNextTree)-1)
                call Sort_Do(nodeSubset)
             else
                allocate(nodeSubset(1))
                nodeSubset=[-1_c_size_t]
             end if
             ! Read data from the file.
             call defaultImporter%import(                                                                                                                           &
                  &                      nextTreeToReadActual                                                                                                     , &
                  &                      nodes                                                                                                                    , &
                  &                      requireScaleRadii         = mergerTreeReadPresetScaleRadii                                                               , &
                  &                      requireParticleCounts     = mergerTreeReadPresetParticleCounts                                                           , &
                  &                      requireVelocityMaxima     = mergerTreeReadPresetVelocityMaxima                                                           , &
                  &                      requireVelocityDispersions= mergerTreeReadPresetVelocityDispersions                                                      , &
                  &                      requireAngularMomenta     =(mergerTreeReadPresetSpins              .and.defaultImporter%angularMomentaAvailable  ())     , &
                  &                      requireAngularMomenta3D   =                                                                                                &
                  &                                                 (                                                                                               &
                  &                                                    mergerTreeReadPresetSpins3D                                                                  &
                  &                                                   .or.                                                                                          &
                  &                                                    (                                                                                            &
                  &                                                      mergerTreeReadPresetSpins                                                                  &
                  &                                                     .and.                                                                                       &
                  &                                                      mergerTreeReadSubhaloAngularMomentaMethod == mergerTreeReadSubhaloAngularMomentaSummation  &
                  &                                                    )                                                                                            &
                  &                                                  )                                                                                              &
                  &                                                 .and.                                                                                           &
                  &                                                  defaultImporter%angularMomenta3DAvailable()                                                  , &
                  &                      requireSpin               =(mergerTreeReadPresetSpins              .and.defaultImporter%spinAvailable            ())     , &
                  &                      requireSpin3D             =(mergerTreeReadPresetSpins3D            .and.defaultImporter%spin3DAvailable          ())     , &
                  &                      requirePositions          =(mergerTreeReadPresetPositions          .or. mergerTreeReadPresetOrbits                 )     , &
                  &                      nodeSubset                =nodeSubset                                                                                      &
                  &                     )
             deallocate(nodeSubset)
             processTree=.true.
          end if
       end if
       !$omp end critical(mergerTreeReadTree)
       ! Handle the case where a new tree file is required.
       if (newTreeFileRequired) then
          ! Assume we can exit by default.
          newTreeFileRequired=.false.
          processTree        =.false.
          ! Are there any more files to process?
          if (mergerTreeReadFileCurrent < mergerTreeReadFileCount) then
             ! Wait for all threads to reach this point.
             !$omp barrier
             ! Have the master thread move to the next tree file.
             !$omp master
             mergerTreeReadFileCurrent=mergerTreeReadFileCurrent+1
             if (mergerTreeReadFileCurrent <= mergerTreeReadFileCount) then
                call defaultImporter%close(                                                 )
                call defaultImporter%open (mergerTreeReadFileName(mergerTreeReadFileCurrent))
                nextTreeToRead=0
             end if
             !$omp end master
             !$omp barrier
             if (mergerTreeReadFileCurrent <= mergerTreeReadFileCount) newTreeFileRequired=.true.
          end if
       end if
    end do treeFile
    
    ! Continue if we have a tree to process.
    if (processTree) then
       select type (nodes)
       class is (nodeData)
          ! Snap node times to output times if a tolerance has been specified.
          if (mergerTreeReadOutputTimeSnapTolerance > 0.0d0) then
             ! Loop over all nodes.
             do iNode=1,size(nodes)
                ! Find closest output time to the node time.
                iOutput=Search_Array_For_Closest(outputTimes,nodes(iNode)%nodeTime)
                ! Test if this time is sufficiently close that we should snap the node time to it.
                if (Values_Agree(nodes(iNode)%nodeTime,outputTimes(iOutput),relTol=mergerTreeReadOutputTimeSnapTolerance)) &
                     & nodes(iNode)%nodeTime=outputTimes(iOutput)
             end do
          end if

          ! Sort node indices.
          call Create_Node_Indices(nodes)

          ! Identify subhalos.
          nodes%isSubhalo=nodes%nodeIndex /= nodes%hostIndex
          
          ! Build pointers to descendent nodes.
          call Build_Descendent_Pointers(nodes)

          ! Find cases where something that was a subhalo stops being a subhalo and prevent them if necessary.
          call Enforce_Subhalo_Status(nodes)

          ! If necessary, add masses and angular momenta of subhalos to host halos.
          if (.not.defaultImporter%angularMomentaIncludeSubhalos().and.mergerTreeReadSubhaloAngularMomentaMethod == mergerTreeReadSubhaloAngularMomentaScale) then
             ! This method requires angular momenta to be available.
             if (.not.defaultImporter%angularMomentaAvailable()) call Galacticus_Error_Report('scaling parent angular momentum for subhalo masses requires angular momenta availability'//{introspection:location})
             do iNode=1,size(nodes)
                if (nodes(iNode)%host%nodeIndex == nodes(iNode)%nodeIndex) then
                   if (mergerTreeReadPresetSpins  )            &
                        & nodes      (iNode)%angularMomentum   &
                        &      =nodes(iNode)%angularMomentum   &
                        &      /nodes(iNode)%nodeMass
                   if (mergerTreeReadPresetSpins3D)            &
                        & nodes      (iNode)%angularMomentum3D &
                        &      =nodes(iNode)%angularMomentum3D &
                        &      /nodes(iNode)%nodeMass
                end if
             end do
          end if
          if (.not.defaultImporter%massesIncludeSubhalos()) then
             do iNode=1,size(nodes)
                if (nodes(iNode)%host%nodeIndex /= nodes(iNode)%nodeIndex) nodes  (iNode)%host%nodeMass &
                     &                                                      =nodes(iNode)%host%nodeMass &
                     &                                                      +nodes(iNode)%nodeMass
             end do
          end if
          if (.not.defaultImporter%angularMomentaIncludeSubhalos().and.mergerTreeReadSubhaloAngularMomentaMethod == mergerTreeReadSubhaloAngularMomentaScale) then
             do iNode=1,size(nodes)
                if (nodes(iNode)%host%nodeIndex == nodes(iNode)%nodeIndex) then
                   if (mergerTreeReadPresetSpins)              &
                        & nodes      (iNode)%angularMomentum   &
                        &      =nodes(iNode)%angularMomentum   &
                        &      *nodes(iNode)%nodeMass
                   if (mergerTreeReadPresetSpins3D)            & 
                        & nodes      (iNode)%angularMomentum3D &
                        &      =nodes(iNode)%angularMomentum3D &
                        &      *nodes(iNode)%nodeMass

                end if
             end do
          end if
          if     (                                                                                           &
               &  (                                                                                          &
               &    mergerTreeReadPresetSpins3D                                                              &
               &   .or.                                                                                      &
               &    mergerTreeReadPresetSpins                                                                &
               &  )                                                                                          &
               &  .and.                                                                                      &
               &   .not.defaultImporter%angularMomentaIncludeSubhalos()                                      &
               &  .and.                                                                                      &
               &   mergerTreeReadSubhaloAngularMomentaMethod == mergerTreeReadSubhaloAngularMomentaSummation &
               & ) then
             ! This method requires 3D angular momenta to be available.
             if (.not.defaultImporter%angularMomenta3DAvailable()) &
                  & call Galacticus_Error_Report(                                                                                                       &
                  &                              'adding subhalo angular momenta to parent angular momentum requires 3D angular momenta availability'// &
                  &                              {introspection:location}                                                                               &
                  &                             )
             do iNode=1,size(nodes)
                if (nodes(iNode)%host%nodeIndex /= nodes(iNode)%nodeIndex) then
                   ! Find relative position and velocity.
                   relativePosition=nodes(iNode)%position-nodes(iNode)%host%position
                   relativeVelocity=nodes(iNode)%velocity-nodes(iNode)%host%velocity
                   ! Update position/velocity for periodicity and Hubble flow.
                   call Phase_Space_Position_Realize(nodes(iNode)%nodeTime,relativePosition,relativeVelocity)
                   ! Compute orbital angular momentum of subhalo.
                   orbitalAngularMomentum=+nodes(iNode)%nodeMass                             &
                        &                 *Vector_Product(relativePosition,relativeVelocity)
                   ! Sum orbital and internal angular momenta.
                   nodes        (iNode)%host%angularMomentum3D &
                        & =nodes(iNode)%host%angularMomentum3D &
                        & +nodes(iNode)     %angularMomentum3D &
                        & +orbitalAngularMomentum
                end if
             end do
             ! Update scalar angular momenta.
             do iNode=1,size(nodes)
                if (nodes(iNode)%host%nodeIndex == nodes(iNode)%nodeIndex) &
                     & nodes(iNode)%angularMomentum=Vector_Magnitude(nodes(iNode)%angularMomentum3D)
             end do
          end if

          ! Associate parent pointers with the descendent host.
          call Build_Parent_Pointers(nodes)

          ! Create an array of standard nodes.
          call Create_Node_Array(tree,nodes,nodeList,isolatedNodeCount,childIsSubhalo)

          ! Assign parent pointers and properties.
          call Build_Isolated_Parent_Pointers(tree,nodes,nodeList)

          ! Now build child and sibling links.
          call Build_Child_and_Sibling_Links(nodes,nodeList,childIsSubhalo)
          
          ! Assign split forest events.
          call Assign_Split_Forest_Events(nodes,nodeList)
          
          ! Check that all required properties exist.
          if (mergerTreeReadPresetPositions.or.mergerTreeReadPresetOrbits) then
             ! Position and velocity methods are required.
             if     (                                                                                                                                                                   &
                  &  .not.(                                                                                                                                                             &
                  &         defaultPositionComponent%positionIsSettable()                                                                                                               &
                  &        .and.                                                                                                                                                        &
                  &         defaultPositionComponent%velocityIsSettable()                                                                                                               &
                  &       )                                                                                                                                                             &
                  & )                                                                                                                                                                   &
                  & call Galacticus_Error_Report                                                                                                                                        &
                  &      (                                                                                                                                                              &
                  &       'presetting positions or orbits requires a component that supports position and velocity setting (e.g. set [treeNodeMethodPosition]=preset);'              // &
                  &       Galacticus_Component_List(                                                                                                                                    &
                  &                                 'darkMatterProfile'                                                                                                               , &
                  &                                  defaultPositionComponent        %     positionAttributeMatch(requireSettable=.true.)                                               &
                  &                                 .intersection.                                                                                                                      &
                  &                                  defaultPositionComponent        %     velocityAttributeMatch(requireSettable=.true.)                                               &
                  &                                )                                                                                                                                 // &
                  &       char(10)                                                                                                                                                   // &
                  &       'alternatively setting [mergerTreeReadPresetPositions]=false and [mergerTreeReadPresetOrbits]=false will remove the need to store positions and velocities'// &
                  &       {introspection:location}                                                                                                                                      &
                  & )
          end if
          if (mergerTreeReadPresetMergerTimes) then
             ! Time of merging property is required.
             if (.not.defaultSatelliteComponent%timeOfMergingIsSettable      ())                                                                                                        &
                  & call Galacticus_Error_Report                                                                                                                                        &
                  &      (                                                                                                                                                              &
                  &       'presetting merging times requires a component that supports setting of merging times.'                                                                    // &
                  &       Galacticus_Component_List(                                                                                                                                    &
                  &                                 'satellite'                                                                                                                       , &
                  &                                  defaultSatelliteComponent       %timeOfMergingAttributeMatch(requireSettable=.true.)                                               &
                  &                                 )                                                                                                                               //  &
                  &       {introspection:location}                                                                                                                                      &
                  &      )
          end if
          if (mergerTreeReadPresetScaleRadii) then
             ! Scale radius property is required.
             if (.not.defaultDarkMatterProfileComponent%scaleIsSettable      ())                                                                                                        &
                  & call Galacticus_Error_Report                                                                                                                                        &
                  &      (                                                                                                                                                              &
                  &       'presetting scale radii requires a component that supports setting of scale radii.'                                                                        // &
                  &       Galacticus_Component_List(                                                                                                                                    &
                  &                                 'darkMatterProfile'                                                                                                               , &
                  &                                 defaultDarkMatterProfileComponent%        scaleAttributeMatch(requireSettable=.true.)                                               &
                  &                                )                                                                                                                                 // &
                  &       {introspection:location}                                                                                                                                      &
                  &      )
          end if
          if (mergerTreeReadPresetParticleCounts) then
             ! Particle count property is required.
             if (.not.defaultNBodyComponent%particleCountIsSettable          ())                                                                                                        &
                  & call Galacticus_Error_Report                                                                                                                                        &
                  &      (                                                                                                                                                              &
                  &       'presetting particle counts requires an nBody component that supports setting of particle count.'                                                          // &
                  &       Galacticus_Component_List(                                                                                                                                    &
                  &                                 'nBody'                                                                                                                           , &
                  &                                 defaultNBodyComponent            %particleCountAttributeMatch(requireSettable=.true.)                                               &
                  &                                )                                                                                                                                 // &
                  &       {introspection:location}                                                                                                                                      &
                  &      )
          end if
          if (mergerTreeReadPresetVelocityMaxima) then
             ! Velocity maximum property is required.
             if (.not.defaultNBodyComponent%velocityMaximumIsSettable        ())                                                                                                        &
                  & call Galacticus_Error_Report                                                                                                                                        &
                  &      (                                                                                                                                                              &
                  &       'presetting velocity maxima requires an nBody component that supports setting of velocity maxima.'                                                         // &
                  &       Galacticus_Component_List(                                                                                                                                    &
                  &                                 'nBody'                                                                                                                           , &
                  &                                 defaultNBodyComponent            %velocityMaximumAttributeMatch(requireSettable=.true.)                                             &
                  &                                )                                                                                                                                 // &
                  &       {introspection:location}                                                                                                                                      &
                  &      )
          end if
          if (mergerTreeReadPresetVelocityDispersions) then
             ! Velocity dispersion property is required.
             if (.not.defaultNBodyComponent%velocityDispersionIsSettable     ())                                                                                                        &
                  & call Galacticus_Error_Report                                                                                                                                        &
                  &      (                                                                                                                                                              &
                  &       'presetting velocity dispersions requires an nBody component that supports setting of velocity dispersions.'                                               // &
                  &       Galacticus_Component_List(                                                                                                                                    &
                  &                                 'nBody'                                                                                                                           , &
                  &                                 defaultNBodyComponent            %velocityDispersionAttributeMatch(requireSettable=.true.)                                          &
                  &                                )                                                                                                                                 // &
                  &       {introspection:location}                                                                                                                                      &
                  &      )
          end if
          if (mergerTreeReadPresetSpins      ) then
             ! Spin property is required.
             if (.not.defaultSpinComponent             %spinIsSettable       ())                                                                                                        &
                  & call Galacticus_Error_Report                                                                                                                                        &
                  &      (                                                                                                                                                              &
                  &       'presetting spins requires a component that supports setting of spins.'                                                                                    // &
                  &       Galacticus_Component_List(                                                                                                                                    &
                  &                                 'spin'                                                                                                                            , &
                  &                                 defaultSpinComponent             %         spinAttributeMatch(requireSettable=.true.)                                               &
                  &                                )                                                                                                                                 // &
                  &       {introspection:location}                                                                                                                                      &
                  &      )
          end if
          if (mergerTreeReadPresetSpins3D    ) then
             ! Spin property is required.
             if (.not.defaultSpinComponent             %spinVectorIsSettable ())                                                                                                        &
                  & call Galacticus_Error_Report                                                                                                                                        &
                  &      (                                                                                                                                                              &
                  &       'presetting spin vectors requires a component that supports setting of spin vectors.'                                                                      // &
                  &       Galacticus_Component_List(                                                                                                                                    &
                  &                                 'spinVector'                                                                                                                      , &
                  &                                 defaultSpinComponent             %     spinVectorAttributeMatch(requireSettable=.true.)                                             &
                  &                                )                                                                                                                                 // &
                  &       {introspection:location}                                                                                                                                      &
                  &      )
          end if
          if (mergerTreeReadPresetOrbits     ) then
             ! Orbit property is required.
             if (.not.defaultSatelliteComponent        %virialOrbitIsSettable())                                                                                                        &
                  & call Galacticus_Error_Report                                                                                                                                        &
                  &      (                                                                                                                                                              &
                  &       'presetting orbits requires a component that supports setting of orbits (e.g. [treeNodeMethodSatelliteOrbit]=preset);'                                     // &
                  &       Galacticus_Component_List(                                                                                                                                    &
                  &                                 'satellite'                                                                                                                       , &
                  &                                 defaultSatelliteComponent        %  virialOrbitAttributeMatch(requireSettable=.true.)                                               &
                  &                                )                                                                                                                                 // &
                  &       char(10)                                                                                                                                                   // &
                  &       'Alternatively, set [mergerTreeReadPresetOrbits]=false to prevent attempts to set orbits)'                                                                 // &
                  &       {introspection:location}                                                                                                                                      &
                  &)
          end if

          ! Assign scale radii.
          if (mergerTreeReadPresetScaleRadii                               ) call Assign_Scale_Radii         (nodes,nodeList)

          ! Assign particle counts.
          if (mergerTreeReadPresetParticleCounts                           ) call Assign_Particle_Counts     (nodes,nodeList)

          ! Assign velocity maxima.
          if (mergerTreeReadPresetVelocityMaxima                           ) call Assign_Velocity_Maxima     (nodes,nodeList)

          ! Assign velocity dispersions.
          if (mergerTreeReadPresetVelocityDispersions                      ) call Assign_Velocity_Dispersions(nodes,nodeList)

          ! Assign spin parameters.
          if (mergerTreeReadPresetSpins     .or.mergerTreeReadPresetSpins3D) call Assign_Spin_Parameters     (nodes,nodeList)

          ! Assign isolated node indices to subhalos.
          call Assign_Isolated_Node_Indices(nodes)

          ! Ensure that isolated nodes with progenitors that descend into subhalos have valid primary progenitors.
          call Validate_Isolated_Halos(nodes)

          ! Scan subhalos to determine when and how they merge.
          call Scan_For_Mergers(nodes,nodeList,historyCountMaximum)

          ! If a split forest was used, but all trees from it have now been processed, remove the split forest data as we no
          ! longer need it at this point.
          if (returnSplitForest .and. splitForestNextTree == size(splitForestTreeStart)) then
             call deallocateArray(splitForestTreeSize )
             call deallocateArray(splitForestTreeStart)
             call deallocateArray(splitForestPushTo   )
             call deallocateArray(splitForestPullFrom )
             call deallocateArray(splitForestPushType )
             call deallocateArray(splitForestMapIndex )
          end if
          ! Release the lock on split forest data if necessary as we're finished using it. This allows other threads to begin
          ! using the split forest data.
          !$ if (mergerTreeReadForestSizeMaximum > 0) call OMP_Unset_Lock(splitForestLock)

          ! Search for any nodes which were flagged as merging with another node and assign appropriate pointers.
          call Assign_Mergers(nodes,nodeList)

          ! Find cases where something that was a subhalo stops being a subhalo and add events to handle.
          call Scan_for_Subhalo_Promotions(nodes,nodeList)

          ! Search for subhalos which move between branches/trees.
          call Scan_for_Branch_Jumps(nodes,nodeList)

          ! Allocate arrays for history building.
          if (allocated(position)) call deallocateArray(position)
          if (allocated(velocity)) call deallocateArray(velocity)
          call allocateArray(historyTime,[int(historyCountMaximum)])
          if (mergerTreeReadPresetSubhaloIndices                             ) then
          call allocateArray(historyIndex,[  int(historyCountMaximum)])
          else
          call allocateArray(historyIndex,[                        0 ])
          end if
          if (mergerTreeReadPresetSubhaloMasses                              ) then
          call allocateArray(historyMass ,[  int(historyCountMaximum)])
          else
          call allocateArray(historyMass ,[                        0 ])
          end if
          if (mergerTreeReadPresetPositions    .or.mergerTreeReadPresetOrbits) then
          call allocateArray(position    ,[3,int(historyCountMaximum)])
          call allocateArray(velocity    ,[3,int(historyCountMaximum)])
          else
          call allocateArray(position    ,[0,                      0 ])
          call allocateArray(velocity    ,[0,                      0 ])
          end if
          
          ! Build subhalo mass histories if required.
          call Build_Subhalo_Mass_Histories(nodes,nodeList,historyCountMaximum,historyTime,historyIndex,historyMass,position,velocity)

          ! Assign new uniqueIDs to any cloned nodes inserted into the trees.
          call Assign_UniqueIDs_To_Clones(nodeList)
          
          ! Deallocate history building arrays.
          if (allocated(historyTime)) call deallocateArray(historyTime )
          if (allocated(historyMass)) call deallocateArray(historyIndex)
          if (allocated(historyMass)) call deallocateArray(historyMass )
          if (allocated(position   )) call deallocateArray(position    )
          if (allocated(velocity   )) call deallocateArray(velocity    )
          
          ! Deallocate the temporary arrays.
          call Memory_Usage_Record(sizeof(nodeList),addRemove=-1)
          deallocate(nodeList)

          ! Destroy sorted node indices.
          call Destroy_Node_Indices()
       class default
          call Galacticus_Error_Report('nodes arrays is of wrong class'//{introspection:location})
       end select
       ! Deallocate nodes.
       call Memory_Usage_Record(sizeof(nodes),addRemove=-1)
       deallocate(nodes)
    else
       ! Release lock on split forest data if necessary.
       !$ if (mergerTreeReadForestSizeMaximum > 0) call OMP_Unset_Lock(splitForestLock)
    end if
    return
  end subroutine Merger_Tree_Read_Do

  subroutine Create_Node_Indices(nodes)
    !% Create a sorted list of node indices with an index into the original array.
    use Galacticus_Error
    use String_Handling
    use Memory_Management
    use Sort
    implicit none
    class  (nodeDataMinimal), dimension(:), intent(inout) :: nodes   
    integer                                               :: iNode   
    type   (varying_string )                              :: message 
    
    ! Build a sorted list of node indices with an index into the original arrays.
    call allocateArray(nodeLocations          ,shape(nodes))
    call allocateArray(nodeIndicesSorted      ,shape(nodes))
    call allocateArray(descendentLocations    ,shape(nodes))
    call allocateArray(descendentIndicesSorted,shape(nodes))
    nodeLocations      =Sort_Index_Do(nodes%nodeIndex      )
    descendentLocations=Sort_Index_Do(nodes%descendentIndex)
    forall (iNode=1:size(nodes))
       nodeIndicesSorted      (iNode)=nodes(nodeLocations      (iNode))%nodeIndex
       descendentIndicesSorted(iNode)=nodes(descendentLocations(iNode))%descendentIndex
    end forall
    do iNode=2,size(nodes)
       if (nodeIndicesSorted(iNode) == nodeIndicesSorted(iNode-1)) then
          message="WARNING: duplicate node index found in merger tree - this is not allowed ["
          message=message//nodeIndicesSorted(iNode)//']'
          call Galacticus_Warn(message)
       end if
    end do
    return
  end subroutine Create_Node_Indices

  function Node_Location(nodeIndex)
    !% Return the location in the original array of the given {\normalfont \ttfamily nodeIndex}.
    use Arrays_Search
    implicit none
    integer(c_size_t      )                :: Node_Location 
    integer(kind=kind_int8), intent(in   ) :: nodeIndex     
    integer(c_size_t      )                :: iNode         
    
    iNode=Search_Array(nodeIndicesSorted,nodeIndex)
    if (iNode < 1 .or. iNode > size(nodeIndicesSorted)) then
       Node_Location=1
    else
       Node_Location=nodeLocations(iNode)
    end if
    return
  end function Node_Location

  function Descendent_Node_Sort_Index(descendentIndex)
    !% Return the sort index of the given {\normalfont \ttfamily descendentIndex}.
    use Arrays_Search
    implicit none
    integer(c_size_t      )                :: Descendent_Node_Sort_Index
    integer(kind=kind_int8), intent(in   ) :: descendentIndex 
    
    Descendent_Node_Sort_Index=Search_Array(descendentIndicesSorted,descendentIndex)
    return
  end function Descendent_Node_Sort_Index

  subroutine Destroy_Node_Indices()
    !% Destroy the sorted list of node indices.
    use Memory_Management
    implicit none

    if (allocated(nodeLocations          )) call deallocateArray(nodeLocations          )
    if (allocated(nodeIndicesSorted      )) call deallocateArray(nodeIndicesSorted      )
    if (allocated(descendentLocations    )) call deallocateArray(descendentLocations    )
    if (allocated(descendentIndicesSorted)) call deallocateArray(descendentIndicesSorted)
    return
  end subroutine Destroy_Node_Indices

  subroutine Build_Descendent_Pointers(nodes)
    !% Builds pointers from each node to its descendent node.
    use String_Handling
    use Galacticus_Error
    use Galacticus_Display
    implicit none
    class  (nodeData      ), dimension(:), intent(inout), target :: nodes                 
    integer(c_size_t      )                                      :: iNode  , nodeLocation 
    type   (varying_string)                                      :: message               
    
    do iNode=1,size(nodes)
       ! Does this node have a descendent? And is it staying in this tree?
       if (nodes(iNode)%descendentIndex >= 0.and..not.isOnPushList(nodes(iNode))) then
          nodeLocation=Node_Location(nodes(iNode)%descendentIndex)
          if (nodes(nodeLocation)%nodeIndex /= nodes(iNode)%descendentIndex) then
             message='failed to find descendent node: '
             message=message//nodes(iNode)%descendentIndex//' of '//nodes(iNode)%nodeIndex
             call Galacticus_Error_Report(message//{introspection:location})
          end if
          nodes(iNode)%descendent => nodes(nodeLocation)
       else
          nodes(iNode)%descendent => null()
       end if
       if (nodes(iNode)%hostIndex       >= 0) then
          nodeLocation=Node_Location(nodes(iNode)%hostIndex      )
          if (nodes(nodeLocation)%nodeIndex /= nodes(iNode)%hostIndex       ) then
             message='failed to find host node: '
             message=message//nodes(iNode)%hostIndex//' of '//nodes(iNode)%nodeIndex
             if (mergerTreeReadMissingHostsAreFatal) then
                call Galacticus_Error_Report(message//{introspection:location})
             else
                message=message//" - resetting this node to be an isolated node"
                call Galacticus_Display_Message(message,verbosity=verbosityInfo)
                nodes(iNode)%hostIndex =  nodes(iNode)%nodeIndex
                nodes(iNode)%host      => nodes(iNode)
                nodes(iNode)%isSubhalo =  .false.
             end if
          else
             nodes(iNode)%host    => nodes(nodeLocation)
          end if
       else
          call Galacticus_Error_Report('negative values are not allowed for hostIndex - if node is self-hosting [i.e. not a subhalo] set hostIndex=nodeIndex'//{introspection:location})
       end if
    end do
    return
  end subroutine Build_Descendent_Pointers

  subroutine Enforce_Subhalo_Status(nodes)
    !% Ensure that any node which was once a subhalo remains a subhalo.
    use Galacticus_Error
    use String_Handling
    implicit none
    class  (nodeData          ), dimension(:), intent(inout), target :: nodes
    class  (nodeData          ), pointer                             :: descendentNode, progenitorNode
    integer(c_size_t          )                                      :: iNode
    logical                                                          :: failed        , isolatedProgenitorExists 
    type   (varying_string    )                                      :: message
    type   (progenitorIterator)                                      :: progenitors
    
    ! Return immediately if subhalo promotions are allowed.
    if (mergerTreeReadAllowSubhaloPromotions) return
    ! Subhalo promotions are not allowed, so enforce subhalo status.
    do iNode=1,size(nodes)
       if (nodes(iNode)%isSubhalo) then
          descendentNode => nodes(iNode)%descendent
          do while (associated(descendentNode))
             ! Is this node isolated?
             if (.not.descendentNode%isSubhalo) then
                ! Check if there is any isolated node which descends into this node.
                isolatedProgenitorExists=.false.
                call progenitors%descendentSet(descendentNode,nodes)
                do while (progenitors%next(nodes) .and. .not.isolatedProgenitorExists)
                   progenitorNode => progenitors%current(nodes)
                   isolatedProgenitorExists=(progenitorNode%nodeIndex == progenitorNode%hostIndex)
                end do
                if (.not.progenitors%exist() .or. .not.isolatedProgenitorExists) then
                   ! Node is isolated, has no isolated node that descends into it. Therefore, our current node is not allowed to
                   ! be a subhalo.
                   nodes(iNode)%isSubhalo=.false.
                   nodes(iNode)%host => nodes(iNode)
                   nodes(iNode)%hostIndex=nodes(iNode)%nodeIndex
                end if
             end if
             descendentNode => descendentNode%descendent
          end do
       end if
    end do
    ! Check that subhalo enforcement was successful.
    failed=.false.
    do iNode=1,size(nodes)
       ! Find nodes which have no isolated node descending into them.       
       isolatedProgenitorExists=.false.
       call progenitors%descendentSet(nodes(iNode),nodes)
       do while (progenitors%next(nodes) .and. .not.isolatedProgenitorExists)
          progenitorNode => progenitors%current(nodes)
          isolatedProgenitorExists=(progenitorNode%nodeIndex == progenitorNode%hostIndex)
       end do
       if (progenitors%exist() .and. .not.isolatedProgenitorExists) then
          ! Such nodes must be subhalos. If they are not, report an error
          if (.not.nodes(iNode)%isSubhalo) then
             if (failed) then
                message=message//', '
             else
                message='failed to enforce persistent subhalo status for node ['
             end if
             message=message//nodes(iNode)%nodeIndex
             failed=.true.
          end if
       end if
    end do
    if (failed) then
       message=message//']'
       call Galacticus_Error_Report(message//{introspection:location})
    end if

    return
  end subroutine Enforce_Subhalo_Status

  subroutine Scan_for_Subhalo_Promotions(nodes,nodeList)
    !% Scan for cases where a subhalo stops being a subhalo and so must be promoted.
    use Node_Subhalo_Promotions
    implicit none
    class  (nodeData          ), target , dimension(:), intent(inout) :: nodes                                    
    type   (treeNodeList      )         , dimension(:), intent(inout) :: nodeList                                 
    class  (nodeData          ), pointer                              :: descendentNode          , progenitorNode 
    class  (nodeEvent         ), pointer                              :: newEvent                , pairEvent      
    type   (treeNode          ), pointer                              :: promotionNode           , node       
    integer(c_size_t          )                                       :: iNode                                    
    logical                                                           :: isolatedProgenitorExists, nodeIsMostMassive
    type   (progenitorIterator)                                       :: progenitors                              
    
    ! Return immediately if subhalo promotion is not allowed.
    if (.not.mergerTreeReadAllowSubhaloPromotions) return
    ! Find subhalos to be promoted.
    do iNode=1,size(nodes)
       if (nodes(iNode)%isSubhalo.and.associated(nodes(iNode)%descendent)) then
          descendentNode => nodes(iNode)%descendent
          ! Is this node isolated?
          if (.not.descendentNode%isSubhalo) then          
             ! Check if there is any isolated node which descends into this node, and also whether this is the most massive
             ! subhalo which descends into the descendent.
             isolatedProgenitorExists=.false.
             nodeIsMostMassive       =.true.
             call progenitors%descendentSet(descendentNode,nodes)             
             do while (progenitors%next(nodes))
                progenitorNode => progenitors%current(nodes)
                if (progenitorNode%nodeIndex == progenitorNode%hostIndex) then
                   isolatedProgenitorExists=.true.
                else if (progenitorNode%nodeMass > nodes(iNode)%nodeMass) then
                   nodeIsMostMassive=.false.
                end if
             end do
             if (.not.progenitors%exist() .or. .not.isolatedProgenitorExists) then
                if (nodeIsMostMassive) then
                   ! Node is isolated, has no isolated node that descends into it, and our subhalo is the most massive subhalo which
                   ! descends into it. Therefore, our subhalo must be promoted to become an isolated halo again.
                   node       => nodeList(nodes(inode)  %isolatedNodeIndex)%node
                   promotionNode  => nodeList(descendentNode%isolatedNodeIndex)%node
                   allocate(nodeEventSubhaloPromotion ::  newEvent)
                   allocate(nodeEventSubhaloPromotion :: pairEvent)
                   call node     %attachEvent( newEvent)
                   call promotionNode%attachEvent(pairEvent)
                   newEvent %time =  descendentNode%nodeTime
                   newEvent %node => promotionNode
                   newEvent %task => Node_Subhalo_Promotion
                   pairEvent%time =  descendentNode%nodeTime
                   pairEvent%node => node
                   pairEvent%task => null()
                   pairEvent%ID   =  newEvent%ID
                else if (mergerTreeReadAllowBranchJumps) then
                   ! Node is isolated, has no isolated node that descends into it, and our subhalo is not the most massive subhalo
                   ! which descends into it. Therefore, our subhalo must branch jump if this is allowed.
                   call Create_Branch_Jump_Event(                                                 &
                        &                        nodeList(nodes(inode)  %isolatedNodeIndex)%node, &
                        &                        nodeList(descendentNode%isolatedNodeIndex)%node, &
                        &                        descendentNode%nodeTime                          &
                        &                       )
                end if
             end if
          end if
       end if
    end do
    return
  end subroutine Scan_for_Subhalo_Promotions

  subroutine Build_Parent_Pointers(nodes)
    !% Build pointers to node parents.
    use Galacticus_Error
    use String_Handling
    implicit none
    class  (nodeData      ), dimension(:), intent(inout), target :: nodes      
    class  (nodeData      ), pointer                             :: parentNode 
    integer(c_size_t      )                                      :: iNode      
    type   (varying_string)                                      :: message    
    
    do iNode=1,size(nodes)
       if (associated(nodes(iNode)%descendent)) then
          if (nodes(iNode)%nodeIndex == nodes(iNode)%host%nodeIndex) then
             ! Find an isolated parent node, by repeatedly jumping from host to host.
             parentNode => nodes(iNode)%descendent%host
             do while (parentNode%isSubhalo)
                if (associated(parentNode,parentNode%host)) then
                   message='node ['
                   message=message//parentNode%nodeIndex//'] flagged as subhalo is self-hosting - exiting to avoid infinite loop'
                   call Galacticus_Error_Report(message//{introspection:location})
                end if
                parentNode => parentNode%host
             end do
             nodes(iNode)%parent => parentNode
          else
             nodes(iNode)%parent => null()
          end if
       else
          nodes(iNode)%parent => null()
       end if
    end do
    ! Check for self-parents.
    do iNode=1,size(nodes)
       if (associated(nodes(iNode)%parent)) then
          if (nodes(iNode)%nodeIndex == nodes(iNode)%parent%nodeIndex) then
             message='node ['
             message=message//nodes(iNode)%nodeIndex//'] is its own parent - exiting to avoid infinite loop'
             call Galacticus_Error_Report(message//{introspection:location})
          end if
       end if
    end do
    return
  end subroutine Build_Parent_Pointers

  subroutine Create_Node_Array(tree,nodes,nodeList,isolatedNodeCount,childIsSubhalo)
    !% Create an array of standard nodes and associated structures.
    use Memory_Management
    implicit none
    type   (mergerTree        )                           , intent(inout) :: tree                                 
    class  (nodeData          )             , dimension(:), intent(inout) :: nodes                                    
    type   (treeNodeList      ), allocatable, dimension(:), intent(inout) :: nodeList                                 
    logical                    , allocatable, dimension(:), intent(inout) :: childIsSubhalo                           
    integer                                               , intent(  out) :: isolatedNodeCount                        
    integer(c_size_t          )                                           :: iNode                                    
    integer                                                               :: iIsolatedNode    , initialSatelliteCount 
    logical                                                               :: createNode                               
    type   (progenitorIterator)                                           :: progenitors

    ! Determine how many nodes are isolated (i.e. not subhalos).
    isolatedNodeCount=count(.not.nodes%isSubhalo)

    ! Scan here for nodes that are subhalos and have no progenitor. These objects must be
    ! created as satellites within the tree.
    initialSatelliteCount=0
    do iNode=1,size(nodes)
       if (nodes(iNode)%isSubhalo) then
          call progenitors%descendentSet(nodes(iNode),nodes)
          if (.not.progenitors%exist()) initialSatelliteCount=initialSatelliteCount+1
      end if
    end do

    ! Allocate nodes.
    allocate(nodeList(isolatedNodeCount+initialSatelliteCount))
    call Memory_Usage_Record(sizeof(nodeList))
    call allocateArray(childIsSubhalo,[isolatedNodeCount+initialSatelliteCount])

    ! Create the nodes.
    iIsolatedNode          =0
    nodes%isolatedNodeIndex=nodeIsUnreachable
    do iNode=1,size(nodes)
       createNode=.false.
       if (nodes(iNode)%nodeIndex == nodes(iNode)%host%nodeIndex) then
          createNode=.true.
       else if (nodes(iNode)%isSubhalo) then
          call progenitors%descendentSet(nodes(iNode),nodes)
          if (.not.progenitors%exist()) createNode=.true.
       end if
       if (createNode) then
          iIsolatedNode=iIsolatedNode+1
          ! Store a record of where this node goes in the isolated node list.
          nodes(iNode)%isolatedNodeIndex=iIsolatedNode
          nodeList(iIsolatedNode)%node => treeNode(hostTree=tree)
          call nodeList(iIsolatedNode)%node%indexSet(nodes(iNode)%nodeIndex)
          nodes(iNode)%node => nodeList(iIsolatedNode)%node
       end if
    end do
    return
  end subroutine Create_Node_Array

  subroutine Build_Isolated_Parent_Pointers(tree,nodes,nodeList)
    !% Create parent pointer links between isolated nodes and assign times and masses to those nodes.
    use String_Handling
    use Galacticus_Error
    implicit none
    type     (mergerTree        )                       , intent(inout) , target :: tree
    type     (nodeData          )         , dimension(:), intent(inout)          :: nodes
    type     (treeNodeList      )         , dimension(:), intent(inout)          :: nodeList
    class    (nodeComponentBasic), pointer                                       :: basic
    type     (mergerTree        ), pointer                                       :: treeCurrent
    type     (nodeData          ), pointer                                       :: parentNode
    integer                                                                      :: iNode
    integer  (c_size_t          )                                                :: iIsolatedNode                  
    type     (varying_string    )                                                :: message
    character(len=12            )                                                :: label
    logical                                                                      :: assignLastIsolatedTime
    
    do iNode=1,size(nodes)
       ! Only process if this is an isolated node (or an initial satellite).
       if (nodes(iNode)%isolatedNodeIndex /= nodeIsUnreachable) then
          iIsolatedNode=nodes(iNode)%isolatedNodeIndex
          ! Check for an isolated node.
          if (nodes(iNode)%nodeIndex == nodes(iNode)%host%nodeIndex) then
             assignLastIsolatedTime=.false.
             if (associated(nodes(iNode)%parent)) then
                nodeList(iIsolatedNode)%node%parent  => nodes(iNode)%parent%node
             else
                nodeList(iIsolatedNode)%node%parent  => null()
                ! Find a tree to attach this base node to. Begin with the original tree passed to us.
                treeCurrent => tree
                ! Check if its baseNode is already assigned.
                do while (associated(treeCurrent%baseNode))
                   ! While it is, create the next tree (unless it already exists), then step to it.
                   if (.not.associated(treeCurrent%nextTree)) allocate(treeCurrent%nextTree)
                   treeCurrent => treeCurrent%nextTree
                end do
                ! Assign this node as the base node of the current tree.
                treeCurrent   %baseNode         => nodeList(iIsolatedNode)%node
                if (mergerTreeReadTreeIndexToRootNodeIndex) then
                   treeCurrent%index            =  nodes(iNode        )%nodeIndex
                else
                   treeCurrent%index            =  tree                %index
                end if                
                treeCurrent   %volumeWeight     =  treeVolumeWeightCurrent
                treeCurrent   %initializedUntil =  0.0d0
                treeCurrent   %event            => null()
             end if
          else
             ! Node is not isolated, so must be an initial satellite.
             assignLastIsolatedTime=.true.
             if (associated(nodes(iNode)%host)) then
                parentNode => nodes(iNode)%host
                do while (parentNode%isSubhalo)
                   parentNode => parentNode%host
                end do
                nodeList(iIsolatedNode)%node%parent => parentNode%node
             else
                call Galacticus_Error_Report('initial satellite has no parent defined'//{introspection:location})
             end if
          end if
          ! Assign mass and time. For the case of satellites we also assign the time at
          ! which the satellite was last isolated. Since we do not know this, we simply
          ! set it equal to the current time (which is, obviously, an upper limit).
          if (nodes(iNode)%nodeMass <= 0.0d0) then
             write (label,'(e12.6)') nodes(iNode)%nodeMass
             message='non-positive mass ['//label//'] found for node '
             message=message//nodeList(iIsolatedNode)%node%index()
             call Galacticus_Error_Report(message//{introspection:location})
          end if
          if (nodes(iNode)%nodeTime <= 0.0d0) then
             write (label,'(e12.6)') nodes(iNode)%nodeTime
             message='non-positive time ['//label//'] found for node '
             message=message//nodeList(iIsolatedNode)%node%index()
             call Galacticus_Error_Report(message//{introspection:location})
          end if
          basic => nodeList(iIsolatedNode)%node%basic(autoCreate=.true.)
          call        basic%massSet            (nodes(iNode)%nodeMass)
          call        basic%timeSet            (nodes(iNode)%nodeTime)
          if (assignLastIsolatedTime) &
               & call basic%timeLastIsolatedSet(nodes(iNode)%nodeTime)
       end if
    end do
    return
  end subroutine Build_Isolated_Parent_Pointers

  subroutine Build_Child_and_Sibling_Links(nodes,nodeList,childIsSubhalo)
    !% Build child and sibling links between nodes.
    use Memory_Management
    implicit none
    class  (nodeData          )             , dimension(:), intent(inout) :: nodes                                     
    type   (treeNodeList      )             , dimension(:), intent(inout) :: nodeList                                  
    logical                    , allocatable, dimension(:), intent(inout) :: childIsSubhalo                            
    class  (nodeComponentBasic), pointer                                  :: basic            , basicPrimary 
    integer                                                               :: iNode                                     
    integer(c_size_t          )                                           :: iIsolatedNode                             
    logical                                                               :: descendsToSubhalo                         
    
    childIsSubhalo=.false.
    do iNode=1,size(nodes)
       ! Only process if this is an isolated node.
       if (nodes(iNode)%isolatedNodeIndex /= nodeIsUnreachable) then
          iIsolatedNode=nodes(iNode)%isolatedNodeIndex
          ! Check for an isolated node.
          if (nodes(iNode)%nodeIndex == nodes(iNode)%host%nodeIndex) then
             ! Check if the node has a parent.
             if (associated(nodeList(iIsolatedNode)%node%parent)) then
                ! Determine if this node definitely descends to a subhalo - in which case it can never be the primary progenitor.
                descendsToSubhalo=nodes(iNode)%descendentIndex /= nodeList(iIsolatedNode)%node%parent%index()
                ! It does, so set the child pointer of the parent appropriately.
                if (associated(nodeList(iIsolatedNode)%node%parent%firstChild)) then
                   ! A child is already associated. Check if current node does not descend to a subhalo and is more massive.
                   basic    => nodeList(iIsolatedNode)%node%basic()
                   basicPrimary => nodeList(iIsolatedNode)%node%parent%firstChild%basic()
                   if (.not.descendsToSubhalo                                          &
                        & .and. (                                                      &
                        &        childIsSubhalo(nodes(iNode)%parent%isolatedNodeIndex) &
                        &         .or.                                                 &
                        &        basic%mass() > basicPrimary%mass()                    &
                        &       )                                                      &
                        & ) then
                      ! It is, so make this the main progenitor.
                      nodeList(iIsolatedNode)%node%sibling           => nodeList(iIsolatedNode)%node%parent%firstChild
                      nodeList(iIsolatedNode)%node%parent%firstChild => nodeList(iIsolatedNode)%node
                      ! Record that the main child is now not a subhalo.
                      childIsSubhalo(nodes(iNode)%parent%isolatedNodeIndex)=.false.
                   else
                      ! It is not, so add after the main child.
                      nodeList(iIsolatedNode)%node%sibling                   => nodeList(iIsolatedNode)%node%parent%firstChild%sibling
                      nodeList(iIsolatedNode)%node%parent%firstChild%sibling => nodeList(iIsolatedNode)%node
                   end if
                else
                   ! No child is currently associated. Simply point to the current node.
                   nodeList(iIsolatedNode)%node%parent%firstChild => nodeList(iIsolatedNode)%node
                   ! Record whether or not this child is a known subhalo or not.
                   childIsSubhalo(nodes(iNode)%parent%isolatedNodeIndex)=descendsToSubhalo
                end if
             end if
          else
             ! Node must be an initial satellite.
             if (associated(nodeList(iIsolatedNode)%node%parent%firstSatellite)) then
                ! The parent halo already has some satellites. Add this one to the list.
                nodeList(iIsolatedNode)%node%sibling               => nodeList(iIsolatedNode)%node%parent%firstSatellite
                nodeList(iIsolatedNode)%node%parent%firstSatellite => nodeList(iIsolatedNode)%node
             else
                ! The parent halo does not yet have any satellites. Simply add this one as the first.
                nodeList(iIsolatedNode)%node%sibling               => null()
                nodeList(iIsolatedNode)%node%parent%firstSatellite => nodeList(iIsolatedNode)%node
             end if
          end if
       end if
    end do
    call deallocateArray(childIsSubhalo)
    return
  end subroutine Build_Child_and_Sibling_Links

  subroutine Assign_Scale_Radii(nodes,nodeList)
    !% Assign scale radii to nodes.
    use Root_Finder
    use Dark_Matter_Halo_Scales
    use Dark_Matter_Profile_Scales
    use Galacticus_Display
    use Galacticus_Error
    use Input_Parameters
    implicit none
    class           (nodeData                           )                 , dimension(:), intent(inout) :: nodes                                                                 
    type            (treeNodeList                       )                 , dimension(:), intent(inout) :: nodeList                                                              
    double precision                                     , parameter                                    :: scaleRadiusMaximumAllowed     =100.0d0, toleranceAbsolute  =1.0d-9, & 
         &                                                                                                 toleranceRelative             =1.0d-9                                 
    logical                                                         , save                              :: excessiveScaleRadiiReported   =.false.                                
    class           (nodeComponentBasic                 ), pointer                                      :: basic                                         
    class           (nodeComponentDarkMatterProfile     ), pointer                                      :: darkMatterProfile                             
    class           (darkMatterHaloScaleClass           ), pointer                                      :: darkMatterHaloScale_
    integer                                                                                             :: iNode                                 , status                     , &
         &                                                                                                 messageVerbosity
    integer         (c_size_t                           )                                               :: iIsolatedNode                                              
    double precision                                                                                    :: radiusScale                                                
    logical                                                                                             :: excessiveHalfMassRadii                , excessiveScaleRadii        , &
         &                                                                                                 useFallbackScaleMethod
    type            (rootFinder                         )           , save                              :: finder                                                     
    !$omp threadprivate(finder)
    type            (varying_string                     )                                               :: message
    character       (len=16                             )                                               :: label

    ! Initialize our root finder.
    if (.not.finder%isInitialized()) then
       call finder%rootFunction(Half_Mass_Radius_Root              )
       call finder%tolerance   (toleranceAbsolute,toleranceRelative)
    end if
    ! Get required objects.
    darkMatterHaloScale_ => darkMatterHaloScale()
    ! Find the scale radius.
    excessiveScaleRadii   =.false.
    excessiveHalfMassRadii=.false.
    do iNode=1,size(nodes)
       ! Only process if this is an isolated node.
       if (nodes(iNode)%isolatedNodeIndex /= nodeIsUnreachable) then
          iIsolatedNode=nodes(iNode)%isolatedNodeIndex
          ! Assume that we need to use a fallback method to set halo scale radius.
          useFallbackScaleMethod=.true.
          ! Check if the node is sufficiently massive.
          basic             => nodeList(iIsolatedNode)%node%basic            (                 )
          darkMatterProfile => nodeList(iIsolatedNode)%node%darkMatterProfile(autoCreate=.true.)          
          if (basic%mass() >= mergerTreeReadPresetScaleRadiiMinimumMass) then
             ! Check if we have scale radii read directly from file.
             if     (                                                                   &
                  &     nodes(iNode)%scaleRadius                                        &
                  &   >                                                                 &
                  &     0.0d0                                                           &
                  &  .and.                                                              &
                  &     nodes(iNode)%scaleRadius                                        &
                  &   <                                                                 &
                  &     darkMatterHaloScale_%virialRadius(nodeList(iIsolatedNode)%node) &
                  &    /mergerTreeReadPresetScaleRadiiConcentrationMinimum              &
                  &  .and.                                                              &
                  &     nodes(iNode)%scaleRadius                                        &
                  &   >                                                                 &
                  &     darkMatterHaloScale_%virialRadius(nodeList(iIsolatedNode)%node) &
                  &    /mergerTreeReadPresetScaleRadiiConcentrationMaximum              &
                  & ) then
                ! We do, so simply use them to set the scale radii in tree nodes.
                call darkMatterProfile%scaleSet(nodes(iNode)%scaleRadius)
                useFallbackScaleMethod=.false.
             else if (nodes(iNode)%halfMassRadius > 0.0d0) then
                ! We do not have scale radii read directly. Instead, compute them from half-mass radii.
                ! Set the active node and target half mass radius.
                activeNode                       => nodeList(iIsolatedNode)%node
                darkMatterProfileActive => activeNode%darkMatterProfile()
                basicActive             => activeNode%basic            ()
                halfMassRadius                   =  nodes(iNode)%halfMassRadius
                ! Solve for the scale radius.
                call finder%rangeExpand    (                                                                                   &
                     &                      rangeExpandDownward          =0.5d0                                              , &
                     &                      rangeExpandUpward            =2.0d0                                              , &
                     &                      rangeDownwardLimit           = darkMatterHaloScale_%virialRadius(activeNode)       &
                     &                                                    /mergerTreeReadPresetScaleRadiiConcentrationMaximum, &
                     &                      rangeUpwardLimit             = darkMatterHaloScale_%virialRadius(activeNode)       &
                     &                                                    /mergerTreeReadPresetScaleRadiiConcentrationMinimum, &
                     &                      rangeExpandDownwardSignExpect=rangeExpandSignExpectPositive                      , &
                     &                      rangeExpandUpwardSignExpect  =rangeExpandSignExpectNegative                      , &
                     &                      rangeExpandType              =rangeExpandMultiplicative                            &
                     &                     )                
                radiusScale=finder%find(rootGuess=halfMassRadius,status=status)
                if (status == errorStatusSuccess) then
                   call darkMatterProfile%scaleSet(radiusScale)
                   ! Check for scale radii exceeding the virial radius.
                   if (radiusScale    > darkMatterHaloScale_%virialRadius(activeNode)) excessiveScaleRadii   =.true.
                   ! Check for half-mass radii exceeding the virial radius.
                   if (halfMassRadius > darkMatterHaloScale_%virialRadius(activeNode)) excessiveHalfMassRadii=.true.
                   useFallbackScaleMethod=.false.
                else
                   if (mergerTreeReadPresetScaleRadiiFailureIsFatal) then
                      messageVerbosity=Galacticus_Verbosity_Level()
                   else
                      messageVerbosity=verbosityWarn
                   end if
                   call Galacticus_Display_Indent  ("failed to find scale radius consistent with specified half-mass radius",messageVerbosity)
                   write (label,'(i16)') activeNode%hostTree%index
                   message="      tree index: "//trim(label)
                   call Galacticus_Display_Message(message,messageVerbosity)
                    write (label,'(i16)') activeNode%index()
                   message="      node index: "//trim(label)
                   call Galacticus_Display_Message(message,messageVerbosity)
                   write (label,'(e12.6)') darkMatterHaloScale_%virialRadius(activeNode)
                   message="   virial radius: "//trim(label)
                   call Galacticus_Display_Message(message,messageVerbosity)
                   write (label,'(e12.6)') halfMassRadius
                   message="half-mass radius: "//trim(label)
                   call Galacticus_Display_Message(message,messageVerbosity)
                   call Galacticus_Display_Unindent("",messageVerbosity)
                   if (mergerTreeReadPresetScaleRadiiFailureIsFatal) then
                      call Galacticus_Error_Report('aborting'//{introspection:location})
                   else 
                     useFallbackScaleMethod=.true.
                   end if
                end if
             end if
          end if
          if (useFallbackScaleMethod) then
             ! The node mass is below the reliability threshold, or no scale information is available. Set the scale radius using
             ! the fallback concentration method.
             activeNode => nodeList(iIsolatedNode)%node
             radiusScale=max(                                                                                                       &
                  &          min(                                                                                                   &
                  &              Dark_Matter_Profile_Scale(nodeList(iIsolatedNode)%node,concentrationMethod=fallbackConcentration), &
                  &              darkMatterHaloScale_%virialRadius(activeNode)/mergerTreeReadPresetScaleRadiiConcentrationMinimum   &
                  &             )                                                                                                 , &
                  &              darkMatterHaloScale_%virialRadius(activeNode)/mergerTreeReadPresetScaleRadiiConcentrationMaximum   &
                  &         )
             call darkMatterProfile%scaleSet(radiusScale)
          end if
       end if
    end do
    ! Report warning on excessive scale radii if not already done.
    if (excessiveScaleRadii.and..not.excessiveScaleRadiiReported) then
       excessiveScaleRadiiReported=.true.
       call Galacticus_Display_Message('Assign_Scale_Radii(): warning - some scale radii exceed the corresponding virial radii - suggests&
            & inconsistent definitions of halo mass/radius',verbosityWarn)
    end if

    ! Exit on excessive half mass radii.
    if (excessiveHalfMassRadii) call Galacticus_Error_Report('some half mass radii exceed corresponding virial radii'//{introspection:location})

    return
  end subroutine Assign_Scale_Radii

  subroutine Assign_Spin_Parameters(nodes,nodeList)
    !% Assign spin parameters to nodes.
    use Numerical_Constants_Physical
    use Dark_Matter_Profiles
    use Galacticus_Error
    use Halo_Spin_Distributions
    implicit none
    class           (nodeData                 )         , dimension(:), intent(inout) :: nodes              
    type            (treeNodeList             )         , dimension(:), intent(inout) :: nodeList           
    class           (nodeComponentBasic       ), pointer                              :: basic 
    class           (nodeComponentSpin        ), pointer                              :: spin_  
    class           (darkMatterProfileClass   ), pointer                              :: darkMatterProfile_
    class           (haloSpinDistributionClass), pointer                              :: haloSpinDistribution_
    integer                                                                           :: iNode              
    integer         (c_size_t                 )                                       :: iIsolatedNode      
    double precision                                                                  :: spin
    double precision                                    , dimension(3)                :: spin3D               
    
    ! Get required objects.
    darkMatterProfile_    => darkMatterProfile   ()
    haloSpinDistribution_ => haloSpinDistribution()
    do iNode=1,size(nodes)
       ! Only process if this is an isolated node.
       if (nodes(iNode)%isolatedNodeIndex /= nodeIsUnreachable) then
          iIsolatedNode=nodes(iNode)%isolatedNodeIndex
          ! Get basic and spin components.
          basic => nodeList(iIsolatedNode)%node%basic(                 )
          spin_  => nodeList(iIsolatedNode)%node%spin (autoCreate=.true.)
          if (mergerTreeReadPresetSpins  ) then
             if      (defaultImporter%          spinAvailable()) then
                ! If spins are available directly, use them.
                call spin_%spinSet(nodes(iNode)%spin)
             else if (defaultImporter%angularMomentaAvailable()) then
                spin  = spinNormalization()          &
                     & *nodes(iNode)%angularMomentum
                call spin_%spinSet(spin)
             else
                call Galacticus_Error_Report('no method exists to set spins'//{introspection:location})
             end if
             if (mergerTreeReadPresetUnphysicalSpins.and.spin_%spin() <= 0.0d0) &
                  & call spin_%spinSet(haloSpinDistribution_%sample(nodeList(iIsolatedNode)%node))
          end if
          if (mergerTreeReadPresetSpins3D) then
             if      (defaultImporter%          spin3DAvailable()) then
                ! If spins are available directly, use them.
                call spin_%spinVectorSet(nodes(iNode)%spin3D)
             else if (defaultImporter%angularMomenta3DAvailable()) then
                spin3D= spinNormalization()            &
                     & *nodes(iNode)%angularMomentum3D
                call spin_%spinVectorSet(spin3D)
             else
                call Galacticus_Error_Report('no method exists to set vector spins'//{introspection:location})
             end if
          end if
       end if
    end do
    return
    
  contains
    
    double precision function spinNormalization()
      !% Normalization for conversion of angular momentum to spin.
      implicit none
      spinNormalization= sqrt(abs(darkMatterProfile_%energy(nodeList(iIsolatedNode)%node))) &
           &            /gravitationalConstantGalacticus                                    &
           &            /basic%mass()**2.5d0
      return
    end function spinNormalization
    
  end subroutine Assign_Spin_Parameters
  
  subroutine Assign_Particle_Counts(nodes,nodeList)
    !% Assign particle counts to nodes.
    implicit none
    class           (nodeData          )         , dimension(:), intent(inout) :: nodes              
    type            (treeNodeList      )         , dimension(:), intent(inout) :: nodeList           
    class           (nodeComponentNBody), pointer                              :: nBody
    integer                                                                    :: iNode              
    integer         (c_size_t          )                                       :: iIsolatedNode      
    
    do iNode=1,size(nodes)
       ! Only process if this is an isolated node.
       if (nodes(iNode)%isolatedNodeIndex /= nodeIsUnreachable) then
          iIsolatedNode=nodes(iNode)%isolatedNodeIndex
          ! Get N-body component.
          nBody => nodeList(iIsolatedNode)%node%nBody(autoCreate=.true.)
          ! Assign the particle count.
          call nBody%particleCountSet(nodes(iNode)%particleCount)
       end if
    end do
    return
  end subroutine Assign_Particle_Counts

  subroutine Assign_Velocity_Maxima(nodes,nodeList)
    !% Assign velocity maxima to nodes.
    implicit none
    class           (nodeData          )         , dimension(:), intent(inout) :: nodes              
    type            (treeNodeList      )         , dimension(:), intent(inout) :: nodeList           
    class           (nodeComponentNBody), pointer                              :: nBody
    integer                                                                    :: iNode              
    integer         (c_size_t          )                                       :: iIsolatedNode      
    
    do iNode=1,size(nodes)
       ! Only process if this is an isolated node.
       if (nodes(iNode)%isolatedNodeIndex /= nodeIsUnreachable) then
          iIsolatedNode=nodes(iNode)%isolatedNodeIndex
          ! Get N-body component.
          nBody => nodeList(iIsolatedNode)%node%nBody(autoCreate=.true.)
          ! Assign the velocity maximum.
          call nBody%velocityMaximumSet(nodes(iNode)%velocityMaximum)
       end if
    end do
    return
  end subroutine Assign_Velocity_Maxima

  subroutine Assign_Velocity_Dispersions(nodes,nodeList)
    !% Assign velocity dispersions to nodes.
    implicit none
    class           (nodeData          )         , dimension(:), intent(inout) :: nodes              
    type            (treeNodeList      )         , dimension(:), intent(inout) :: nodeList           
    class           (nodeComponentNBody), pointer                              :: nBody
    integer                                                                    :: iNode              
    integer         (c_size_t          )                                       :: iIsolatedNode      
    
    do iNode=1,size(nodes)
       ! Only process if this is an isolated node.
       if (nodes(iNode)%isolatedNodeIndex /= nodeIsUnreachable) then
          iIsolatedNode=nodes(iNode)%isolatedNodeIndex
          ! Get N-body component.
          nBody => nodeList(iIsolatedNode)%node%nBody(autoCreate=.true.)
          ! Assign the velocity dispersion.
          call nBody%velocityDispersionSet(nodes(iNode)%velocityDispersion)
       end if
    end do
    return
  end subroutine Assign_Velocity_Dispersions
  
  double precision function Half_Mass_Radius_Root(radius)
    !% Function used to find scale radius of dark matter halos given their half-mass radius.
    use Dark_Matter_Profiles
    implicit none
    double precision                        , intent(in   ) :: radius 
    class           (darkMatterProfileClass), pointer       :: darkMatterProfile_

    ! Get required objects.
    darkMatterProfile_ => darkMatterProfile()
    ! Set scale radius to current guess.
    call darkMatterProfileActive%scaleSet(radius)
    ! Compute difference between mass fraction enclosed at half mass radius and one half.
    Half_Mass_Radius_Root=darkMatterProfile_%enclosedMass(activeNode,halfMassRadius)/basicActive%mass()-0.50d0
    return
  end function Half_Mass_Radius_Root

  subroutine Assign_Isolated_Node_Indices(nodes)
    !% Assign to each node the number of the corresponding isolated node.
    implicit none
    class  (nodeData      ), dimension(:), intent(inout) :: nodes         
    class  (nodeData      ), pointer                     :: node      
    integer(c_size_t      )                              :: iIsolatedNode 
    integer                                              :: iNode         
    logical                                              :: endOfBranch   
    
    ! First make a copy of the currently assigned isolated node indices. These will be used
    ! later to reference the nodes which are the primary node associated with objects in nodeList.
    nodes%primaryIsolatedNodeIndex=nodes%isolatedNodeIndex
    ! Iterate over nodes.
    do iNode=1,size(nodes)
       ! Only process if this is an isolated node.
       if (nodes(iNode)%isolatedNodeIndex /= nodeIsUnreachable) then
          iIsolatedNode=nodes(iNode)%isolatedNodeIndex
          ! Find the subset with descendents.
          if (associated(nodes(iNode)%descendent)) then
             ! Select the subset which have a subhalo as a descendent.
             if (nodes(iNode)%descendent%isSubhalo) then
                ! Trace descendents until merging or final time.
                node   => nodes(iNode)%descendent
                endOfBranch=  .false.
                do while (.not.endOfBranch)
                   ! Record that this node was reachable via descendents of an isolated node.
                   if (node%isolatedNodeIndex == nodeIsUnreachable) node%isolatedNodeIndex=nodeIsReachable
                   if (.not.associated(node%descendent)) then
                      ! If there is no descendent then the end of the branch has been reached.
                      endOfBranch=.true.
                   else
                      ! Step to the next descendent.
                      node => node%descendent
                   end if
                end do
             end if
          end if
       end if
    end do
    return
  end subroutine Assign_Isolated_Node_Indices

  subroutine Scan_For_Mergers(nodes,nodeList,historyCountMaximum)
    !% Scan for and record mergers between nodes.
    use Vectors
    use Virial_Orbits
    use Kepler_Orbits
    use Dark_Matter_Halo_Scales
    use String_Handling
    use Galacticus_Error
    implicit none
    class           (nodeData                       )           , dimension(:), intent(inout), target :: nodes                                                                
    type            (treeNodeList                   )           , dimension(:), intent(inout)         :: nodeList                                                             
    integer         (c_size_t                       )                         , intent(  out)         :: historyCountMaximum                                                  
    class           (nodeData                       ), pointer                                        :: lastSeenNode                      , progenitorNode            , & 
         &                                                                                               node                                                          
    type            (treeNode                       ), pointer                                        :: firstProgenitor                   , hostNode                  , & 
         &                                                                                               orbitalPartner                    , satelliteNode                 
    double precision                                            , dimension(3)                        :: hostPosition                      , relativePosition          , & 
         &                                                                                               satellitePosition                                                 
    double precision                                            , dimension(3)                        :: hostVelocity                      , relativeVelocity          , & 
         &                                                                                               satelliteVelocity                                                 
    logical                                          , parameter                                      :: acceptUnboundOrbits       =.false.                                
    integer                                          , parameter                                      :: passAssign                =1      , passMerge               =2
    class           (nodeComponentBasic             ), pointer                                        :: basicChild                        , basicOrbitalPartner       , & 
         &                                                                                               basicSatellite                    , basic              
    class           (nodeComponentPosition          ), pointer                                        :: positionChild                     , positionHost              , & 
         &                                                                                               positionSatellite                 , position           
    class           (nodeComponentSatellite         ), pointer                                        :: satelliteSatellite                , satellite          
    class           (darkMatterHaloScaleClass       ), pointer                                        :: darkMatterHaloScale_
    class           (virialOrbitClass               ), pointer                                        :: virialOrbit_
    type            (keplerOrbit                    )                                                 :: orbit                                                         
    integer                                                                                           :: iNode                             , pass_
    integer         (c_size_t                       )                                                 :: historyCount                      , iIsolatedNode                 
    integer         (kind_int8                      )                                                 :: progenitorMassMaximumIndex
    logical                                                                                           :: branchMerges                      , branchTipReached          , & 
         &                                                                                               endOfBranch                       , isolatedProgenitorExists  , & 
         &                                                                                               nodeWillMerge                                                     
    double precision                                                                                  :: radiusApocenter                   , radiusPericenter          , & 
         &                                                                                               radiusVirial                      , timeSubhaloMerges         , &
         &                                                                                               progenitorMassMaximum
    type            (varying_string                 )                                                 :: message                                                              
    type            (progenitorIterator             )                                                 :: progenitors                                                          
    
    ! Initialize.
    historyCountMaximum  = 0
    nodes%mergesWithIndex=-1
    ! First pass assigns isolated node indices to all descendents, second pass finds mergers.
    do pass_=passAssign,passMerge
       do iNode=1,size(nodes)
          if (nodes(iNode)%primaryIsolatedNodeIndex /= nodeIsUnreachable) then
             iIsolatedNode=nodes(iNode)%primaryIsolatedNodeIndex
             ! Find the subset with descendents.
             if (associated(nodes(iNode)%descendent)) then
                ! Flag indicating if this is a node for which a merging time should be set.
                nodeWillMerge=.false.
                ! Select the subset which have a subhalo, or which are an initial subhalo.
                if (nodes(iNode)%descendent%isSubhalo.or.nodes(iNode)%isSubhalo) then
                   ! Trace descendents until merging or final time.
                   endOfBranch     =.false.
                   branchTipReached=.false.
                   branchMerges    =.false.
                   historyCount    =0
                   if (nodes(iNode)%isSubhalo) then
                      node => nodes(iNode)
                   else
                      ! Check for an immediate subhalo-subhalo merger.
                      if (Is_Subhalo_Subhalo_Merger(nodes,nodes(iNode))) then
                         endOfBranch =.true.
                         branchMerges=.true.
                         nodes(iNode)%mergesWithIndex=nodes(iNode)%descendent%nodeIndex
                         historyCount=historyCount+max(0_kind_int8,defaultImporter%subhaloTraceCount(nodes(iNode)))
                      end if
                      lastSeenNode => nodes(iNode)
                      node     => nodes(iNode)%descendent
                   end if
                   do while (.not.endOfBranch)
                      ! Record which isolated node this node belongs to.
                      node%isolatedNodeIndex=iIsolatedNode
                      ! Increment the history count for this branch.
                      historyCount=historyCount+1
                      ! Test the branch.
                      if (.not.associated(node%descendent)) then
                         ! No descendent, indicating tip of branch has been reached
                         branchTipReached            =.true.
                         endOfBranch                 =.true.
                         historyCount                =historyCount+max(0_kind_int8,defaultImporter%subhaloTraceCount(node))
                      else if (.not.node%descendent%isSubhalo) then
                         ! Descendent is not a subhalo, treat as a merging event or a subhalo promotion.
                         endOfBranch                 =.true.
                         historyCount                =historyCount+max(0_kind_int8,defaultImporter%subhaloTraceCount(node))
                         ! Search for any isolated progenitors of the node's descendent.
                         isolatedProgenitorExists=.false.
                         call progenitors%descendentSet(node%descendent,nodes)
                         progenitorMassMaximum=-1.0d0
                         progenitorMassMaximumIndex=-1_kind_int8
                         do while (progenitors%next(nodes) .and. .not.isolatedProgenitorExists)
                            progenitorNode => progenitors%current(nodes)
                            isolatedProgenitorExists=(progenitorNode%nodeIndex == progenitorNode%hostIndex)
                            if (progenitorNode%nodeMass > progenitorMassMaximum) then
                               progenitorMassMaximum     =progenitorNode%nodeMass
                               progenitorMassMaximumIndex=progenitorNode%nodeIndex
                            end if
                         end do
                         ! If an isolated progenitor exists, or this is not the most massive subhalo progenitor, this is a merger
                         ! event. If not, it is a subhalo promotion (which will be handled elsewhere).
                         if (isolatedProgenitorExists .or. progenitorMassMaximumIndex /= node%nodeIndex) then
                            branchMerges                =.true.
                            nodes(iNode)%mergesWithIndex=node%descendent%nodeIndex
                            lastSeenNode                => node
                            node                        => node%descendent
                         end if
                      else
                         ! Merges with another subhalo.
                         call progenitors%descendentSet(node%descendent,nodes)
                         do while (progenitors%next(nodes))
                            progenitorNode => progenitors%current(nodes)
                            if     (                                                                          &
                                 &                    progenitorNode%nodeIndex         /= node%nodeIndex      &
                                 &  .and.             progenitorNode%isolatedNodeIndex /= nodeIsUnreachable   &
                                 &  .and.  associated(progenitorNode%descendent                             ) &
                                 &  .and.             progenitorNode%nodeMass           > node%nodeMass       &
                                 & ) then
                               ! Another node merges into current node's descendent subhalo and is more massive than current
                               ! node. Therefore, class this as a subhalo-subhalo merger.
                               branchMerges                =.true.
                               endOfBranch                 =.true.
                               nodes(iNode)%mergesWithIndex=progenitorNode%descendent%nodeIndex
                               historyCount                =historyCount+max(0_kind_int8,defaultImporter%subhaloTraceCount(node))
                               lastSeenNode                => node
                               node                    => node%descendent
                               exit
                            end if
                         end do
                         ! Step to the next descendent.
                         if (.not.endOfBranch) node => node%descendent
                      end if
                   end do
                   ! If on the isolated node index assigning pass, skip to the next halo.
                   if (pass_ == passAssign) cycle
                   ! Only set a merging time if this node is not the primary progenitor of its parent.
                   if (.not.nodeList(iIsolatedNode)%node%isPrimaryProgenitor()) then
                      ! Record the largest history.
                      historyCountMaximum=max(historyCountMaximum,historyCount)
                      ! Set an appropriate merging time for this subhalo.
                      if      (branchTipReached) then
                         timeSubhaloMerges=satelliteMergeTimeInfinite ! Subhalo never merges, so set merging time to effective infinity.
                      else if (branchMerges    ) then
                         ! Find the time of merging, accounting for any additional (subresolution) time.
                         timeSubhaloMerges=node%nodeTime
                         call Time_Until_Merging_Subresolution(lastSeenNode,nodes,nodeList,iNode,timeSubhaloMerges)
                      else
                         ! Neither the branch tip was reached, not does this branch merge. Therefore, this must be a subhalo which is
                         ! promoted to be an isolated halo. Simply set an infinite merging time as we do not wish this node to merge.
                         timeSubhaloMerges=satelliteMergeTimeInfinite
                      end if
                      ! Flag that this node will merge.
                      nodeWillMerge=.true.
                   end if
                else if (pass_ == passAssign) then
                   ! If on the isolated node index assigning pass, skip to the next halo.
                   cycle
                else if (.not.nodeList(iIsolatedNode)%node%isPrimaryProgenitor()) then
                   ! Descendent is not a subhalo but this node is not the primary progenitor. Assume instantaneous merging.
                   basic => nodeList(iIsolatedNode)%node%basic()
                   timeSubhaloMerges=basic%time()
                   ! Flag that this node will merge.
                   nodeWillMerge=.true.
                   ! Record the node with which the merger occurs.
                   nodes(iNode)%mergesWithIndex=nodes(iNode)%descendent%nodeIndex
                   ! Ensure the history arrays will be large enough to hold data for this node.
                   historyCountMaximum=max(historyCountMaximum,max(0_kind_int8,defaultImporter%subhaloTraceCount(nodes(iNode))))
                   ! Account for any subresolution merging time.
                   call Time_Until_Merging_Subresolution(nodes(iNode),nodes,nodeList,iNode,timeSubhaloMerges)
                end if               
                ! Set a merging time and/or orbit if this node will merge.
                if (mergerTreeReadPresetMergerTimes) then
                   ! If the node does not merge set an infinite merging time.
                   if (.not.nodeWillMerge) timeSubhaloMerges=satelliteMergeTimeInfinite
                   ! Store the time of merging for this node and all of its primary progenitors.
                   firstProgenitor => nodeList(iIsolatedNode)%node
                   do while (associated(firstProgenitor))
                      satellite => firstProgenitor%satellite(autoCreate=.true.)
                      call satellite%timeOfMergingSet(timeSubhaloMerges)
                      firstProgenitor => firstProgenitor%firstChild
                   end do
                end if            
             end if
             ! Handle cases where a node jumps to another tree.
             if (pass_ == passMerge .and. isOnPushList(nodes(iNode)) .and. mergerTreeReadPresetMergerTimes) then
                ! Merger times are to be preset, but this node will be pushed to another tree. We must set its merging time to be
                ! infinite in this case.
                firstProgenitor => nodeList(iIsolatedNode)%node
                do while (associated(firstProgenitor))                   
                   satellite => firstProgenitor%satellite(autoCreate=.true.)
                   call satellite%timeOfMergingSet(satelliteMergeTimeInfinite)
                   firstProgenitor => firstProgenitor%firstChild
                end do
             end if
             ! Set position and velocity if required.
             if (mergerTreeReadPresetPositions) then
                position => nodeList(iIsolatedNode)%node%position(autoCreate=.true.)
                call position%positionSet(nodes(iNode)%position)
                call position%velocitySet(nodes(iNode)%velocity)
                ! Detect if the node parent has no isolated child - in which case one will have been made for it using a
                ! direct copy of itself. Note that this is an ugly solution - once trees can handle nodes with no primary
                ! progenitor (but with secondary progenitors) a cleaner test could be used here.
                if (associated(nodeList(iIsolatedNode)%node%firstChild)) then
                   basic      => nodeList(iIsolatedNode)%node           %basic()
                   basicChild => nodeList(iIsolatedNode)%node%firstChild%basic()
                   if (nodeList(iIsolatedNode)%node%uniqueID() == nodeList(iIsolatedNode)%node%firstChild%uniqueID()) then
                      ! Set the position and velocity of the pseudo-primary progenitor here also.
                      positionChild => nodeList(iIsolatedNode)%node%firstChild%position(autoCreate=.true.)
                      call positionChild%positionSet(nodes(iNode)%position)
                      call positionChild%velocitySet(nodes(iNode)%velocity)
                   end if
                end if
             end if
          end if
       end do
    end do
    ! Get required objects.
    darkMatterHaloScale_ => darkMatterHaloScale()
    ! Set orbits.
    if (mergerTreeReadPresetOrbits) then
       virialOrbit_ => virialOrbit()
       iIsolatedNode=0
       do iNode=1,size(nodes)
         if (nodes(iNode)%primaryIsolatedNodeIndex /= nodeIsUnreachable) then
             iIsolatedNode=nodes(iNode)%primaryIsolatedNodeIndex
             ! Set the orbit for this halo.
             satelliteNode => nodeList(iIsolatedNode)%node
             if (associated(satelliteNode%parent).and..not.satelliteNode%isPrimaryProgenitor()) then
                ! Find the orbital partner.
                hostNode => satelliteNode%parent%firstChild
                ! If the parent node has no progenitors, then we are forced to use the parent node
                ! itself as the orbital partner.
                if (associated(hostNode)) then
                   orbitalPartner => hostNode     %parent
                else
                   hostNode       => satelliteNode%parent
                   orbitalPartner => hostNode
                end if
                ! Get components.
                basicSatellite      => satelliteNode             %basic    (                 )
                positionSatellite   => satelliteNode             %position (                 )
                satelliteSatellite  => satelliteNode             %satellite(autoCreate=.true.)
                positionHost        => hostNode                  %position (                 )
                basicOrbitalPartner => orbitalPartner            %basic    (                 )
                ! Get position and velocity.
                satellitePosition            =  positionSatellite%position (                 )
                satelliteVelocity            =  positionSatellite%velocity (                 )
                hostPosition                 =       positionHost%position (                 )
                hostVelocity                 =       positionHost%velocity (                 )
                ! Find relative position and velocity.
                relativePosition=satellitePosition-hostPosition
                relativeVelocity=satelliteVelocity-hostVelocity
                ! Update position/velocity for periodicity and Hubble flow.
                call Phase_Space_Position_Realize(basicSatellite%time(),relativePosition,relativeVelocity)
                ! Catch zero separation halos.
                if (Vector_Magnitude(relativePosition) == 0.0d0) then
                   if (mergerTreeReadPresetOrbitsSetAll) then
                      ! The satellite and host have zero separation, so no orbit can be
                      ! computed. Since all orbits must be set, choose an orbit at random.
                      orbit=virialOrbit_%orbit(satelliteNode,hostNode,acceptUnboundOrbits)
                      call satelliteSatellite%virialOrbitSet(orbit)
                   else
                      message='merging halos ['
                      message=message//satelliteNode%index()//' & '//hostNode%index()//'] have zero separation'
                      call Galacticus_Error_Report(message//{introspection:location})
                   end if
                else
                   ! Create the orbit.
                   orbit=Orbit_Construct(basicSatellite%mass(),basicOrbitalPartner%mass(),relativePosition,relativeVelocity)
                   ! Propagate to the virial radius.
                   radiusPericenter=orbit               %radiusPericenter(              )
                   radiusApocenter =orbit               %radiusApocenter (              )
                   radiusVirial    =darkMatterHaloScale_%virialRadius    (orbitalPartner)
                   ! Check if the orbit intersects the virial radius.
                   if     (                                                                      &
                        &    radiusVirial >= radiusPericenter                                    &
                        &  .and.                                                                 &
                        &   (radiusVirial <= radiusApocenter          .or. .not.orbit%isBound()) &
                        &  .and.                                                                 &
                        &   (.not.mergerTreeReadPresetOrbitsBoundOnly .or.      orbit%isBound()) &
                        & ) then
                      call orbit%propagate(radiusVirial,infalling=.true.)
                      ! Set the orbit.
                      call satelliteSatellite%virialOrbitSet(orbit)
                      ! If the satellite component supports full phase-space position, set that
                      ! also.
                      if (satelliteSatellite%positionIsSettable()) call satelliteSatellite%positionSet(relativePosition)
                      if (satelliteSatellite%velocityIsSettable()) call satelliteSatellite%velocitySet(relativeVelocity)
                   else if (mergerTreeReadPresetOrbitsSetAll) then
                      ! The given orbit does not cross the virial radius. Since all orbits must be set, choose an orbit at random.
                      orbit=virialOrbit_%orbit(satelliteNode,hostNode,acceptUnboundOrbits)
                      call satelliteSatellite%virialOrbitSet(orbit)
                   else if (mergerTreeReadPresetOrbitsAssertAllSet) then
                      message='virial orbit could not be set for node '
                      message=message//satelliteNode%index()//char(10)
                      message=message//' -> set [mergerTreeReadPresetOrbitsAssertAllSet]=false to ignore this problem'//char(10)
                      message=message//'    (this may lead to other problems)'
                      call Galacticus_Error_Report(message//{introspection:location})
                   end if
                end if
             end if
          end if
       end do
    end if
    return
  end subroutine Scan_For_Mergers

  subroutine Assign_Mergers(nodes,nodeList)
    !% Assign pointers to merge targets.
    use Galacticus_Error
    use String_Handling
    implicit none
    class  (nodeData      ), dimension(:), intent(inout) :: nodes    
    type   (treeNodeList  ), dimension(:), intent(inout) :: nodeList 
    integer                                              :: iNode    
    integer(c_size_t      )                              :: jNode    
    type   (varying_string)                              :: message  
    
    if (mergerTreeReadPresetMergerNodes) then
       do iNode=1,size(nodes)
          ! Check if this node was flagged as merging with another node.
          if (nodes(iNode)%mergesWithIndex /= -1) then
             ! Search for the node that it merges with.
             jNode=Node_Location(nodes(iNode)%mergesWithIndex)
             if (nodes(jNode)%isolatedNodeIndex <= 0) then
                ! This node does not belong to any isolated halo - this should not happen.
                message='subhalo-subhalo ['
                message=message//nodes(iNode)%nodeIndex//":"//nodes(jNode)%nodeIndex
                message=message//'] merger in which subhalo has no isolated node progenitor - this should not happen'
                call Galacticus_Error_Report(message//{introspection:location})
             else
                ! Set pointer from merging node (a.k.a. the "mergee") to node that will be merged with.
                nodeList(nodes(iNode)%isolatedNodeIndex)%node%mergeTarget => nodeList(nodes(jNode)%isolatedNodeIndex)%node
                ! Make a backward pointer from the merge target to the mergee. Check if the target already has mergees associated with it.
                if (associated(nodeList(nodes(jNode)%isolatedNodeIndex)%node%firstMergee)) then
                   ! It does: unlink them and attached to the "siblingMergee" pointer of the current mergee.
                   nodeList(nodes(iNode)%isolatedNodeIndex)%node%siblingMergee => nodeList(nodes(jNode)%isolatedNodeIndex)%node%firstMergee
                else
                   ! It does not: simply nullify the next mergee pointer of the mergee.
                   nodeList(nodes(iNode)%isolatedNodeIndex)%node%siblingMergee => null()
                end if
                ! Append the mergee as the first mergee on the target node.
                nodeList(nodes(jNode)%isolatedNodeIndex)%node%firstMergee => nodeList(nodes(iNode)%isolatedNodeIndex)%node
             end if
          end if
       end do
    end if
    return
  end subroutine Assign_Mergers

  subroutine Scan_for_Branch_Jumps(nodes,nodeList)
    !% Search for subhalos which move between branches/trees.
    use ISO_Varying_String
    use String_Handling
    use Galacticus_Display
    implicit none
    class           (nodeData      ), dimension(:), intent(inout), target :: nodes                                                        
    type            (treeNodeList  ), dimension(:), intent(inout)         :: nodeList                                                     
    class           (nodeData      ), pointer                             :: currentHost  , descendentNode  , hostDescendent      , jumpToHost, & 
         &                                                                   previousNode , isolatedHostNode, isolatedHostHostNode                                             
    integer                                                               :: iNode                                                        
    integer         (c_size_t      )                                      :: iIsolatedNode                                                
    logical                                                               :: isMergerEvent, subhaloJumps    , wasMergerEvent                
    double precision                                                      :: timeOfJump                                                   
    type            (varying_string)                                      :: message                                                      
    
    ! If branch jumps are not allowed, simply return.
    if (.not.mergerTreeReadAllowBranchJumps) return
    ! Search for subhalos whose descendents live in a different host than that to which their
    ! host descends. These subhalos are jumping between tree branches (or between trees). Add
    ! an event to such nodes to handle the jump.
    do iNode=1,size(nodes)
       ! Only process if this is an isolated node (or an initial satellite).
       if (nodes(iNode)%primaryIsolatedNodeIndex /= nodeIsUnreachable) then
          iIsolatedNode=nodes(iNode)%primaryIsolatedNodeIndex
          ! Find those which are a subhalo, or whose descendent is a subhalo.
          descendentNode => null()
          if      (           nodes(iNode)%isSubhalo  ) then
             descendentNode => nodes(iNode)
             previousNode   => nodes(iNode)
          else if (associated(nodes(iNode)%descendent)) then
             if (nodes(iNode)%descendent%isSubhalo) then
                descendentNode => nodes(iNode)%descendent
                previousNode   => nodes(iNode)
             end if
          end if
          ! Check for an immediate subhalo-subhalo merger. If found, nullify the descendent,
          ! so we do not attempt to process this branch.
          if (Is_Subhalo_Subhalo_Merger(nodes,nodes(iNode))) then
             descendentNode => null()
             currentHost    => Last_Host_Descendent(nodes(iNode))
             ! Add a jump if the tree ends before the descendent time.
             if (currentHost%nodeTime <= nodes(iNode)%descendent%nodeTime) then
                timeOfJump     =  currentHost%nodeTime
                jumpToHost     => nodes(iNode)%descendent%host
                do while (jumpToHost%isSubhalo)
                   if (.not.warningNestedHierarchyIssued) then
                      message='nested hierarchy detected [node '
                      message=message//nodes(iNode)%descendent%nodeIndex//']'
                      message=message//char(10)//'ignoring as not currently supported'
                      message=message//char(10)//'warning will not be issued again'
                      call Galacticus_Display_Message(message,verbosityWarn)
                      warningNestedHierarchyIssued=.true.
                   end if
                   jumpToHost => jumpToHost%host
                end do
                call Create_Branch_Jump_Event(                                                    &
                     &                        nodeList(iIsolatedNode                      )%node, &
                     &                        nodeList(jumpToHost%primaryIsolatedNodeIndex)%node, &
                     &                        timeOfJump                                          &
                     &                       )
             end if
          end if
          ! If a subhalo was found, follow its descent.
          wasMergerEvent=.false.
          do while (associated(descendentNode))
             subhaloJumps=.false.
             timeOfJump  =-1.0d0
             if (descendentNode%isSubhalo.and.associated(descendentNode%descendent)) then
                ! Determine if this is actually a merger event rather than a branch jump.
                ! Assume it is not a merger initially.
                isMergerEvent=.false.
                if (descendentNode%descendent%isSubhalo) then
                   ! Descendent is a subhalo. Check for subhalo-subhalo merger.
                   if (Is_Subhalo_Subhalo_Merger(nodes,previousNode)) isMergerEvent=.true.
                else
                   ! Descendent is not a subhalo, so this must be a merger event.
                   isMergerEvent=.true.
                end if
                ! If this is a merger event, then check that the current descendent's host has a
                ! descendent that exists beyond the time of the merger. If it does not, then we
                ! still need to allow our node to jump branches (if necessary) as it will not be
                ! able to evolve in the descendentless host.
                wasMergerEvent=isMergerEvent
                if (isMergerEvent) then
                   currentHost => Last_Host_Descendent(descendentNode)
                   if (currenthost%nodeTime <= descendentNode%descendent%nodeTime) then
                      isMergerEvent=.false.
                      timeOfJump=currentHost%nodeTime
                   endif
                end if
                ! Proceed only if this is not a merger event.
                if (.not.isMergerEvent) then
                   ! Does this subhalo's descendent live in the host to which the subhalo's host descends.
                   if (.not.associated(descendentNode%host%descendent)) then
                      ! Host has no descendent, so this must be a branch jump.
                      subhaloJumps=.true.
                   else
                      ! In nested hierarchies we must find the isolated node which hosts our node and our node's host.
                      isolatedHostNode     => descendentNode     %descendent%host
                      do while (associated(isolatedHostNode    %host).and..not.associated(isolatedHostNode    %host,isolatedHostNode    ))
                         isolatedHostNode     => isolatedHostNode    %host
                      end do
                      isolatedHostHostNode => descendentNode%host%descendent%host
                      do while (associated(isolatedHostHostNode%host).and..not.associated(isolatedHostHostNode%host,isolatedHostHostNode))
                         isolatedHostHostNode => isolatedHostHostNode%host
                      end do
                      if (isolatedHostNode%nodeIndex /= isolatedHostHostNode%nodeIndex) then
                         ! Host has a descendent, but its host is not the same as our descendent's host.
                         subhaloJumps=.true.
                         ! Check that is not simply a case of the subhalo skipping one or more timesteps before
                         ! reappearing in the expected host.
                         hostDescendent => isolatedHostHostNode
                         if (isolatedHostNode%nodeTime > hostDescendent%nodeTime) then
                            ! Handle cases where the subhalo skipped one or more timesteps.
                            do while (isolatedHostNode%nodeTime > hostDescendent%nodeTime)
                               if (associated(hostDescendent%descendent)) then
                                  hostDescendent => hostDescendent%descendent%host
                                  ! In nested hierarchies, find the isolated host node.
                                  do while (associated(hostDescendent%host).and..not.associated(hostDescendent%host,hostDescendent))
                                     hostDescendent => hostDescendent%host
                                  end do
                               else
                                  exit
                               end if
                            end do
                         else if (isolatedHostNode%nodeTime < hostDescendent%nodeTime) then
                            ! Handle cases where the host skipped one or more timesteps.
                            do while (isolatedHostNode%nodeTime < hostDescendent%nodeTime)
                               if (associated(isolatedHostNode%descendent)) then
                                  isolatedHostNode => isolatedHostNode%descendent%host
                                  ! In nested hierarchies, find the isolated host node.
                                  do while (associated(isolatedHostNode%host).and..not.associated(isolatedHostNode%host,isolatedHostNode))
                                     isolatedHostNode => isolatedHostNode%host
                                  end do
                               else
                                  exit
                               end if
                            end do
                         end if
                         ! Subhalo reappeared in the expected host. This is not a branch jump.
                         if (isolatedHostNode%nodeIndex == hostDescendent%nodeIndex) subhaloJumps=.false.
                      end if
                   end if
                else
                   ! Since this is a merger event, we're finished checking this branch.
                   exit
                end if
             end if
             ! If a jump was detected, create an event.
             if (subhaloJumps) then
                if (timeOfJump < 0.0d0)                   &
                     & timeOfJump=descendentNode%nodeTime
                jumpToHost => descendentNode%descendent%host                
                ! Find an isolated host.
                do while (jumpToHost%isSubhalo)
                   jumpToHost => jumpToHost%host
                end do
                call Create_Branch_Jump_Event(                                                    &
                     &                        nodeList(iIsolatedNode                      )%node, &
                     &                        nodeList(jumpToHost%primaryIsolatedNodeIndex)%node, &
                     &                        timeOfJump                                          &
                     &                       )
             end if
             ! Move to the descendent.
             previousNode   => descendentNode
             descendentNode => descendentNode%descendent
             ! If the descendent is not a subhalo, then we're finished checking this branch.
             if (associated(descendentNode)) then
                if (.not.descendentNode%isSubhalo) exit
             end if
             ! If this was a merger event, then we're finished checking this branch.
             if (wasMergerEvent) exit
          end do
       end if
    end do
    return
  end subroutine Scan_for_Branch_Jumps

  function Last_Host_Descendent(node) result (currentHost)
    !% Return a pointer to the last descendent that can be reached from {\normalfont \ttfamily node} when descending through hosts.
    implicit none
    class(nodeData), pointer               :: currentHost 
    class(nodeData), intent(inout), target :: node    
    
    currentHost => node%host
    do while(associated(currentHost%descendent))
       currentHost => currentHost%descendent%host
    end do
    return
  end function Last_Host_Descendent

  subroutine Create_Branch_Jump_Event(node,jumpToHost,timeOfJump)
    !% Create a matched-pair of branch jump events in the given nodes.
    use Node_Branch_Jumps
    implicit none
    type            (treeNode ), intent(inout), pointer :: jumpToHost, node  
    double precision           , intent(in   )          :: timeOfJump            
    class           (nodeEvent)               , pointer :: newEvent  , pairEvent 

    allocate(nodeEventBranchJump ::  newEvent)
    allocate(nodeEventBranchJump :: pairEvent)
    call node  %attachEvent( newEvent)
    call jumpToHost%attachEvent(pairEvent)
    newEvent %time =  timeOfJump
    newEvent %node => jumpToHost
    newEvent %task => Node_Branch_Jump
    pairEvent%time =  timeOfJump
    pairEvent%node => node
    pairEvent%task => null()
    pairEvent%ID   =  newEvent%ID
    return
  end subroutine Create_Branch_Jump_Event

  subroutine Build_Subhalo_Mass_Histories(nodes,nodeList,historyCountMaximum,historyTime,historyIndex,historyMass,position,velocity)
    !% Build and attached bound mass histories to subhalos.
    use Galacticus_Error
    use String_Handling
    use Cosmology_Functions
    use Histories
    implicit none
    class           (nodeData               )         , dimension(:  ), intent(inout), target :: nodes                                    
    type            (treeNodeList           )         , dimension(:  ), intent(inout)         :: nodeList                                 
    integer         (kind=kind_int8         )         , dimension(:  ), intent(inout)         :: historyIndex
    integer         (c_size_t               )                         , intent(in   )         :: historyCountMaximum
    double precision                                  , dimension(:  ), intent(inout)         :: historyMass        , historyTime   
    double precision                                  , dimension(:,:), intent(inout)         :: position           , velocity      
    class           (nodeData               ), pointer                                        :: progenitorNode     , node      
    class           (nodeComponentSatellite ), pointer                                        :: satellite             
    class           (nodeComponentPosition  ), pointer                                        :: position_             
    class           (cosmologyFunctionsClass), pointer                                        :: cosmologyFunctions_          
    integer         (c_size_t               )                                                 :: historyCount       , iIsolatedNode 
    integer                                                                                   :: iNode                                    
    logical                                                                                   :: endOfBranch                              
    type            (varying_string         )                                                 :: message                                  
    type            (history                )                                                 :: subhaloHistory                           
    type            (longIntegerHistory     )                                                 :: subhaloIndexHistory                           
    type            (progenitorIterator     )                                                 :: progenitors
    
    if (mergerTreeReadPresetSubhaloMasses.or.mergerTreeReadPresetPositions.or.mergerTreeReadPresetSubhaloIndices) then
       ! Check that preset subhalo masses are supported.
       if (mergerTreeReadPresetSubhaloMasses .and..not.defaultSatelliteComponent%boundMassHistoryIsSettable()) &
            & call Galacticus_Error_Report('presetting subhalo masses requires a component that supports setting of node bound mass histories'//{introspection:location})
       ! Check that preset subhalo masses are supported.
       if (mergerTreeReadPresetSubhaloIndices.and..not.defaultSatelliteComponent%nodeIndexHistoryIsSettable()) &
            & call Galacticus_Error_Report('presetting subhalo indices requires a component that supports setting of node index histories'//{introspection:location})
       ! Get the default cosmology functions object.
       cosmologyFunctions_ => cosmologyFunctions()
       historyBuildNodeLoop: do iNode=1,size(nodes)
          historyBuildIsolatedSelect: if (nodes(iNode)%primaryIsolatedNodeIndex /= nodeIsUnreachable) then
             iIsolatedNode=nodes(iNode)%primaryIsolatedNodeIndex
             ! Find the subset with descendents.
             historyBuildHasDescendentSelect: if (associated(nodes(iNode)%descendent)) then
                ! Set a pointer to the current node - this will be updated if any descendents are traced.
                node => nodes(iNode)
                ! Set initial number of times in the history to zero.
                historyCount=0
                ! Select the subset which have a subhalo as a descendent and are not the primary progenitor or are initial subhalos. Also skip immediate subhalo-subhalo mergers.
                historyBuildSubhaloSelect: if ((nodes(iNode)%descendent%isSubhalo.or.nodes(iNode)%isSubhalo).and..not.Is_Subhalo_Subhalo_Merger(nodes,nodes(iNode))) then
                   ! Trace descendents until merging or final time.
                   if (nodes(iNode)%isSubhalo) then
                      node => nodes(iNode)
                   else
                      node => nodes(iNode)%descendent
                   end if
                   endOfBranch =.false.
                   historyBuildBranchWalk: do while (.not.endOfBranch)
                      ! Increment the history count for this branch.
                      historyCount=historyCount+1
                      ! Check for history count array size being exceeded.
                      if (historyCount > historyCountMaximum) then
                         message='history array length exceeded for node ['
                         message=message//nodes(iNode)%nodeIndex//'] - this should not happen'
                         call Galacticus_Error_Report(message//{introspection:location})
                      end if
                      ! Store the history.
                      historyTime(historyCount)=node%nodeTime
                      if (mergerTreeReadPresetSubhaloIndices) historyIndex(  historyCount)=node%nodeIndex
                      if (mergerTreeReadPresetSubhaloMasses ) historyMass (  historyCount)=node%nodeMass
                      if (mergerTreeReadPresetPositions     ) position    (:,historyCount)=node%position
                      if (mergerTreeReadPresetPositions     ) velocity    (:,historyCount)=node%velocity
                      ! Test the branch.
                      if (.not.associated(node%descendent).or..not.node%descendent%isSubhalo) then
                         ! End of branch reached.
                         endOfBranch=.true.
                      else
                         ! Check if merges with another subhalo.
                         call progenitors%descendentSet(node%descendent,nodes)
                         do while (progenitors%next(nodes))
                            progenitorNode => progenitors%current(nodes)
                            if     (                                                                          &
                                 &                    progenitorNode%nodeIndex         /= node%nodeIndex      &
                                 &  .and.             progenitorNode%isolatedNodeIndex /= nodeIsUnreachable   &
                                 &  .and.  associated(progenitorNode%descendent                             ) &
                                 &  .and.             progenitorNode%nodeMass           > node%nodeMass       &
                                 & ) then
                               ! Subhalo-subhalo merger.
                               endOfBranch =.true.
                               exit
                            end if
                         end do
                         ! Step to the next descendent.
                         if (.not.endOfBranch) node => node%descendent
                      end if
                   end do historyBuildBranchWalk
                   ! Set the mass history for this node.
                   if (mergerTreeReadPresetSubhaloMasses) then
                      call subhaloHistory%destroy()
                      call subhaloHistory%create(1,int(historyCount))
                      subhaloHistory%time(:  )=historyTime(1:historyCount)
                      subhaloHistory%data(:,1)=historyMass(1:historyCount)
                      satellite => nodeList(iIsolatedNode)%node%satellite()
                      call satellite%boundMassHistorySet(subhaloHistory)
                   end if
                   ! Set the node index history for this node.
                   if (mergerTreeReadPresetSubhaloIndices) then
                      call subhaloIndexHistory%destroy()
                      call subhaloIndexHistory%create(1,int(historyCount))
                      subhaloIndexHistory%time(:  )=historyTime (1:historyCount)
                      subhaloIndexHistory%data(:,1)=historyIndex(1:historyCount)
                      satellite       => nodeList(iIsolatedNode)%node%satellite()
                      call satellite%nodeIndexHistorySet(subhaloIndexHistory)
                   end if
                end if historyBuildSubhaloSelect
                ! Set the position history for this node.
                if (mergerTreeReadPresetPositions.and..not.nodeList(iIsolatedNode)%node%isPrimaryProgenitor()) then
                   ! Check if particle data is available for this node.
                   if (defaultImporter%subhaloTraceCount(node) > 0) then
                      ! Check that arrays are large enough to hold particle data. They should be. If they are not, it's a
                      ! bug.
                      if (historyCount+defaultImporter%subhaloTraceCount(node) > size(historyTime)) then
                         message='history arrays are too small to hold data for node '
                         message=message//nodeList(iIsolatedNode)%node%index()//': ['//historyCount//'+'//defaultImporter%subhaloTraceCount(node)//']='//(historyCount+defaultImporter%subhaloTraceCount(node))//'>'//size(historyTime)
                         call Galacticus_Error_Report(message//{introspection:location})
                      end if
                      ! Read subhalo position trace data.
                      call defaultImporter%subhaloTrace                                                           &
                           & (                                                                                    &
                           &  node                                                                              , &
                           &  historyTime(  historyCount+1:historyCount+defaultImporter%subhaloTraceCount(node)), &
                           &  position   (:,historyCount+1:historyCount+defaultImporter%subhaloTraceCount(node)), &
                           &  velocity   (:,historyCount+1:historyCount+defaultImporter%subhaloTraceCount(node))  &
                           & )
                      ! Increment the history count for this node.
                      historyCount=historyCount+defaultImporter%subhaloTraceCount(node)
                   end if
                   if (historyCount > 0) then
                      call subhaloHistory%destroy()
                      call subhaloHistory%create(6,int(historyCount))
                      subhaloHistory%time(:    )=          historyTime(    1:historyCount)
                      subhaloHistory%data(:,1:3)=transpose(position   (1:3,1:historyCount))
                      subhaloHistory%data(:,4:6)=transpose(velocity   (1:3,1:historyCount))
                      position_ => nodeList(iIsolatedNode)%node%position()
                      call position_%positionHistorySet(subhaloHistory)
                   end if
                end if

             end if historyBuildHasDescendentSelect
          end if historyBuildIsolatedSelect
       end do historyBuildNodeLoop
    end if
    return
  end subroutine Build_Subhalo_Mass_Histories

  subroutine Validate_Isolated_Halos(nodes)
    !% Ensure that nodes have valid primary progenitors.
    implicit none
    class  (nodeData          ), dimension(:), intent(inout) :: nodes                            
    type   (treeNode          ), pointer                     :: nodeNew          , nodeSatellite 
    class  (nodeComponentBasic), pointer                     :: newBasicComponent                
    integer                                                  :: iNode                            
    integer(c_size_t          )                              :: iIsolatedNode                    
    
    ! Search for cases where a node has no progenitors which do not descend into subhalos.
    do iNode=1,size(nodes)
       ! Only process if this is an isolated node.
       if (nodes(iNode)%isolatedNodeIndex /= nodeIsUnreachable .and. .not.nodes(iNode)%isSubhalo) then
          iIsolatedNode=nodes(iNode)%isolatedNodeIndex
          ! Select nodes with parents.
          if (associated(nodes(iNode)%node%parent)) then
             ! Select nodes with subhalo descendents which are also the primary progenitor of their parent.
             if (nodes(iNode)%descendent%isSubhalo.and.associated(nodes(iNode)%node%parent%firstChild,nodes(iNode)%node)) then
                ! Insert a copy of the parent node as its own primary progenitor. This avoids current node being promoted into its
                ! parent even though it is intended to descend into a subhalo. The copy is shifted to a very slightly earlier
                ! time to avoid having two identical halos existing simultaneously (which can be problematic if outputting
                ! quantities which use the node index as a label in dataset names for example).
                allocate(nodeNew)
                call nodes(iNode)%node%parent%copyNodeTo(nodeNew)
                nodeNew%sibling                         => nodes(iNode)%node
                nodeNew%parent                          => nodes(iNode)%node%parent
                nodeNew%firstChild                      => null()
                nodeNew%mergeTarget                     => null()
                nodeNew%siblingMergee                   => null()
                nodes(iNode)%node%parent%firstChild     => nodeNew
                newBasicComponent                       => nodeNew%basic()
                call newBasicComponent%timeSet(newBasicComponent%time()*(1.0d0-1.0d-6))
                ! Events remain attached to the original and we do not want to duplicate them.
                nodeNew%event => null()
                ! Any satellites are now attached to the copy.
                nodes(iNode)%node%parent%firstSatellite => null()
                nodeSatellite => nodeNew%firstSatellite
                do while (associated(nodeSatellite))
                   nodeSatellite%parent => nodeNew
                   nodeSatellite        => nodeSatellite%sibling
                end do
             end if
          end if
       end if
    end do
    return
  end subroutine Validate_Isolated_Halos

  subroutine Assign_UniqueIDs_To_Clones(nodeList)
    !% Assign new uniqueID values to any cloned nodes inserted into the trees.
    implicit none
    type   (treeNodeList), dimension(:), intent(inout) :: nodeList 
    integer                                            :: iNode    
    
    do iNode=1,size(nodeList)
       if (associated(nodeList(iNode)%node%firstChild)) then
          if (nodeList(iNode)%node%uniqueID() == nodeList(iNode)%node%firstChild%uniqueID()) &
               &  call nodeList(iNode)%node%firstChild%uniqueIDSet()
       end if
    end do
    return
  end subroutine Assign_UniqueIDs_To_Clones

  logical function Is_Subhalo_Subhalo_Merger(nodes,node)
    !% Returns true if {\normalfont \ttfamily node} undergoes a subhalo-subhalo merger.
    implicit none
    class(nodeData          ), dimension(:), intent(inout) :: nodes          
    class(nodeData          )              , intent(in   ) :: node       
    class(nodeData          ), pointer                     :: progenitorNode 
    type (progenitorIterator)                              :: progenitors    
    
    Is_Subhalo_Subhalo_Merger=.false.
    ! Return immediately if there is no descendent. (Since there can be no merger if there is no descendent.)
    if (.not.associated(node%descendent          )) return
    ! Return immediately if descendent is not a subhalo, as this could then not be a subhalo-subhalo merger.
    if (.not.           node%descendent%isSubhalo ) return
    ! Check if node's descendent has any progenitor nodes.
    call progenitors%descendentSet(node%descendent,nodes)
    do while (progenitors%next(nodes))
       progenitorNode => progenitors%current(nodes)
       if     (                                                                          &
            &                    progenitorNode%nodeIndex         /= node%nodeIndex  &
            &  .and.             progenitorNode%isolatedNodeIndex /= nodeIsUnreachable   &
            &  .and.  associated(progenitorNode%descendent                             ) &
            &  .and.             progenitorNode%nodeMass           > node%nodeMass   &
            & ) then
          ! It does, so this is a subhalo-subhalo merger.
          Is_Subhalo_Subhalo_Merger =.true.
          exit
       end if
    end do
    return
  end function Is_Subhalo_Subhalo_Merger

  !$GLC function attributes unused :: Dump_Tree
  subroutine Dump_Tree(nodes,highlightNodes,branchRoot)
    !% Dumps the tree structure to a file in a format suitable for processing with \href{http://www.graphviz.org/}{\normalfont \scshape dot}.
    implicit none
    class    (nodeData      ), dimension(:), intent(in   ), target   :: nodes                 
    integer  (kind=kind_int8), dimension(:), intent(in   ), optional :: highlightNodes        
    integer  (kind=kind_int8)              , intent(in   ), optional :: branchRoot            
    class    (nodeData      ), pointer                               :: node              
    integer                                                          :: fileUnit      , iNode 
    character(len=20        )                                        :: color         , style 
    logical                                                          :: outputNode
    integer  (kind=kind_int8)                                        :: branchRootHost
    
    ! Open an output file and write the GraphViz opening.
    open(newunit=fileUnit,file='mergerTreeConstructReadTree.gv',status='unknown',form='formatted')
    write (fileUnit,*) 'digraph Tree {'

    ! Identify the host of the branch root.
    if (present(branchRoot)) then
       branchRootHost =  branchRoot
       node       => null()
       do iNode=1,size(nodes)
          if (nodes(iNode)%nodeIndex == branchRootHost) node => nodes(iNode)
       end do
       if (associated(node)) then
          do while (associated(node%host).and..not.associated(node%host,node))
             node => node%host
          end do
          branchRootHost=node%nodeIndex
       end if
    else
       branchRootHost=-1_kind_int8
    end if
    
    ! Loop over all nodes.
    do iNode=1,size(nodes)
       ! Determine if node is in the branch to be output.
       if (present(branchRoot)) then
          outputNode=.false.
          node => nodes(iNode)
          do while (associated(node%host).and..not.associated(node%host,node))
             node => node%host
          end do
          outputNode=node%nodeIndex == branchRootHost
          do while (.not.outputNode.and.associated(node%descendent))
             node => node%descendent
             do while (associated(node%host).and..not.associated(node%host,node))                
                node => node%host
             end do
             outputNode=node%nodeIndex == branchRootHost
          end do
       else
          outputNode=.true.
       end if
       if (outputNode) then
          ! Write each node, setting the node shape to a box for subhalos and a circle for halos. Node label consists of the node
          ! index plus the time, separated by a colon.
          ! Determine node color.
          if (present(highlightNodes)) then
             if (any(highlightNodes == nodes(iNode)%nodeIndex)) then
                color='green'
                style='filled'
             else
                color='black'
                style='solid'
             end if
          else
             color='black'
             style='solid'
          end if
          if (nodes(iNode)%isSubhalo) then
             write (fileUnit,'(a,i20.20,a,i20.20,a,f5.2,a,a,a,a,a,f5.2,a)') '"',nodes(iNode)%nodeIndex,'" [shape=box   , label="',nodes(iNode)%nodeIndex,':',nodes(iNode)%nodeTime,'", color=',trim(color),', style=',trim(style),', z=',nodes(iNode)%nodeTime,'];'
             ! If a host node is given, add a link to it as a red line.
             if (associated(nodes(iNode)%host)) write (fileUnit,'(a,i20.20,a,i20.20,a)') '"',nodes(iNode)%nodeIndex,'" -> "',nodes(iNode)%host%nodeIndex,'" [color=red];'
          else
             write (fileUnit,'(a,i20.20,a,i20.20,a,f5.2,a,a,a,a,a,f5.2,a)') '"',nodes(iNode)%nodeIndex,'" [shape=circle, label="',nodes(iNode)%nodeIndex,':',nodes(iNode)%nodeTime,'", color=',trim(color),', style=',trim(style),', z=',nodes(iNode)%nodeTime,'];'
          endif
          ! Make a link to the descendent node using a black line.
          if (associated(nodes(iNode)%descendent)) write (fileUnit,'(a,i20.20,a,i20.20,a)') '"',nodes(iNode)%nodeIndex,'" -> "',nodes(iNode)%descendent%nodeIndex,'" ;'
       end if
    end do

    ! Close the file.
    write (fileUnit,*) '}'
    close(fileUnit)
    return
  end subroutine Dump_Tree
  
  subroutine Time_Until_Merging_Subresolution_Initialize()
    !% Initialize subresolution merging calculations.
    use Input_Parameters
    implicit none
    type(varying_string) :: mergerTreeReadSubresolutionMergingMethod                                     

    ! Initialize if necessary.
    if (.not.subresolutionMergingInitialized) then
       !$omp critical(Time_Until_Merging_Subresolution_Initialize)
       if (.not.subresolutionMergingInitialized) then
          ! Construct the satellite merging timescale object.
          !# <inputParameter>
          !#   <name>mergerTreeReadSubresolutionMergingMethod</name>
          !#   <cardinality>1</cardinality>
          !#   <defaultValue>var_str('null')</defaultValue>
          !#   <description>The name of a satellite merging timescale method to be used for computing the extra time until merging for subhalos.</description>
          !#   <source>globalParameters</source>
          !#   <type>string</type>
          !# </inputParameter>
          subresolutionSatelliteMergingTimescales => satelliteMergingTimescales(char(mergerTreeReadSubresolutionMergingMethod))
          ! Record that we are now initialized.
          subresolutionMergingInitialized=.true.
       end if
       !$omp end critical(Time_Until_Merging_Subresolution_Initialize)
    end if
    return
  end subroutine Time_Until_Merging_Subresolution_Initialize

  subroutine Time_Until_Merging_Subresolution(lastSeenNode,nodes,nodeList,iNode,timeSubhaloMerges)
    !% Compute the additional time until merging after a subhalo is lost from the tree (presumably due to limited resolution).
    use Vectors
    use Kepler_Orbits
    use Galacticus_Error
    use String_Handling
    use Galacticus_Display
    implicit none
    class           (nodeData                       )                             , intent(in   ) :: lastSeenNode                                                                      
    class           (nodeData                       ), target       , dimension(:), intent(inout) :: nodes                                     
    type            (treeNodeList                   )               , dimension(:), intent(inout) :: nodeList
    integer                                                                       , intent(in   ) :: iNode                                                                             
    double precision                                                              , intent(inout) :: timeSubhaloMerges                                                                 
    class           (nodeData                       ), pointer                                    :: primaryProgenitor    , progenitorNode  , & 
         &                                                                                           node
    class           (nodeComponentBasic             ), pointer                                    :: basic
    class           (nodeComponentPosition          ), pointer                                    :: position
    type            (treeNode                       ), pointer                                    :: hostNode             , satelliteNode
    double precision                                                , dimension(3)                :: relativePosition     , relativeVelocity           
    type            (keplerOrbit                    )                                             :: orbit                                         
    double precision                                                                              :: primaryProgenitorMass, timeUntilMerging           
    type            (progenitorIterator             )                                             :: progenitors                                                                       
    character       (len=42                         )                                             :: coordinateLabel                                                                   
    type            (varying_string                 )                                             :: message                                                                   
    logical                                                                                       :: parentIsCloned

    ! Initialize.
    call Time_Until_Merging_Subresolution_Initialize()
    ! Find the nodes that descend into our target node's descendent.
    call progenitors%descendentSet(lastSeenNode%descendent,nodes)
    if (progenitors%exist()) then
       ! Determine if the parent node has a clone primary progenitor.
       parentIsCloned=(nodeList(lastSeenNode%isolatedNodeIndex)%node%parent%uniqueID() == nodeList(lastSeenNode%isolatedNodeIndex)%node%parent%firstChild%uniqueID())
       ! If parent is cloned, we need to make a temporary progenitor node.
       if (parentIsCloned) then
          allocate(primaryProgenitor)
          basic                       => nodeList(lastSeenNode%isolatedNodeIndex)%node%parent%firstChild%basic   ()
          position                    => nodeList(lastSeenNode%isolatedNodeIndex)%node%parent%firstChild%position()
          primaryProgenitor%nodeIndex =  nodeList(lastSeenNode%isolatedNodeIndex)%node%parent%firstChild%index   ()
          primaryProgenitor%nodeMass  =  basic                                                          %mass    ()
          primaryProgenitor%position  =  position                                                       %position()
          primaryProgenitor%velocity  =  position                                                       %velocity()
       else
          primaryProgenitor     => null()
          primaryProgenitorMass =  0.0d0
          do while (progenitors%next(nodes))
             progenitorNode => progenitors%current(nodes)
             if (progenitorNode%nodeIndex /= lastSeenNode%nodeIndex .and. progenitorNode%nodeMass > primaryProgenitorMass) then
                primaryProgenitorMass =  progenitorNode%nodeMass
                primaryProgenitor     => progenitorNode
             end if
          end do
       end if
       ! Initialize time until merging to zero.
       timeUntilMerging=0.0d0
       ! If position information is available, compute the subresolution orbit.
       if (mergerTreeReadPresetPositions) then
          ! Find relative position and velocity.
          relativePosition=lastSeenNode%position-primaryProgenitor%position
          relativeVelocity=lastSeenNode%velocity-primaryProgenitor%velocity
          ! Update position/velocity for periodicity and Hubble flow.
          call Phase_Space_Position_Realize(lastSeenNode%nodeTime,relativePosition,relativeVelocity)
          ! Catch zero separation halos.
          if (Vector_Magnitude(relativePosition) == 0.0d0) then
             message='merging halos ['
             message=message//lastSeenNode%nodeIndex//' & '//primaryProgenitor%nodeIndex//'] have zero separation'
             call Galacticus_Display_Indent  (message                          ,verbosityWarn)
             write (coordinateLabel,'("[",e12.6,",",e12.6,",",e12.6,"]")') primaryProgenitor%position
             message="position [primary  ] = "//trim(coordinateLabel)
             call Galacticus_Display_Message (message                          ,verbosityWarn)
             write (coordinateLabel,'("[",e12.6,",",e12.6,",",e12.6,"]")') lastSeenNode     %position
             message="position [satellite] = "//trim(coordinateLabel)
             call Galacticus_Display_Message (message                          ,verbosityWarn)
             write (coordinateLabel,'("[",e12.6,",",e12.6,",",e12.6,"]")') primaryProgenitor%velocity
             message="velocity [primary  ] = "//trim(coordinateLabel)
             call Galacticus_Display_Message (message                          ,verbosityWarn)
             write (coordinateLabel,'("[",e12.6,",",e12.6,",",e12.6,"]")') lastSeenNode     %velocity
             message="velocity [satellite] = "//trim(coordinateLabel)
             call Galacticus_Display_Message (message                          ,verbosityWarn)
             call Galacticus_Display_Unindent('assuming instantaneous merging' ,verbosityWarn)
          else
             ! Create the orbit.
             orbit=Orbit_Construct(lastSeenNode%nodeMass,primaryProgenitor%nodeMass,relativePosition,relativeVelocity)
             ! Construct temporary nodes.
             satelliteNode                => treeNode()
             hostNode                     => treeNode()
             call    nodeList(lastSeenNode     %isolatedNodeIndex)%node                  %copyNodeTo(satelliteNode,skipEvent=.true.)
             if (parentIsCloned) then
                call nodeList(lastSeenNode     %isolatedNodeIndex)%node%parent%firstChild%copyNodeTo(hostNode     ,skipEvent=.true.)
             else
                call nodeList(primaryProgenitor%isolatedNodeIndex)%node                  %copyNodeTo(hostNode     ,skipEvent=.true.)
             end if
             satelliteNode%parent         => hostNode
             hostNode     %firstSatellite => satelliteNode             
             ! Determine the time until merging.
             timeUntilMerging=subresolutionSatelliteMergingTimescales%timeUntilMerging(satelliteNode,orbit)
             ! Clean up.
             call satelliteNode%destroy()
             call hostNode     %destroy()
             deallocate(satelliteNode)
             deallocate(hostNode     )
          end if
       end if
       ! Find the new merging time, and the node with which the merging will occur.
       node              => lastSeenNode%descendent
       timeSubhaloMerges =  timeSubhaloMerges+timeUntilMerging
       do while (associated(node%descendent))
          if (node%descendent%nodeTime > timeSubhaloMerges) then
             nodes(iNode)%mergesWithIndex=node%nodeIndex
             exit
          else
             node => node%descendent
          end if
       end do
       ! Merging time is beyond the end of the tree. Set merging time to infinity.
       if (.not.associated(node%descendent)) nodes(iNode)%mergesWithIndex=node%nodeIndex
       ! Clean up any temporary progenitor.
       if (parentIsCloned) deallocate(primaryProgenitor)
    else
       call Galacticus_Error_Report('no descendents found'//{introspection:location})
    end if
    return
  end subroutine Time_Until_Merging_Subresolution

  function Orbit_Construct(mass1,mass2,position,velocity) result(orbit)
    !% Construct a Keplerian orbit given body masses, positions, and relative velocities.
    use Kepler_Orbits
    use Vectors
    implicit none
    type            (keplerOrbit)                              :: orbit           
    double precision                           , intent(in   ) :: mass1   , mass2    
    double precision             , dimension(3), intent(in   ) :: position, velocity 
    
    call orbit%reset()
    call orbit%massesSet            (       &
         &                           mass1, &
         &                           mass2  &
         &                          )
    call orbit%radiusSet            (                                                   Vector_Magnitude(position))
    call orbit%velocityRadialSet    (                    Dot_Product(velocity,position)/Vector_Magnitude(position))
    call orbit%velocityTangentialSet(Vector_Magnitude(Vector_Product(velocity,position)/Vector_Magnitude(position)))
    return
  end function Orbit_Construct

  subroutine Phase_Space_Position_Realize(time,position,velocity)
    !% Modify relative positions and velocities to account for both any periodicity of the simulated volume, and for Hubble flow.
    use Cosmology_Functions
    use Numerical_Constants_Boolean
    implicit none
    double precision                                       , intent(in   ) :: time                                
    double precision                         , dimension(3), intent(inout) :: position           , velocity 
    class           (cosmologyFunctionsClass), pointer                     :: cosmologyFunctions_           
    double precision                                                       :: lengthSimulationBox                 
    
    ! Account for periodicity.
    if (defaultImporter%positionsArePeriodic() /= booleanFalse) then
       lengthSimulationBox=defaultImporter%cubeLength(time)
       position=mod(position+0.5d0*lengthSimulationBox,lengthSimulationBox)-0.5d0*lengthSimulationBox
       position=mod(position-0.5d0*lengthSimulationBox,lengthSimulationBox)+0.5d0*lengthSimulationBox
    end if
    ! Account for Hubble flow.
    if (defaultImporter%velocitiesIncludeHubbleFlow() /= booleanTrue) then
       cosmologyFunctions_ => cosmologyFunctions()
       velocity=velocity                                                    &
            &  +position                                                    &
            &  *cosmologyFunctions_%hubbleParameterEpochal(time=time)
    end if
    return
  end subroutine Phase_Space_Position_Realize

  subroutine progenitorIteratorDescendentSet(self,node,nodes)
    !% Initialize a progenitor iterator object by storing the index of the taget {\normalfont \ttfamily node} and finding the location of the first
    !% progenitor (if any).
    implicit none
    class(progenitorIterator)              , intent(inout) :: self  
    class(nodeData          )              , intent(in   ) :: node  
    class(nodeData          ), dimension(:), intent(in   ) :: nodes 
    
    ! Store the index of the target node.
    self%targetIndex     =node%nodeIndex
    ! Assume no progenitors descendants by default.
    self%progenitorsFound=.false.
    ! Find the index of matching nodes in the list sorted by descendent index.
    self%progenitorIndex=Descendent_Node_Sort_Index(node%nodeIndex)
    if (self%progenitorIndex > 0 .and. self%progenitorIndex <= size(nodes)) then
       ! Progenitors may exist, store the location of the first progenitor if found.
       self%progenitorLocation=descendentLocations(self%progenitorIndex)
       if (associated(nodes(self%progenitorLocation)%descendent)) &
            & self%progenitorsFound=(nodes(self%progenitorLocation)%descendent%nodeIndex == node%nodeIndex)
       ! Increment the initial index so that the first call to get the next progenitor can find the first progenitor by
       ! subtracting one from this index.
       self%progenitorIndex=self%progenitorIndex+1
    end if
    return
  end subroutine progenitorIteratorDescendentSet
  
  logical function progenitorIteratorNext(self,nodes)
    !% Move to the next progenitor using a progenitor iterator object, returning true if the next progenitor exists, false if it
    !% does not.
    implicit none
    class(progenitorIterator)              , intent(inout) :: self  
    class(nodeData          ), dimension(:), intent(in   ) :: nodes 
    
    if (self%progenitorsFound) then
       progenitorIteratorNext=.true.
       self%progenitorLocation=-1
       do while (self%progenitorIndex > 0)
          self%progenitorIndex=self%progenitorIndex-1
          if (self%progenitorIndex <= 0) exit
          self%progenitorLocation=descendentLocations(self%progenitorIndex)
          if (associated(nodes(self%progenitorLocation)%descendent)) exit
       end do
       if (.not.associated(nodes(self%progenitorLocation)%descendent)) then
          progenitorIteratorNext=.false.
          return
       end if
       if (      self%progenitorIndex                          == 0               ) progenitorIteratorNext=.false.
       if (nodes(self%progenitorLocation)%descendent%nodeIndex /= self%targetIndex) progenitorIteratorNext=.false.
    else
       progenitorIteratorNext=.false.
    end if
    return
  end function progenitorIteratorNext
  
  function progenitorIteratorIndex(self,nodes)
    !% Return the node index of the current progenitor in a progenitor iterator object.
    implicit none
    integer(kind=kind_int8    )                              :: progenitorIteratorIndex 
    class  (progenitorIterator)              , intent(in   ) :: self                    
    class  (nodeData          ), dimension(:), intent(in   ) :: nodes                   
    
    progenitorIteratorIndex=nodes(self%progenitorLocation)%nodeIndex
    return
  end function progenitorIteratorIndex
  
  function progenitorIteratorCurrent(self,nodes)
    !% Return a pointer to the current progenitor in a progenitor iterator object.
    implicit none
    class(nodeData          ), pointer                             :: progenitorIteratorCurrent 
    class(progenitorIterator)              , intent(in   )         :: self                      
    class(nodeData          ), dimension(:), intent(in   ), target :: nodes                     
    
    progenitorIteratorCurrent => nodes(self%progenitorLocation)
    return
  end function progenitorIteratorCurrent
  
  logical function progenitorIteratorExist(self)
    !% Return true if progenitors exist, false otherwise.
    implicit none
    class(progenitorIterator), intent(in   ) :: self 
    
    progenitorIteratorExist=self%progenitorsFound
    return
  end function progenitorIteratorExist
  
  !$GLC function attributes unused :: Timing_Record
  subroutine Timing_Record(label)
    !% Record timing data.
    implicit none
    character(len=*         ), intent(in   )               :: label
    real                     , allocatable  , dimension(:) :: timingTimesTmp
    type     (varying_string), allocatable  , dimension(:) :: timingLabelsTmp
    real                                                   :: timeNow
    
    call CPU_Time(timeNow)
    if (allocated(timingTimes)) then
       call Move_Alloc(timingTimes ,timingTimesTmp )
       call Move_Alloc(timingLabels,timingLabelsTmp)
       allocate(timingTimes (size(timingTimesTmp )+1))
       allocate(timingLabels(size(timingLabelsTmp)+1))
       timingTimes (1:size(timingTimesTmp ))=timingTimesTmp
       timingLabels(1:size(timingLabelsTmp))=timingLabelsTmp
       deallocate(timingTimesTmp )
       deallocate(timingLabelsTmp)
    else
      allocate(timingTimes (1))
      allocate(timingLabels(1))
    end if
    timingTimes (size(timingTimes ))=timeNow
    timingLabels(size(timingLabels))=trim(label)
    return
  end subroutine Timing_Record
  
  !$GLC function attributes unused :: Timing_Report
  subroutine Timing_Report()
    !% Report on time taken in various steps of processing merger trees read from file.
    use Galacticus_Display
    implicit none
    integer                   :: i        , lengthMaximum
    type     (varying_string) :: message
    character(len=12        ) :: timeTaken

    call Galacticus_Display_Indent("Merger tree read processing report:")
    if (allocated(timingTimes).and.size(timingTimes) > 1) then
       lengthMaximum=maxval(len(timingLabels))
       do i=2,size(timingTimes)
          write (timeTaken,'(f10.2)') timingTimes(i)-timingTimes(i-1)
          message=repeat(" ",lengthMaximum-len(timingLabels(i)))//timingLabels(i)//": "//trim(adjustl(timeTaken))//" s"
          call Galacticus_Display_Message(message)
       end do
    end if
    call Galacticus_Display_Unindent("done")
    return
  end subroutine Timing_Report

  subroutine Root_Node_Affinities_Initial(nodes)
    !% Find initial root node affinities for all nodes.
    use Memory_Management
    use Sort
    use ISO_Varying_String
    use Galacticus_Display
    use String_Handling
    implicit none
    class  (nodeDataMinimal   ), dimension(         : ), intent(inout) :: nodes
    integer(kind=kind_int8    ), dimension(size(nodes))                :: rootAffinity
    integer(c_size_t          )                                        :: i                , j                       , &
         &                                                                treeCount        , pushCount               , &
         &                                                                k                , progenitorLocation      , &
         &                                                                forestSizeI      , forestSizeJ
    integer(kind=kind_int8    )                                        :: treeIndexPrevious, treeStartPrevious       , &
         &                                                                progenitorIndex
    type   (varying_string    )                                        :: message
    logical                                                            :: nodeIsMostMassive, isolatedProgenitorExists, &
         &                                                                nodeIsPrimary
    
    ! Get a unique ID for this split forest.
    splitForestUniqueID=splitForestUniqueID+1
    ! Build sorted indices into nodes.
    call Create_Node_Indices(nodes)
    ! Initialize root affinities to impossible value.
    rootAffinity=-1_kind_int8
    ! Iterate over nodes.
    do i=1,size(nodes)
       ! Trace through hosts until a self-hosting node is found.
       j=i
       do while (nodes(j)%nodeIndex /= nodes(j)%hostIndex)
          j=Node_Location(nodes(j)%hostIndex)
       end do
       ! Trace descendents until a root node is reached.
       do while (nodes(j)%descendentIndex >= 0)
          ! Jump to descendent.
          if (nodes(j)%descendentIndex >= 0) j=Node_Location(nodes(j)%descendentIndex)
          ! Trace through hosts until a self-hosting node is found.
          do while (nodes(j)%nodeIndex /= nodes(j)%hostIndex)
             j=Node_Location(nodes(j)%hostIndex)
          end do
       end do
       ! Store root affinity.
       rootAffinity(i)=nodes(j)%nodeIndex
    end do
    ! Search for nodes which have a descendent or host with different root affinity and attempt to regroup trees into subforests
    ! of the original forest.
    do i=1,size(nodes)
       ! Process only nodes with a descendent.       
       if (nodes(i)%descendentIndex >= 0) then
          ! Check for different root affinity in descendent.
          do k=1,2
             select case (k)
             case (1)
                j=Node_Location(nodes(i)%descendentIndex)
             case (2)
                j=Node_Location(nodes(i)%      hostIndex)
             end select
             if (rootAffinity(i) /= rootAffinity(j)) then
                forestSizeI=count(rootAffinity == rootAffinity(i))
                if (forestSizeI             >= mergerTreeReadForestSizeMaximum) cycle                
                forestSizeJ=count(rootAffinity == rootAffinity(j))
                if (forestSizeI+forestSizeJ >  mergerTreeReadForestSizeMaximum) cycle
                where (rootAffinity == rootAffinity(j))
                   rootAffinity=rootAffinity(i)
                end where
              end if
          end do
       end if
    end do
    ! Get a sorted index into the root node affinities.
    call allocateArray(splitForestMapIndex,shape(nodes))
    splitForestMapIndex=Sort_Index_Do(rootaffinity)
    ! Count trees in the forest.
    treeCount        = 0
    treeIndexPrevious=-1
    do i=1,size(nodes)
       if (rootAffinity(splitForestMapIndex(i)) /= treeIndexPrevious) then
          treeCount        =treeCount                           +1
          treeIndexPrevious=rootAffinity(splitForestMapIndex(i))
       end if
    end do
    ! Identify tree size and start offsets.
    call allocateArray(splitForestTreeSize ,[treeCount])
    call allocateArray(splitForestTreeStart,[treeCount])
    treeIndexPrevious=-1
    treeStartPrevious= 0
    treeCount        = 0
    do i=1,size(nodes)
       if (rootAffinity(splitForestMapIndex(i)) /= treeIndexPrevious) then
          treeCount                      =treeCount                           +1
          treeIndexPrevious              =rootAffinity(splitForestMapIndex(i))
          splitForestTreeStart(treeCount)=                                 i
       end if
    end do
    if (treeCount > 1) then
       do i=1,treeCount-1
          splitForestTreeSize(i)=splitForestTreeStart(i+1)-splitForestTreeStart(i)
       end do
    end if
    splitForestTreeSize(treeCount)=size(nodes)+1-splitForestTreeStart(treeCount)   
    ! Report.
    call Galacticus_Display_Indent('Breaking forest into trees:',verbosityInfo)
    do i=1,treeCount
       message="Tree "
       message=message//i//" of "//treeCount//" contains "//splitForestTreeSize(i)//" node"
       if (splitForestTreeSize(i) > 1) message=message//"s"
       call Galacticus_Display_Message(message,verbosityInfo)
    end do
    ! Search for nodes which have a descendent with different root affinity.
    pushCount=0
    do i=1,size(nodes)
       ! Process only nodes with a descendent.       
       if (nodes(i)%descendentIndex >= 0) then
          ! Check for different root affinity in descendent.
          j=Node_Location(nodes(i)%descendentIndex)
          k=Node_Location(nodes(j)%      hostIndex)
          if     (                                    &
               &   rootAffinity(i) /= rootAffinity(j) &
               &  .or.                                &
               &   rootAffinity(i) /= rootAffinity(k) &
               & ) then
             ! Descendent has different root affinity - this is a cross-tree subhalo promotion event or cross-tree branch jump
             ! event.
             pushCount=pushCount+1
          end if
       end if
    end do
    message="Found "
    message=message//pushCount//" links between trees"
    call Galacticus_Display_Message(message,verbosityInfo)
    ! Build a list of push and pull links.
    call allocateArray(splitForestPushTo   ,[pushCount])
    call allocateArray(splitForestPullFrom ,[pushCount])
    call allocateArray(splitForestPushType ,[pushCount])
    call allocateArray(splitForestPushTime ,[pushCount])
    call allocateArray(splitForestIsPrimary,[pushCount])
    call allocateArray(splitForestPushDone ,[pushCount])
    call allocateArray(splitForestPullDone ,[pushCount])
    pushCount=0
    do i=1,size(nodes)
       ! Process only nodes with a descendent.
       if (nodes(i)%descendentIndex >= 0) then
          ! Check for different root affinity in descendent.
          j=Node_Location(nodes(i)%descendentIndex)
          ! Test for an inter-tree event. These are identified by a node having a different initial root affinity than its descendent.
          if (rootAffinity(i) /= rootAffinity(j)) then     
             ! Determine if our node is the primary progenitor and if an isolated progenitor exists.
             isolatedProgenitorExists=.false.
             nodeIsMostMassive       =.true.
             progenitorIndex         =Descendent_Node_Sort_Index(nodes(i)%descendentIndex)
             if (progenitorIndex > 0 .and. progenitorIndex <= size(nodes)) then
                progenitorLocation=descendentLocations(progenitorIndex)
                do while (nodes(progenitorLocation)%descendentIndex == nodes(i)%descendentIndex)
                   ! Determine progenitor status.
                   if (nodes(progenitorLocation)%nodeIndex /= nodes(progenitorLocation)%hostIndex) then
                      if     (                                                           &
                           &   nodes(progenitorLocation)%nodeIndex /= nodes(i)%nodeIndex &
                           &  .and.                                                      &
                           &   nodes(progenitorLocation)%nodeMass  >  nodes(i)%nodeMass  &
                           & ) nodeIsMostMassive=.false.
                   else
                      isolatedProgenitorExists=.true.
                   end if
                   ! Move to the next progenitor.
                   progenitorIndex=progenitorIndex-1
                   if (progenitorIndex > 0) then
                      progenitorLocation=descendentLocations(progenitorIndex)
                   else
                      exit
                   end if
                end do
             end if
             nodeIsPrimary=nodeIsMostMassive.and..not.isolatedProgenitorExists             
             ! Determine the type of event. If the descendent is a subhalo, then this is an inter-tree branch jump. If the
             ! descendent is not a subhalo this is an inter-tree subhalo promotion.
             pushCount=pushCount+1
             if (nodes(j)%nodeIndex == nodes(j)%hostIndex) then
                ! Inter-tree subhalo promotion.
                splitForestPushTime (pushCount)=nodes(j)%      nodeTime
                splitForestPushTo   (pushCount)=nodes(i)%      nodeIndex
                splitForestPullFrom (pushCount)=nodes(i)%descendentIndex
                splitForestIsPrimary(pushCount)=nodeIsPrimary
                splitForestPushType (pushCount)=pushTypeSubhaloPromotion
                splitForestPushDone (pushCount)=.false.
                splitForestPullDone (pushCount)=.false.                
             else
                ! For non-primary progenitors, detect nested subhalo hierarchy. The descendent node is a subhalo. As nested hierarchies are not currently
                ! handled, we must instead find the isolated host of the descendent and push to that node instead.
                if (.not.nodeIsPrimary) then
                   if (.not.warningSplitForestNestedHierarchyIssued) then
                      message='nested hierarchy in split forests detected [node '
                      message=message//nodes(j)%nodeIndex//']'
                      message=message//char(10)//'ignoring as not currently supported'
                      message=message//char(10)//'warning will not be issued again'
                      call Galacticus_Display_Message(message,verbosityWarn)
                      warningSplitForestNestedHierarchyIssued=.true.
                   end if
                   do while (nodes(j)%nodeIndex /= nodes(j)%hostIndex)
                      j=Node_Location(nodes(j)%hostIndex)
                   end do
                end if
                ! Inter-tree branch jump.
                k                              =Node_Location(nodes(i)%hostIndex)
                splitForestPushTime (pushCount)=              nodes(k)%nodeTime
                splitForestPushTo   (pushCount)=              nodes(i)%nodeIndex
                splitForestPullFrom (pushCount)=              nodes(j)%nodeIndex
                splitForestIsPrimary(pushCount)=nodeIsPrimary
                splitForestPushType (pushCount)=pushTypeBranchJump
                splitForestPushDone (pushCount)=.false.
                splitForestPullDone (pushCount)=.false.
             end if
          end if
       end if
    end do
    call Galacticus_Display_Unindent('done',verbosityInfo)
    return
  end subroutine Root_Node_Affinities_Initial

  logical function isOnPushList(node)
    !% Return true if the given node is on the current ``push-to'' list of nodes for split forests.
    implicit none
    class(nodeData), intent(in   ) :: node

    if (allocated(splitForestPushTo)) then
       isOnPushList=any(splitForestPushTo == node%nodeIndex)
    else
       isOnPushList=.false.
    end if
    return
  end function isOnPushList
  
  logical function isOnPullList(node)
    !% Return true if the given node is on the current ``pull-from'' list of nodes for split forests.
    implicit none
    class(nodeData), intent(in   ) :: node

    if (allocated(splitForestPullFrom)) then
       isOnPullList=any(splitForestPullFrom == node%nodeIndex)
    else
       isOnPullList=.false.
    end if
    return
  end function isOnPullList
  
  function pushListIndex(node)
    !% Return the index of the given node in the ``push-to'' list of nodes for split forests.
    implicit none
    integer(c_size_t)                :: pushListIndex
    class  (nodeData), intent(in   ) :: node
    integer(c_size_t)                :: i
    
    pushListIndex=-1_c_size_t
    do i=1,size(splitForestPushTo)
       if (splitForestPushTo(i) == node%nodeIndex) then
          pushListIndex=i
          exit
       end if
    end do
    return
  end function pushListIndex
  
  function pullListIndex(node,iPull)
    !% Return the index of the given node in the ``pull-from'' list of nodes for split forests.
    implicit none
    integer(c_size_t)                :: pullListIndex
    class  (nodeData), intent(in   ) :: node
    integer(c_size_t), intent(in   ) :: iPull
    integer(c_size_t)                :: i            , matchesRemaining
    
    pullListIndex   =-1_c_size_t
    matchesRemaining=iPull
    do i=1,size(splitForestPullFrom)
       if (splitForestPullFrom(i) == node%nodeIndex) then
          matchesRemaining=matchesRemaining-1
          if (matchesRemaining == 0) then
             pullListIndex   =i
             exit
          end if
       end if
    end do
    return
  end function pullListIndex
  
  function pullListCount(node)
    !% Return the number of the given node in the ``pull-from'' list of nodes for split forests.
    implicit none
    integer(c_size_t)                :: pullListCount
    class  (nodeData), intent(in   ) :: node
    
    if (allocated(splitForestPullFrom)) then
       pullListCount=count(splitForestPullFrom == node%nodeIndex)
    else
       pullListCount=0
    end if 
    return
  end function pullListCount
  
  subroutine Assign_Split_Forest_Events(nodes,nodeList)
    !% Assign events to nodes if they jump between trees in a forest.
    use Galacticus_Display
    use Galacticus_Error
    use String_Handling
    use Node_Events_Inter_Tree
    implicit none
    class           (nodeData          ), dimension(:), intent(inout), target :: nodes
    type            (treeNodeList      ), dimension(:), intent(inout)         :: nodeList
    class           (nodeEvent         ), pointer                             :: newEvent
    class           (nodeData          ), pointer                             :: node
    type            (treeNode          ), pointer                             :: nodeNew          , satellite
    class           (nodeComponentBasic), pointer                             :: basicNew
    integer                                                                   :: iNode
    integer         (c_size_t          )                                      :: iIsolatedNode    , progenitorLocation, &
         &                                                                       iPull
    integer         (kind=kind_int8    )                                      :: progenitorIndex
    type            (varying_string    )                                      :: message
    character       (len=12            )                                      :: label
    logical                                                                   :: nodeIsMostMassive

    !! TODO: Handle cases where branch jumps and/or subhalo promotions are disallowed.
    
    call Galacticus_Display_Indent('Assigning inter-tree events',verbosityInfo)
    do iNode=1,size(nodes)
       ! Process only isolated nodes.
       if (nodes(iNode)%isolatedNodeIndex == nodeIsUnreachable) cycle
       ! Trace through subhalo descendents.
       node => nodes(iNode)
       newEvent => null (     )
       do while (.true.)
          if (isOnPushList(node)) then
             iIsolatedNode =  nodes(iNode)%isolatedNodeIndex             
             if (.not.splitForestPushDone(pushListIndex(node))) then
                select case (splitForestPushType(pushListIndex(node)))
                case (pushTypeSubhaloPromotion)
                   allocate(nodeEventSubhaloPromotionInterTree :: newEvent)
                case (pushTypeBranchJump      )
                   allocate(nodeEventBranchJumpInterTree       :: newEvent)
                end select
                call nodeList(iIsolatedNode)%node%attachEvent(newEvent)
                newEvent%time =  splitForestPushTime(pushListIndex(node))
                newEvent%node => null()
                newEvent%task => Node_Push_From_Tree
                select type (newEvent)
                type is (nodeEventSubhaloPromotionInterTree)
                   newEvent%splitForestUniqueID =  splitForestUniqueID
                   newEvent%pairedNodeID        =  splitForestPushTo(pushListIndex(node))
                   newEvent%mergeTimeSet        => null()
                type is (nodeEventBranchJumpInterTree      )
                   newEvent%splitForestUniqueID =  splitForestUniqueID
                   newEvent%pairedNodeID        =  splitForestPushTo(pushListIndex(node))
                   newEvent%mergeTimeSet        => null()
                end select
                splitForestPushDone(pushListIndex(node))=.true.
                write (label,'(f12.8)') splitForestPushTime(pushListIndex(node))
                message="Attaching push event ["
                message=message//newEvent%ID//"] to node "//node%nodeIndex//" [-->"//splitForestPullFrom(pushListIndex(node))//"] {ref:"//splitForestPushTo(pushListIndex(node))//"} at time "//label//" Gyr"
                call Galacticus_Display_Message(message,verbosityInfo)             
             end if
          end if
          if (isOnPullList(node)) then             
             do iPull=1,pullListCount(node)
                if (.not.splitForestPullDone(pullListIndex(node,iPull))) then
                   select case (splitForestPushType(pullListIndex(node,iPull)))
                   case (pushTypeSubhaloPromotion)
                      allocate(nodeEventSubhaloPromotionInterTree :: newEvent)
                   case (pushTypeBranchJump      )
                      allocate(nodeEventBranchJumpInterTree       :: newEvent)
                   case default
                      call Galacticus_Error_Report('unknown push type'//{introspection:location})
                   end select
                   iIsolatedNode=nodes(iNode)%isolatedNodeIndex
                   if (splitForestIsPrimary(pullListIndex(node,iPull))) then
                      ! For a subhalo promotion primary progenitor, create a temporary primary progenitor node (unless we have
                      ! previously done so) to which we attach the event. This will later be replaced with our node.
                      if (splitForestPushType(pullListIndex(node,iPull)) == pushTypeBranchJump) then
                         nodeNew => nodeList(iIsolatedNode)%node
                      else
                         allocate                                    (nodeNew)
                         call nodeList(iIsolatedNode)%node%copyNodeTo(nodeNew)
                         nodeNew%sibling                         => nodeList(iIsolatedNode)%node%firstChild
                         nodeNew%parent                          => nodeList(iIsolatedNode)%node
                         nodeNew%firstChild                      => null()
                         nodeNew%mergeTarget                     => null()
                         nodeNew%siblingMergee                   => null()
                         nodeList(iIsolatedNode)%node%firstChild => nodeNew
                         basicNew                                => nodeNew%basic()
                         call basicNew%timeSet(basicNew%time()*(1.0d0-1.0d-6))
                         ! Events remain attached to the original and we do not want to duplicate them.
                         nodeNew%event => null()
                         ! Any satellites are now attached to the copy.
                         nodeList(iIsolatedNode)%node%firstSatellite => null()
                         satellite => nodeNew%firstSatellite
                         do while (associated(satellite))
                            satellite%parent => nodeNew
                            satellite        => satellite%sibling
                         end do
                      end if
                      select type (newEvent)
                      type is (nodeEventSubhaloPromotionInterTree)
                         newEvent%mergeTimeSet => null()
                      type is (nodeEventBranchJumpInterTree      )
                         newEvent%mergeTimeSet => null()
                         class default
                         call Galacticus_Error_Report('unknown event type'//{introspection:location})
                      end select
                      call nodeNew%attachEvent(newEvent)
                   else
                      ! For a non-primary progenitor, attach the event to the primary progenitor of the node, such that our node
                      ! can later be added as a sibling. If the primary progenitor has no child, create a clone.
                      if (.not.associated(nodeList(iIsolatedNode)%node%firstChild)) then
                         allocate                                    (nodeNew)
                         call nodeList(iIsolatedNode)%node%copyNodeTo(nodeNew)
                         nodeNew%parent                          => nodeList(iIsolatedNode)%node
                         nodeNew%sibling                         => null()
                         nodeNew%firstChild                      => null()
                         nodeNew%mergeTarget                     => null()
                         nodeNew%siblingMergee                   => null()
                         nodeList(iIsolatedNode)%node%firstChild => nodeNew
                         basicNew                                => nodeNew%basic()
                         call basicNew%timeSet(basicNew%time()*(1.0d0-1.0d-6))
                         ! Events remain attached to the original and we do not want to duplicate them.
                         nodeNew%event => null()
                         ! Any satellites are now attached to the copy.
                         nodeList(iIsolatedNode)%node%firstSatellite => null()
                         satellite => nodeNew%firstSatellite
                         do while (associated(satellite))
                            satellite%parent => nodeNew
                            satellite        => satellite%sibling
                         end do
                      end if
                      select type (newEvent)
                      type is (nodeEventSubhaloPromotionInterTree)
                         newEvent%mergeTimeSet => mergerTreeReadInterTreeMergeTimeSet
                      type is (nodeEventBranchJumpInterTree      )
                         newEvent%mergeTimeSet => mergerTreeReadInterTreeMergeTimeSet
                         class default
                         call Galacticus_Error_Report('unknown event type'//{introspection:location})
                      end select
                      call nodeList(iIsolatedNode)%node%firstChild%attachEvent(newEvent)
                   end if
                   newEvent%time =  splitForestPushTime(pullListIndex(node,iPull))
                   newEvent%node => null()
                   newEvent%task => Node_Pull_From_Tree
                   select type (newEvent)
                   type is (nodeEventSubhaloPromotionInterTree)
                      newEvent%splitForestUniqueID=splitForestUniqueID
                      newEvent%pairedNodeID       =splitForestPushTo      (pullListIndex(node,iPull))
                      newEvent%isPrimary          =splitForestIsPrimary   (pullListIndex(node,iPull))
                   type is (nodeEventBranchJumpInterTree      )
                      newEvent%splitForestUniqueID=splitForestUniqueID
                      newEvent%pairedNodeID       =splitForestPushTo      (pullListIndex(node,iPull))
                      newEvent%isPrimary          =splitForestIsPrimary   (pullListIndex(node,iPull))
                   class default
                      call Galacticus_Error_Report('unknown event type'//{introspection:location})
                   end select
                   splitForestPullDone(pullListIndex(node,iPull))=.true.
                   write (label,'(f12.8)') splitForestPushTime(pullListIndex(node,iPull))
                   message="Attaching pull event ["
                   message=message//newEvent%ID//"] to node "//node%nodeIndex//" [<--"//splitForestPushTo(pullListIndex(node,iPull))//"] {ref:"//splitForestPushTo(pullListIndex(node,iPull))//"} at time "//label//" Gyr"
                   call Galacticus_Display_Message(message,verbosityInfo)
                end if
             end do
          end if
          ! Is this the primary progenitor of its descendent?
          nodeIsMostMassive=.true.
          progenitorIndex  =Descendent_Node_Sort_Index(node%descendentIndex)
          if (progenitorIndex > 0 .and. progenitorIndex <= size(nodes)) then
             progenitorLocation=descendentLocations(progenitorIndex)
             do while (nodes(progenitorLocation)%descendentIndex == node%descendentIndex)
                ! Determine progenitor status.
                if     (                                                           &
                     &   nodes(progenitorLocation)%nodeIndex /= node%nodeIndex &
                     &  .and.                                                      &
                     &   nodes(progenitorLocation)%nodeMass  >  node%nodeMass  &
                     & ) nodeIsMostMassive=.false.                 
                ! Move to the next progenitor.
                progenitorIndex=progenitorIndex-1
                if (progenitorIndex > 0) then
                   progenitorLocation=descendentLocations(progenitorIndex)
                else
                   exit
                end if
             end do
          end if
          ! Move to a subhalo descendent.
          if (associated(node%descendent).and.node%descendent%isSubhalo.and.nodeIsMostMassive) then
             node => node%descendent
             ! If we've reached an isolated node, stop as we will process it in another pass through the loop.
             if (node%isolatedNodeIndex /= nodeIsUnreachable) exit
          else
             exit
          end if
       end do
    end do
    call Galacticus_Display_Unindent('done',verbosityInfo)   
    return
  end subroutine Assign_Split_Forest_Events

  subroutine mergerTreeReadInterTreeMergeTimeSet(nodeSatellite,nodeHost)
    !% Set the merging time for a node undergoing and inter-tree transfer.
    use Kepler_Orbits
    use Virial_Orbits
    use Dark_Matter_Halo_Scales
    use Galacticus_Error
    use String_Handling
    implicit none
    type            (treeNode                ), intent(inout), target  :: nodeSatellite               , nodeHost
    type            (treeNode                )               , pointer :: nodeTarget
    class           (nodeComponentSatellite  )               , pointer :: satelliteSatellite
    class           (nodeComponentBasic      )               , pointer :: basicSatellite              , basicHost       , &
         &                                                                basicTarget
    class           (nodeComponentPosition   )               , pointer :: positionSatellite           , positionHost
    class           (darkMatterHaloScaleClass)               , pointer :: darkMatterHaloScale_
    class           (virialOrbitClass        )               , pointer :: virialOrbit_
    logical                                   , parameter              :: acceptUnboundOrbits =.false.                                  
    double precision                          , dimension(3)           :: relativePosition            , relativeVelocity
    double precision                                                   :: timeUntilMerging            , radiusPericenter, &
         &                                                                radiusApocenter             , radiusVirial 
    type            (keplerOrbit             )                         :: orbit                                                            
    type            (varying_string          )                         :: message

    if (mergerTreeReadPresetMergerTimes) then
       ! If merger times are to preset, compute subresolution merging time.
       call Time_Until_Merging_Subresolution_Initialize()
       basicSatellite     => nodeSatellite%basic    (                 )
       basicHost          => nodeHost     %basic    (                 )
       positionSatellite  => nodeSatellite%position (                 )
       positionHost       => nodeHost     %position (                 )
       satelliteSatellite => nodeSatellite%satellite(autoCreate=.true.)
       relativePosition   =  positionSatellite%position()-positionHost%position()
       relativeVelocity   =  positionSatellite%velocity()-positionHost%velocity()
       orbit              =  Orbit_Construct(basicSatellite%mass(),basicHost%mass(),relativePosition,relativeVelocity)
       timeUntilMerging   =  subresolutionSatelliteMergingTimescales%timeUntilMerging(nodeSatellite,orbit)
       call satelliteSatellite%mergeTimeSet(timeUntilMerging)
       ! Set target node.
       nodeTarget => nodeHost
       do while (.true.)
          basicTarget => nodeTarget%basic()
          if (basicTarget%time() <= satelliteSatellite%timeOfMerging() .or. .not.associated(nodeTarget%parent)) exit
          nodeTarget => nodeTarget%parent
       end do       
       nodeSatellite%mergeTarget   => nodeTarget
       nodeSatellite%siblingMergee => nodeTarget   %firstMergee
       nodeTarget   %firstMergee   => nodeSatellite
       ! Assign virial orbit if necessary.
       if (mergerTreeReadPresetOrbits) then
          ! Propagate orbit to the virial radius.
          darkMatterHaloScale_ =>                      darkMatterHaloScale(        )
          virialOrbit_         =>                      virialOrbit        (        )
          radiusPericenter     =  orbit               %radiusPericenter   (        )
          radiusApocenter      =  orbit               %radiusApocenter    (        )
          radiusVirial         =  darkMatterHaloScale_%virialRadius       (nodeHost)
          ! Check if the orbit intersects the virial radius.
          if     (                                                                      &
               &    radiusVirial >= radiusPericenter                                    &
               &  .and.                                                                 &
               &   (radiusVirial <= radiusApocenter          .or. .not.orbit%isBound()) &
               &  .and.                                                                 &
               &   (.not.mergerTreeReadPresetOrbitsBoundOnly .or.      orbit%isBound()) &
               & ) then
             call orbit%propagate(radiusVirial,infalling=.true.)
             ! Set the orbit.
             call satelliteSatellite%virialOrbitSet(orbit)
             ! If the satellite component supports full phase-space position, set that also.
             if (satelliteSatellite%positionIsSettable()) call satelliteSatellite%positionSet(relativePosition)
             if (satelliteSatellite%velocityIsSettable()) call satelliteSatellite%velocitySet(relativeVelocity)
          else if (mergerTreeReadPresetOrbitsSetAll) then
             ! The given orbit does not cross the virial radius. Since all orbits must be set, choose an orbit at random.
             orbit=virialOrbit_%orbit(nodeSatellite,nodeHost,acceptUnboundOrbits)
             call satelliteSatellite%virialOrbitSet(orbit)
          else if (mergerTreeReadPresetOrbitsAssertAllSet) then
             message='virial orbit could not be set for node '
             message=message//nodeSatellite%index()//char(10)
             message=message//' -> set [mergerTreeReadPresetOrbitsAssertAllSet]=false to ignore this problem'//char(10)
             message=message//'    (this may lead to other problems)'
             call Galacticus_Error_Report(message//{introspection:location})
          end if
       end if
    else if (mergerTreeReadPresetMergerNodes) then
       ! If merger nodes are to be set, set that now.
       nodeSatellite%mergeTarget   => nodeHost
       nodeSatellite%siblingMergee => nodeHost     %firstMergee
       nodeHost     %firstMergee   => nodeSatellite
    end if
    return
  end subroutine mergerTreeReadInterTreeMergeTimeSet
  
end module Merger_Tree_Read
