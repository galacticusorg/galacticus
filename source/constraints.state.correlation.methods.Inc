!! Copyright 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017
!!    Andrew Benson <abenson@carnegiescience.edu>
!!
!! This file is part of Galacticus.
!!
!!    Galacticus is free software: you can redistribute it and/or modify
!!    it under the terms of the GNU General Public License as published by
!!    the Free Software Foundation, either version 3 of the License, or
!!    (at your option) any later version.
!!
!!    Galacticus is distributed in the hope that it will be useful,
!!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!!    GNU General Public License for more details.
!!
!!    You should have received a copy of the GNU General Public License
!!    along with Galacticus.  If not, see <http://www.gnu.org/licenses/>.

!% Defines methods for the ``correlation'' state class.

function stateCorrelationConstructor(parameterCount,acceptedStateCount)
  !% Constructor for ``correlation'' state class.
  use MPI_Utilities
  implicit none
  type   (stateCorrelation)                :: stateCorrelationConstructor
  integer                  , intent(in   ) :: parameterCount                 , acceptedStateCount
  integer                  , parameter     :: correlationLengthInitial   =100

  allocate(stateCorrelationConstructor%current           (    parameterCount                         ))
  allocate(stateCorrelationConstructor%accepted          (acceptedStateCount                         ))
  allocate(stateCorrelationConstructor%stateSum          (    parameterCount                         ))
  allocate(stateCorrelationConstructor%stateSquaredSum   (    parameterCount                         ))
  allocate(stateCorrelationConstructor%states            (    parameterCount,correlationLengthInitial))
  allocate(stateCorrelationConstructor%correlationLengths(    parameterCount                         ))
  stateCorrelationConstructor%parameterCount                 = parameterCount
  stateCorrelationConstructor%stepCount                      = 0
  stateCorrelationConstructor%storedStateCount               = 0
  stateCorrelationConstructor%stateSum                       = 0.0d0
  stateCorrelationConstructor%stateSquaredSum                = 0.0d0
  stateCorrelationConstructor%accepted                       = 0
  stateCorrelationConstructor%stepComputePrevious            = 0
  stateCorrelationConstructor%correlationLengths             =-1
  stateCorrelationConstructor%convergedCorrelationLengthCount= 0
  stateCorrelationConstructor%chainIndexValue                =mpiSelf%rank()
  return
end function stateCorrelationConstructor

subroutine stateCorrelationDestroy(self)
  !% Destructor for ``correlation'' state class.
  implicit none
  type(stateCorrelation), intent(inout) :: self

  if (allocated(self%states)) deallocate(self%states)
  return
end subroutine stateCorrelationDestroy

subroutine stateCorrelationUpdate(self,stateNew,logState,isConverged,outlierMask)
  !% Update the current state.
  implicit none
  class           (stateCorrelation), intent(inout)                                      :: self
  double precision                  , intent(in   ), dimension(:             )           :: stateNew
  logical                           , intent(in   )                                      :: logState
  logical                           , intent(in   )                                      :: isConverged
  logical                           , intent(in   ), dimension(:)             , optional :: outlierMask
  double precision                  , allocatable  , dimension(:,:           )           :: statesTmp
  integer                                                                                :: storedStateCountMaximum
  integer                                                                                :: i                      , n, &
       &                                                                                    stepComputeInterval

  call self%stateHistory%update(stateNew,logState,isConverged,outlierMask)
  ! Return if not logging states.
  if (.not.logState) return
  ! Determine if we should compute the correlation length.
  storedStateCountMaximum=size(self%states,dim=2)
  if (any(self%correlationLengths == -1)) then
     stepComputeInterval=storedStateCountMaximum
  else
     stepComputeInterval=maxval(self%correlationLengths)
  end if
  ! Store full state.
  self%storedStateCount=self%storedStateCount+1
  if (self%storedStateCount > storedStateCountMaximum) then
     self%storedStateCount=storedStateCountMaximum
     self%states(:,1:storedStateCountMaximum-1)=self%states(:,2:storedStateCountMaximum)
  end if
  self%states(:,self%storedStateCount)=stateNew
  if (self%stepCount >= self%stepComputePrevious+stepComputeInterval) then
     ! Update count of number of correlation lengths accrued post-convergence.
     if (isConverged.and..not.any(self%correlationLengths == -1)) &
          & self%convergedCorrelationLengthCount=self%convergedCorrelationLengthCount+1
     call self%correlationLengthCompute(outlierMask)
     self%stepComputePrevious=self%stepCount
  end if
  ! If any correlation length is not found, extend the number of states stored.
  if (any(self%correlationLengths == -1) .and. self%storedStateCount == storedStateCountMaximum) then
     call Move_Alloc(self%states,statesTmp)
     allocate(self%states(size(stateNew),2*size(statesTmp,dim=2)))
     self%states(:,1:size(statesTmp,dim=2))=statesTmp
     deallocate(statesTmp)
  end if
  return
end subroutine stateCorrelationUpdate

subroutine stateCorrelationReset(self)
  !% Reset the state object.
  implicit none
  class(stateCorrelation), intent(inout) :: self
  
  call self%stateHistory%reset()
  self%states                         =0.0d0
  self%storedStateCount               =0
  self%convergedCorrelationLengthCount=0
  return
end subroutine stateCorrelationReset

integer function stateCorrelationPostConvergenceCorrelationCount(self)
  !% Return the number of post-convergence correlation lengths that have accrued.
  implicit none
  class(stateCorrelation), intent(in   ) :: self
  
  stateCorrelationPostConvergenceCorrelationCount=self%convergedCorrelationLengthCount
  return
end function stateCorrelationPostConvergenceCorrelationCount

integer function stateCorrelationCorrelationLength(self)
  !% Return the correlation length.
  implicit none
  class(stateCorrelation), intent(inout) :: self

  if (any(self%correlationLengths <= 0)) call self%correlationLengthCompute()
  stateCorrelationCorrelationLength=maxval(self%correlationLengths)
  return
end function stateCorrelationCorrelationLength

subroutine stateCorrelationCorrelationLengthCompute(self,outlierMask)
  !% Compute correlation lengths.
  use MPI_Utilities
  use Galacticus_Display
  use String_Handling
  use ISO_Varying_String
  implicit none
  class           (stateCorrelation), intent(inout)                            :: self
  logical                           , intent(in   ), dimension(:), optional    :: outlierMask
  double precision                                                             :: correlation
  double precision                                 , dimension(:), allocatable :: stateMean
  integer                                                                      :: i          , n
  type            (varying_string  )                                           :: message

  ! Compute correlation lengths.
  if (mpiSelf%isMaster()) call Galacticus_Display_Indent("Computing correlation lengths")
  stateMean              =sum(self%states(:,1:self%storedStateCount),dim=2)/dble(self%storedStateCount)
  self%correlationLengths=-1
  do i=1,size(stateMean)
     do n=1,self%storedStateCount-1
        correlation=sum((self%states(i,1:self%storedStateCount-n)-stateMean(i))*(self%states(i,1+n:self%storedStateCount)-stateMean(i)))
        if (correlation <= 0.0d0) then
           self%correlationLengths(i)=n
           exit
        end if
     end do
  end do
  self%correlationLengths=mpiSelf%median(self%correlationLengths,outlierMask)
  if (mpiSelf%isMaster()) then
     message="Correlation length at step "
     message=message//self%stepCount//" = "
     do i=1,size(stateMean)
        message=message//self%correlationLengths(i)
        if (i < size(stateMean)) message=message//", "
     end do
     call Galacticus_Display_Message (message)
     call Galacticus_Display_Unindent("done" )
  end if
  return
end subroutine stateCorrelationCorrelationLengthCompute

subroutine stateCorrelationRestore(self,stateVector,first)
  !% Restore the state object from file.
  use MPI_Utilities
  use ISO_Varying_String
  implicit none
  class           (stateCorrelation), intent(inout)               :: self
  double precision                  , intent(in   ), dimension(:) :: stateVector
  logical                           , intent(in   )               :: first
  integer                                                         :: storedStateCountMaximum

  ! On first restore state, reset.
  if (first) call self%reset()
  ! Perform restore of parent class.
  call self%stateHistory%restore(stateVector,first)
  ! Store state.
  self%storedStateCount=self%storedStateCount+1
  storedStateCountMaximum=size(self%states,dim=2)
  if (self%storedStateCount > storedStateCountMaximum) then
     self%storedStateCount=storedStateCountMaximum
     self%states(:,1:storedStateCountMaximum-1)=self%states(:,2:storedStateCountMaximum)
  end if
  self%states(:,self%storedStateCount)=stateVector
  return
end subroutine stateCorrelationRestore
