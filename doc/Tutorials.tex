\chapter{Tutorials}

This chapter contains step-by-step guides to performing common tasks with \glc.

\section{Running \glc\ on N-body Merger Trees}\label{sec:nBodyRun}\index{merger trees!N-body}\index{N-body!merger trees}

See \S\ref{sec:MergerTreeBuilder} for details of how to build merger tree files suitable for input into \glc.

\subsection{Setting Input Parameters}

To utilize merger trees from the file that you created in a \glc\ run it's necessary to set two parameters in the input parameter file that you will use for the run:
\begin{verbatim}
  <!-- Specify that merger trees are to be read from file, and give the name of the file to read -->
  <parameter>
    <name>mergerTreeConstructMethod</name>
    <value>read</value>
  </parameter>
  <parameter>
    <name>mergerTreeReadFileName</name>
    <value>myNBodyTrees.hdf5</value>
  </parameter>
\end{verbatim}
The first of these {\tt [mergerTreeConstructMethod]}$=${\tt read} tells \glc\ that merger trees will be constructed by reading them from a file. The second, {\tt [mergerTreeReadFileName]}, gives the name of the file from which to read the trees. In this example, we use the name of the file that was jus created.

In addition to specifying that trees should be read from a file, it's also important to ensure that the values of cosmological parameters in \glc\ match those in the merger tree file. (If they don't match, \glc\ will stop with an error message unless you set {\tt [mergerTreeReadMismatchIsFatal]}$=${\tt false} in which case you'll just be warned about any mismatch.) In our case of using merger trees from the Millennium Simulation, the correct cosmological parameter values can be set as follows:
\begin{verbatim}
  <!-- Use Millennium Simulation cosmology. -->
  <parameter>
    <name>H_0</name>
    <value>73.0</value>
  </parameter>
  <parameter>
    <name>Omega_Matter</name>
    <value>0.25</value>
  </parameter>
  <parameter>
    <name>Omega_DE</name>
    <value>0.75</value>
  </parameter>
  <parameter>
    <name>Omega_b</name>
    <value>0.0455</value>
  </parameter>
  <parameter>
    <name>sigma_8</name>
    <value>0.9</value>
  </parameter>
  <parameter>
    <name>powerSpectrumIndex</name>
    <value>1.0</value>
  </parameter>
  <parameter>
    <name>powerSpectrumReferenceWavenumber</name>
    <value>1</value>
  </parameter>
  <parameter>
    <name>powerSpectrumRunning</name>
    <value>0</value>
  </parameter>
\end{verbatim}

Normally, \glc\ assumes that all merger trees will exist (i.e. have at least one node present) at the final output time. This may not be true of trees extracted from an N-body simulation---in this case \glc\ can be informed of this fact by setting:
\begin{verbatim}
  <parameter>
    <name>allTreesExistAtFinalTime</name>
    <value>false</value>
  </parameter>
\end{verbatim}

N-body merger trees are often built from ``snapshots'' of the simulation, i.e. all of the nodes exist at a set of discrete times. Often we want to output nodes at precisely these output times. In such cases it is useful to set:
\begin{verbatim}
  <parameter>
    <name>mergerTreeReadOutputTimeSnapTolerance</name>
    <value>1.0d-3</value>
  </parameter>
\end{verbatim}
which ensures that the times of nodes are adjusted to lie at precisely the output time if that time is within the specified relative tolerance (this avoids any small differences between node times and output times that can arises due to rounding errors when converting from redshifts to times and vice-versa).

Further parameters can be set to control what information from the stored trees will be used in \glc. Examples are given below.

\subsubsection{Node Positions}

If position and velocity information for tree nodes is available within the merger tree file then \glc\ can be instructed to use this information by using the ``preset'' method for tree node positions and telling the merger tree construction method to preset node positions as follows:
\begin{verbatim}
  <!-- Use merger tree node positions -->
  <parameter>
    <name>treeNodeMethodPosition</name>
    <value>preset</value>
  </parameter>
  <parameter>
    <name>mergerTreeReadPresetPositions</name>
    <value>true</value>
  </parameter>
\end{verbatim}
If position information is unavailable, the ``null'' position method can be selected and the merger tree construction method instructed not to preset positions as follows:
\begin{verbatim}
  <!-- Do not use merger tree node positions -->
  <parameter>
    <name>treeNodeMethodPosition</name>
    <value>null</value>
  </parameter>
  <parameter>
    <name>mergerTreeReadPresetPositions</name>
    <value>false</value>
  </parameter>
\end{verbatim}

\subsubsection{Virial Orbits}\index{orbits!virial}\index{orbits!setting}\index{orbits!N-body}

If position and velocity information for tree nodes is available within the merger tree file then \glc\ can be instructed to use this information to estimate the orbit of each subhalo at the point at which it crosses the virial radius of its host halo. This ``virial orbit'' may then be used by, for example, calculations of merging timescales.
\begin{verbatim}
  <!-- Use merger tree node positions to compute orbits at the virial radius -->
  <parameter>
    <name>mergerTreeReadPresetOrbits</name>
    <value>true</value>
  </parameter>
  <parameter>
    <name>mergerTreeReadPresetOrbitsBoundOnly</name>
    <value>true</value>
  </parameter>
  <parameter>
    <name>mergerTreeReadPresetOrbitsSetAll</name>
    <value>true</value>
  </parameter>
  <parameter>
    <name>mergerTreeReadPresetOrbitsAssertAllSet</name>
    <value>true</value>
  </parameter>
\end{verbatim}
Typically, a merging halo is not seen at precisely the time at which it crosses the virial radius of its host (due to the fact that N-body simulations are output at discretely spaced timesteps). Therefore, \glc\ computes the orbit at the time just prior to merging and assumes that the orbital parameters (energy and angular momentum) remain fixed to propagate the orbit to the virial radius of the host. The second parameter in the above example, {\tt [mergerTreeReadPresetOrbitsBoundOnly]}, specifies whether or not only bound orbits should be set. Some calculations (e.g. of subhalo merging times) assume bound orbits and may fail if given an unbound orbit. Setting this option to {\tt true} causes only bound orbits to be preset---unbound orbits are ignored. Note that some orbits cannot be propagated to the virial radius (i.e. their pericenter is larger than the virial radius). The {\tt [mergerTreeReadPresetOrbitsSetAll]} option, if true, will cause such orbits to be assigned randomly using the selected XXXXX method, such that all orbits are assigned. The {\tt [mergerTreeReadPresetOrbitsAssertAllSet]} option requires that all orbits be set---if {\tt [mergerTreeReadPresetOrbitsSetAll]}$=${\tt false} and {\tt [mergerTreeReadPresetOrbitsAssertAllSet]}$=${\tt true} then \glc\ will exit with an error message if any orbit cannot be set.

\subsubsection{Merging Times and Targets}

The times at which subhalos merge with their host halo can be determined directly from the merger tree file if subhalo information is included in that file. Merging is assumed to occur when the subhalo no longer has a distinct descendent (i.e. it descends into a non-subhalo). If merging times are to be computed in this way set
\begin{verbatim}
  <parameter>
    <name>treeNodeMethodSatellite</name>
    <value>preset</value>    
  </parameter>
  <parameter>
    <name>mergerTreeReadPresetMergerTimes</name>
    <value>true</value>    
  </parameter>
\end{verbatim}
which select a satellite orbit method that allows merger times to be present and tell the merger tree construction method to preset those merger times respectively. If merger times are not to be computed in this way then instead set, for example,
\begin{verbatim}
  <parameter>
    <name>treeNodeMethodSatellite</name>
    <value>standard</value>    
  </parameter>
  <parameter>
    <name>mergerTreeReadPresetMergerNodes</name>
    <value>false</value>
  </parameter>
  <parameter>
    <name>satelliteMergingMethod</name>
    <value>Jiang2008</value>
  </parameter>
\end{verbatim}
which selects a standard satellite orbit method, prevents attempts to preset the merger times and selects the {\tt Jiang2008} method for computing merger times instead.

In addition to setting the times of merger events, it is possible to set the target node with which a merging node should merge. By default, \glc\ will assume that all merging occurs with the non-subhalo host node in which a subhalo is located. This may not be the desired behavior when using N-body merger trees. For example, such trees may indicate that a subhalo merges with another subhalo. Setting
\begin{verbatim}
  <parameter>
    <name>mergerTreeReadPresetMergerNodes</name>
    <value>true</value>
  </parameter>
\end{verbatim}
will cause the target node with which each merger should occur to be determined from the merger tree structure and preset for use in \glc.

It is possible to add a delay between the last time at which a subhalo was seen in a simulation and the time at which it is considered to merge. This functionality is motivated by the consideration that a subhalo vanishing from a simulation may be simply due to it dropping below resolution rather than it actually having undergone a merger. The parameter {\tt [mergerTreeReadSubresolutionMergingMethod]} can be used to select a satellite merging timescale method (see \S\ref{sec:SatelliteMergingTimescales}) to use in this case. (It is set by default to ``{\tt null}'' such that no delay before merging occurs.) The orbit of the subhalo around its parent at the last time it is present in the merger tree is passed to this method and used to estimate a time until merging. This delay is added to the time at which the subhalo merges and, if merge target nodes are being set, the target node is updated accordingly.

\subsubsection{Subhalo Masses}

The masses of subhalos (specifically their time evolution after they become subhalos) can be set using the values stored in the merger tree file (if available). To set subhalo masses in this way use
\begin{verbatim}
  <parameter>
    <name>treeNodeMethodSatellite</name>
    <value>preset</value>    
  </parameter>
  <parameter>
    <name>mergerTreeReadPresetSubhaloMasses</name>
    <value>true</value>
  </parameter>
\end{verbatim}
to first select the ``preset'' satellite orbit method (which allows subhalo masses to be preset) and, second, to instruct the merger tree construction algorithm to preset those masses.

\subsubsection{Node Spins}

If information on the angular momenta of nodes is available in the merger tree file, this can be used to preset the value of the spin parameter in each node\footnote{Before doing this, it is important to be sure that the angular momenta of the nodes are reliable. For example, in low mass nodes extracted from an N-body simulation resolution effect may limit the accuracy of the measured angular momentum.} by setting:

\begin{verbatim}
  <parameter>
    <name>mergerTreeReadPresetSpins</name>
    <value>true</value>
  </parameter>
\end{verbatim}

The spin parameter is set using the angular momentum of each node stored in the merger tree file using:
\begin{equation}
 \lambda = {|{\bf J}| |E|^{1/2} \over {\rm G} M^{5/2}}
\end{equation}
where $|{\bf J}|$ is the magnitude of the node's angular momentum, $M$ is the node's mass and $E$ is its energy. Additionally, by setting:

\begin{verbatim}
  <parameter>
    <name>mergerTreeReadPresetSpins3D</name>
    <value>true</value>
  </parameter>
\end{verbatim}
the spin vector of each node will be set (assuming that the vector angular momenta of nodes are available in the merger tree file) using:
\begin{equation}
 {\boldmath \lambda} = {{\bf J} |E|^{1/2} \over {\rm G} M^{5/2}}.
\end{equation}

\subsubsection{Node Scale Radii}

If information on the half-mass or scale radii of nodes is available in the merger tree file, it can be used to preset the value of the dark matter halo scale radius in each node by setting:

\begin{verbatim}
  <parameter>
    <name>mergerTreeReadPresetScaleRadii</name>
    <value>true</value>
  </parameter>
\end{verbatim}

Before doing this, it is important to be sure that the half-mass or scale radii of the nodes are reliable. For example, in low mass nodes extracted from an N-body simulation resolution effect may limit the accuracy of the measured half-mass or scale radius. In such cases, use the {\tt [mergerTreeReadPresetScaleRadiiMinimumMass]} parameter to specify the lowest mass halos for which the scale radii should be preset---lower mass halos will be assigned a scale radius using whatever method is selected by the {\tt [darkMatterConcentrationMethod]} parameter (see \S\ref{sec:DarkMatterProfileConcentration}).

If only half-mass radii are available, the scale radius is set by using a root finding algorithm to ensure that half of the total halo mass is enclosed within the specified half-mass radius.

\subsubsection{Miscellaneous N-body Properties}

Several miscellaneous properties often available from N-body merger trees can also be preset by setting the following parameters to {\tt true}:
\begin{description}
\item[{mergerTreeReadPresetParticleCounts}] Sets the number of particles in each halo (requires the {\tt particleCount} dataset to be present in the merger tree file);
\item[{mergerTreeReadPresetVelocityMaxima}] Sets the maxima of halo rotation curves (requires the {\tt velocityMaximum} dataset to be present in the merger tree file);
\item[{mergerTreeReadPresetVelocityDispersions}] Sets the velocity dispersion of halos (requires the {\tt velocityDispersion} dataset to be present in the merger tree file).
\end{description}

\subsubsection{``Fly-by'' Halos}

In some cases, a halo that is part of one tree can later become part of another tree. This can happen in so-called ``fly-by'' encounters where a halo may briefly become a subhalo in a halo in tree A then leave that halo and become a subhalo in tree B.

The correct way to handle this issue is to combine trees A and B into a single tree (which will now have multiple base nodes). \glc\ will then process these two trees simultaneously, correctly handling the fly-by, and outputting the trees as two separate trees.

If for some reason this is not possible or desired, the fly-by problem will normally cause \glc\ to complain that the host halo of a node cannot be found (since it exists in a different tree). This problem can be avoided by setting:
\begin{verbatim}
  <parameter>
    <name>mergerTreeReadMissingHostsAreFatal</name>
    <value>false</value>
  </parameter>
\end{verbatim}
In this case, nodes with missing hosts are simply treated as being isolated halos. This will avoid an error condition, but is not a physically correct way to handle such cases, so use with caution.

\subsection{Analyzing the Output}

\subsubsection{Positions and Velocities}

Components of the position of each node are output as {\tt positionX}, {\tt positionY} and {\tt positionZ} and can be accessed in the same way as other output properties from \glc\ (see \S\ref{sec:nodeDataGroup} and \S\ref{sec:perlModuleDataExtraction}).

\subsubsection{Subhalo Masses}

The current mass of subhalos is available via the {\tt nodeBoundMass} otuput dataset and can be accessed in the same way as other output properties from \glc\ (see \S\ref{sec:nodeDataGroup} and \S\ref{sec:perlModuleDataExtraction}). For non-subhalos this property is equal to the usual {\tt nodeMass} property.

\section{Generating Mock Catalogs with Lightcones from the Millennium Simulation}\index{lightcone}\index{Millennium Simulation}\index{mock catalog}

Suppose that you want to create a catalog of galaxies as would be found in a survey of an area of the sky out to some redshift. Such a ``mock catalog'' can be built by populating with galaxies all of the dark matter halos which happen to lie within the cone which that area makes as it is projected from the observer through the Universe.

Generating such a mock catalog using \glc\ involves first extracting the halos (and their merger trees) within this ``lightcone'' from a suitable N-body simulation, and then processing them through \glc. In this tutorial, we will specifically make use of the \href{http://gavo.mpa-garching.mpg.de/MyMillennium3/MyDB}{Millennium Simulation database} to provide the merger trees, but the same principles apply to any N-body simulation.

The script, {\tt scripts/aux/Millennium\_Lightcone\_Grab.pl} can be used to retrieve merger trees that intersect a given lightcone from the Millennium Database and to store them in \glc's format (see \S\ref{sec:MergerTreeFileFormat}). The script is used as follows:
\begin{verbatim}
scripts/aux/Millennium_Lightcone_Grab.pl <lightconeDirectory> <fieldSize> <maximumRedshift>
    --user <myUserName> --password <myPassword> --treesPerFile <treesPerFile>
\end{verbatim}
Here, {\tt \textless lightconeDirectory\textgreater} is the name of a (pre-existing) directory into which merger tree data will be stored, {\tt \textless fieldSize\textgreater} is the length (in degrees) of one side of the square field of view of the lightcone, {\tt \textless maximumRedshift\textgreater} is the highist redshift for which halos should be included in the catalog. The {\tt --user} and {\tt --password} options allow you to specify your username and password for accessing the Millennium Simulation database. Finally, the {\tt --treesPerFile} specifies how many merger trees should be stored in each file (the script will split the lightcone between many files---this is primarily so that each request sent to the Millennium Database server is not too large). If no value is specified a default of 200 trees per file will be used.

The script generates multiple SQL queries to the Millennium database in order to first find all halos which intersect the lightcone and second to retrieve the complete merger tree associated with each such halo. These merger trees are then stored in \glc's merger tree file format in files named {\tt Lightcone\_Trees\_AAA:BBB.hdf5} in the given {\tt \textless lightconeDirectory\textgreater}, where {\tt AAA} and {\tt BBB} are numbers giving the first and last trees in the file\footnote{Note that these are not the ID numbers of the trees, just a sequential count of all trees retrieved.}

Each of the merger tree files created can then be run through \glc\ in the usual way (see \S\ref{sec:nBodyRun}).  Outputs should be requested at every Millennium snapshot (up to the largest redshift to be considered), and the {\tt lightcone} filter should be used to cause only those galaxies which intersect the lightcone to be output---for example:
\begin{verbatim}
<!-- Set output redshifts to the snapshots in the milliMillennium. -->                                                                                                
<parameter>
  <name>outputRedshifts</name>
  <value>
    0.0000 0.0199 0.0414 0.0645 0.0893 0.1159 0.1444 0.1749 0.2075 0.2425
    0.2798 0.3197 0.3623 0.4079 0.4566 0.5086 0.5642 0.6236 0.6871 0.7550
    0.8277 0.9055 0.9887 1.0779 1.1734 1.2758 1.3857 1.5036 1.6303 1.7663
    1.9126 2.0700 2.2395 2.4220 2.6189 2.8312 3.0604 3.3081 3.5759 3.8657
    4.1795 4.5196 4.8884 5.2888 5.7239 6.1968
  </value>
</parameter>

<!-- Add a lightcone filter with the required geometry -->                                                                    
<parameter>
  <name>mergerTreeOutputFilters</name>
  <value>lightcone</value>
</parameter>
<parameter>
  <name>filterLightconeGeometryFileName</name>
  <value>lightconeDirectory/geometry.xml</value>
</parameter>                                                                                                                                                          
\end{verbatim}
where the {\tt geometry.xml} file will have been automatically created within the {\tt \textless lightconeDirectory\textgreater} directory.

Selecting the lightcone filter automatically causes lightcone coordinate information (i.e. the position and velocity of each galaxy in a coordinate system with axes aligned along the line of sight of the lightcone and parallel to the two edges of the square field of view) to be output (see \S\ref{sec:OutputLightcone}). The redshift of each galaxy is also output.

\section{Using the Instantaneous Recycling Approximation}\index{recycling!instantaneous}\index{instantaneous recycling approximation}

Choosing {\tt [stellarPopulationPropertiesMethod]}$=${\tt instantaneous} will cause \glc\ to use the instantaneous recycling approximation for all calculations of stellar populations. The recyling rate and yield to use are set by the {\tt [imfNAMERecycledInstantaneous]} and {\tt [imfNAMEYieldInstantaneous]} parameters respectively, where {\tt NAME} is the name of the appropriate \gls{imf}.

Setting {\tt [stellarPopulationPropertiesMethod]}$=${\tt noninstantaneous} causes \glc\ to use a fully non-instantaneous, metal-depdendent calculation of recycling, metal production and \gls{sne} rates. However, it is possible to force this method to operate in the instantaneous recycling approximation limit (which can be useful for testing and comparison) by setting:
\begin{verbatim}
<parameter>
  <!-- Force the calculation of recycling, yields etc. to   -->
  <!-- be done assuming instantaneous recycling             -->
  <name>starFormationImfInstantaneousApproximation</name>
  <value>true</value>
</parameter>
<parameter>
  <!-- Set the mass of stars which should be used as the    -->
  <!-- dividing line between long-lived and instantaneously -->
  <!-- evolving in this approximation.                      -->
  <name>starFormationImfInstantaneousApproximationMassLongLived</name>
  <value>1.0</value>
</parameter>
<parameter>
  <!-- Set the effective age of populations to use in this -->
  <!-- approximation when computing SNe numbers.           -->
  <name>starFormationImfInstantaneousApproximationEffectiveAge</name>
  <value>13.8</value>
</parameter>
\end{verbatim}

\section{Computing Dust Attenuation and Emission Using Galacticus+Grasil}\label{sec:TutorialGrasil}\index{dust!emission}\index{dust!attenutation}\index{Grasil@{\sc Grasil}}

\glc\ can interface with the \href{http://adlibitum.oat.ts.astro.it/silva/grasil/grasil.html}{\sc Grasil} code to compute the attenutation of starlight by dust, along with the re-emission of absorbed energy by that dust. To do this, it is necessary to store the entire star formation history of galaxies in a \glc\ model, as {\sc Grasil} uses this information to determine the attenuation of stellar populations as a function of their age.

Recording star formation histories is as simple as setting the {\tt [starFormationHistoriesMethod]} parameter to {\tt metallicitySplit}. This particular star formation history method stores the star formation in each galaxy as a function of time and metallicity, as required by {\sc Grasil}. The level of detail with which the star formation history is stored is controlled by several parameters:
\begin{description}
\item [{\tt starFormationHistoryTimeStep}] The timestep used in discretizing star formation histories.
\item [{\tt starFormationHistoryFineTimeStep}] The timestep to use in discretizing star formation histories just prior to output times. This should typically be smaller than {\tt [starFormationHistoryTimeStep]} to give improved resolution in the star formation hsitory for recently formed stars.
\item [{\tt starFormationHistoryFineTime}] The period before each output for which the {\tt [starFormationHistoryFineTimeStep]} should be used.
\item [{\tt starFormationHistoryMetallicityCount}] The number of bins in metallicity to use when discretizing the star formation history.
\item [{\tt starFormationHistoryMetallicityMinimum}] The upper limit to the metallicity in the lowest metallicity bin (i.e. the lowest metallicity bin will extend from zero to this value).
\item [{\tt starFormationHistoryMetallicityMaximum}] The upper limit to the metallicity in the highest metallicity bin.
\end{description}
Default values set a timestep of 0.1~Gyr, with 0.01~Gyr timesteps for 0.1~Gyr before each output, along with 10 metallicity bins ranging from $10^{-4}Z_\odot$ to $10Z_\odot$. It is always recommended to check that these values result in a sufficiently well-resolved star formation history for your purposes.

When run with these parameter settings \glc\ will output an additional group to the output file called {\tt starFormationHistories}. This contains a hierarchically arranged set of datasets describing the star formation histories. The hierarchy extends through output number, and merger tree index. For example {\tt starFormationHistories/Output5/mergerTree3/} will contain the star formation history for merger tree 3 at output 5. This group will, in general, contain many datasets, e.g.
\begin{verbatim}
diskSFH7819       Dataset {11, 34}
diskTime7819      Dataset {34}
spheroidSFH7819   Dataset {11, 34}
spheroidTime7819  Dataset {34}
\end{verbatim}
In this case, datasets are present for both a disk and bulge component of node 7819. (If a node does not contain one of these components, the corresponding dataset will be missing.) The ``{\tt Time}'' datasets give the times at which the star formation history is stored, while the ``{\tt SFH}'' datasets give the mass of stars formed in each time/metallicity bin. (The metallicities themselves are available in the {\tt starFormationHistories/metallicities} dataset.)

Properties of the {\sc Grasil} \gls{sed} can now be accessed using the {\tt Galacticus::Grasil} module (see \S\ref{sec:Grasil}). When such properties are requested, {\sc Grasil} will be automatically run on each selected galaxy, the \gls{sed} computed and stored to the \glc\ file\footnote{{\sc Grasil} \glspl{sed} are stored in the {\tt grasilSEDs} group in a hierarchy of output, merger tree, and node groups, as for the star formation histories. Within each node group three datasets are stored, giving the {\tt wavelength}, {\tt inclination}, and {\tt SED} of the galaxy.}, and the relevant fluxes computed. If necessary, {\sc Grasil} and its data files will be downloaded automatically. Multiple {\sc Grasil} models will be run simultaneously if multiple cores are available.

For example:
\begin{verbatim}
# Specify model.                                                                                                                 
my $galacticus;
$galacticus->{'file' } = "/galacticus.hdf5";
$galacticus->{'store'} = 0;
$galacticus->{'tree' } = "all";

# Specify Grasil options.                                                                                                        
$galacticus->{'grasilOptions'}->{'includePAHs'            } = 1;
$galacticus->{'grasilOptions'}->{'fluctuatingTemperatures'} = 1;
$galacticus->{'grasilOptions'}->{'wavelengthCount'        } = 1000;
$galacticus->{'grasilOptions'}->{'radialGridCount'        } = 30;
$galacticus->{'grasilOptions'}->{'recomputeSEDs'          } = 0;

# Read results from model.                                                                                                       
&HDF5::Select_Output($galacticus,2.0);
&HDF5::Get_Dataset  ($galacticus,
                           [
                            'grasilFlux850microns',
                            'grasilFlux250microns',
                            'grasilFlux350microns',
                            'grasilFlux500microns',
                            'grasilInfraredLuminosity'
                           ]
\end{verbatim}
The {\tt grasilOptions} block in the above controls the behavior of {\sc Grasil}. Here we've chosen to include calculations of \gls{pah} features, have accounted for fluctuating tempertures in small grains (both of which slow down the calculation but make it more accurate), have specified the number of wavelengths and the size of the radial grid used to model each galaxy. We have also specified that the \gls{sed} should not be recomputed---if {\sc Grasil} fluxes are requested in future for galaxies in this model, they will be computed from the stored {\sc Grasil} \gls{sed}. If you want to change the parameters of the {\sc Grasil} calculation then set the {\tt recomputeSED} option to 1 instead\footnote{Exercise caution when using this option. Recomputing SEDs requires deleting the old SED group. The HDF5 library currently does not clean up the space occupied by the datasets in this deleted group, so the file size can grow rapidly if you repeatedly recompute {\sc Grasil} SEDs.}. Fluxes are returned in units of Janskys, while the total infrared luminosity ({\tt grasilInfraredLuminosity}) is returned in units of Solar luminosities.

A simple plotting script is provided which illustrates how to access and use the {\sc Grasil} \glspl{sed} stored in \glc\ files. For example:
\begin{verbatim}
scripts/plotting/plotGrasilSpectrum.pl galacticus.hdf5 5 9 217 43.2 SED.pdf
\end{verbatim}
will plot the \gls{sed} of node 217, in merger tree 9, at output 5 from the {\tt galacticus.hdf5} file. The \gls{sed} will be shown for an inclination of $43.2^\circ$ and the plot will be written to {\tt SED.pdf}.

\section{Outputting Stellar Luminosities}\index{luminosities!stellar}\index{stellar!luminosities}\index{luminosities!galactic}\index{galaxy!luminosities}

\glc\ can compute the stellar luminosity of galaxies in any required combination of filter, redshift, and frame. To cause luminosities to be computed add something such as the following to your input parameter file:
\begin{verbatim}
 <parameter>
  <name>luminosityFilter</name>
  <value>SDSS_r</value>
 </parameter>
 <parameter>
  <name>luminosityRedshift</name>
  <value>0.1</value>
 </parameter>
 <parameter>
  <name>luminosityType</name>
  <value>observed</value>
 </parameter>
\end{verbatim}
This would result in a dataset called {\tt diskLuminositiesStellar:SDSS\_r:observed:z0.1000} being output (along with a similar dataset for the spheroid component), corresponding to the luminosity in the SDSS r-band filter, as observed at $z=0.1$. To get the same filter but in the rest-frame of the galaxy, change the {\tt luminosityType} to ``{\tt rest}''. Available filters can be found in the {\tt data/filters} folder. Luminosities are always output in units of the zero-point of the AB magnitude system, such that $-2.5\log_{10}L$ (where $L$ is the output luminosity) gives the AB absolute magnitude of the galaxy.

You can add additional luminosities by simply adding more entries in these parameter values. For example:
\begin{verbatim}
 <parameter>
   <name>luminosityFilter</name>
   <value>SDSS_r SDSS_g</value>
 </parameter>
 <parameter>
   <name>luminosityRedshift</name>
   <value>0.1 0.3</value>
 </parameter>
 <parameter>
   <name>luminosityType</name>
   <value>observed rest</value>
 </parameter>
\end{verbatim}
would result in datasets {\tt diskLuminositiesStellar:SDSS\_r:observed:z0.1000} and {\tt diskLuminositiesStellar:SDSS\_g:rest:z0.3000}. 
