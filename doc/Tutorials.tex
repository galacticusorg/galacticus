\chapter{Tutorials}

This chapter contains step-by-step guides to performing common tasks with \glc.

\section{Running \glc\ on N-body Merger Trees}\label{sec:nBodyRun}\index{merger trees!N-body}\index{N-body!merger trees}

See \S\ref{sec:MergerTreeBuilder} for details of how to build merger tree files suitable for input into \glc. There are many options which control precisely how merger trees read from file should be handled. The following section provides guidance on the best choice of parameters.

\subsection{Setting Input Parameters}

To utilize merger trees from the file\footnote{The following assumes that merger trees will be read from a file following \protect\glc's standard HDF5 format which is described in Appendix~\protect\ref{sec:MergerTreeFileFormat}.} that you created in a \glc\ run it's necessary to set two parameters in the input parameter file that you will use for the run:
\begin{verbatim}
  <!-- Specify that merger trees are to be read from file, and give the name of the file to read -->
  <mergerTreeConstructMethod value="read"             />
  <mergerTreeReadFileName    value="myNBodyTrees.hdf5"/>
\end{verbatim}
The first of these {\normalfont \ttfamily [mergerTreeConstructMethod]}$=${\normalfont \ttfamily read} tells \glc\ that merger trees will be constructed by reading them from a file. The second, {\normalfont \ttfamily [mergerTreeReadFileName]}, gives the name of the file from which to read the trees.

In order to choose sensible settings for the various parameters that control merger trees read from file, it is recommended that you read through each of the items below and follow the guidance given.

{\normalfont \bfseries Cosmology:} In addition to specifying that trees should be read from a file, it's also important to ensure that the values of cosmological parameters in \glc\ match those in the merger tree file. (If they don't match, \glc\ will stop with an error message unless you set {\normalfont \ttfamily [mergerTreeReadMismatchIsFatal]}$=${\normalfont \ttfamily false} in which case you'll just be warned about any mismatch.) In our case of using merger trees from the Millennium Simulation, the correct cosmological parameter values can be set as follows:
\begin{verbatim}
  <!-- Use Millennium Simulation cosmology. -->
  <cosmologyParametersMethod value="simple"/>
   <HubbleConstant  value="73.0"  />
   <OmegaMatter     value="0.25"  />
   <OmegaDarkEnergy value="0.75"  />
   <OmegaBaryon     value="0.0455"/>
  </cosmologyParametersMethod>
  <cosmologicalMassVarianceMethod value="filteredPower">
    <sigma_8 value="0.900"/>
  </cosmologicalMassVarianceMethod>
  <powerSpectrumPrimordialMethod value="powerLaw">
    <index               value="1.000"/>
    <wavenumberReference value="1.000"/>
    <running              value="0.000"/>
  </powerSpectrumPrimordialMethod>
\end{verbatim}

{\normalfont \bfseries Existance at Final Time:} Normally, \glc\ assumes that all merger trees will exist (i.e. have at least one node present) at the final output time. This may not be true of trees extracted from an N-body simulation---in this case \glc\ can be informed of this fact by setting:
\begin{verbatim}
  <allTreesExistAtFinalTime value="false"/>
\end{verbatim}

{\normalfont \bfseries Snapping Nodes to Snapshots:} N-body merger trees are often built from ``snapshots'' of the simulation, i.e. all of the nodes exist at a set of discrete times. Often we want to output nodes at precisely these output times. In such cases it is useful to set:
\begin{verbatim}
  <mergerTreeReadOutputTimeSnapTolerance value="1.0d-3"/>
\end{verbatim}
which ensures that the times of nodes are adjusted to lie at precisely the output time if that time is within the specified relative tolerance (this avoids any small differences between node times and output times that can arises due to rounding errors when converting from redshifts to times and vice-versa).

{\normalfont \bfseries Missing Hosts:} \glc\ expects to find each \gls{node}'s host \gls{node} present in a merger tree \gls{forest}. If a \gls{node}'s host is not found this is cause for a fatal error to be issued, since it is impossible to correctly construct and evolve the corresponding \gls{forest}. If you absolutely want to run a \gls{forest} for which one or more host \glspl{node} are missing, you can allow this by setting {\normalfont \ttfamily [mergerTreeReadMissingHostsAreFatal]}$=${\normalfont \ttfamily false}---in this case missing host \glspl{node} trigger a warning only and \glspl{node} without a host are forced to become isolated \glspl{node}. This will lead to incorrect tree evolution however, so the recommended setting is:
\begin{verbatim}
<mergerTreeReadMissingHostsAreFatal value="true"/>
\end{verbatim}

{\normalfont \bfseries Branch Jumps and Subhalo Promotions:} If your merger trees contain subhalos they will most likely exhibit two specific behaviors\footnote{These two behaviors are called out as they specifically \emph{do not} occur in merger trees created using Press-Schechter-based algorithms for example.}: i) \glspl{node} which are subhalos in one timestep may become non-subhalos (isolated halos) in a subsequent timestep (``subhalo promotion''), and ii) \glspl{node} which are subhalos in one branch of the tree may ``jump'' to another branch\footnote{That is, the subhalo's descendented is hosted by a \gls{node} other than the descendent of the subhalo's host.} of the tree becoming a subhalo there (``branch jumping''). These behaviors are fully supported by \glc\ and so we recommend the following settings:
\begin{verbatim}
<mergerTreeReadAllowSubhaloPromotions value="true"/>
<mergerTreeReadAllowBranchJumps       value="true"/>
\end{verbatim}
You may choose to disallow these behaviors by setting either of the above parameters to {\normalfont \ttfamily false}---for example if you wish to explore how your results would differ if subhalos were forced to remain subhalos forever in their original branch. Note that allowing subhalo promotion while not allowing branch jumping can lead to \glspl{deadlock} in merger tree evolution, so change these settings with caution.

Note that for trees which do not contain subhalos these two parameters are irrelevant.

{\normalfont \bfseries Subhalo Masses:} If your trees contain subhalos, the mass evolution of those subhalos can be preset in the satellite component of each \gls{node}. In this way, the subhalo mass in \glc\ will track that specified by the merger tree file. This requires the use of a satellite component which allows presetting of subhalo masses. Recommended settings are therefore:
\begin{verbatim}
<treeNodeMethodSatellite           value="preset"/>
<mergerTreeReadPresetSubhaloMasses value="true"  />
\end{verbatim}
If your trees do not contain subhalos, recommended settings are instead:
\begin{verbatim}
<treeNodeMethodSatellite           value="standard"/>
<mergerTreeReadPresetSubhaloMasses value="false"   />
\end{verbatim}

{\normalfont \bfseries Halo Positions/Velocities:} If your trees contain position and velocity information for halos, those positions and velocities can be preset in the position component of each \gls{node}. This requires the use of a position component which allows presetting of positions and velocities. Recommended settings are therefore:
\begin{verbatim}
<treeNodeMethodPosition        value="preset"/>
<mergerTreeReadPresetPositions value="true"  />
\end{verbatim}
If your trees do not contain position information recommended settings are:
\begin{verbatim}
<treeNodeMethodPosition        value="null" />
<mergerTreeReadPresetPositions value="false"/>
\end{verbatim}

{\normalfont \bfseries Subhalo Orbits:} If your trees contain position and velocity information they can be used to preset initial orbit information for subhalos. Note that it is not required that your trees contain subhalos for this orbit presetting to be performed---\glc\ can follow subhalo orbits even if subhalos are not included in the trees themselves. The following settings are recommended:
\begin{verbatim}
<mergerTreeReadPresetOrbits             value="true"/>
<mergerTreeReadPresetOrbitsSetAll       value="true"/>
<mergerTreeReadPresetOrbitsAssertAllSet value="true"/>
<mergerTreeReadPresetOrbitsBoundOnly    value="true"/>
\end{verbatim}
These options will cause an orbit to be preset for each subhalo based on the relative position and velocity of merging halos and assuming that the orbital energy and angular momentum are conserved between the time immediately prior to the merger and the time of virial radius crossing. If the computed orbit does not cross the virial radius of the larger halo or if the computed orbit is unbound, the above options cause an orbit to be preset by drawing orbital parameters at random from the chosen cosmological distribution (see \S\ref{sec:SatelliteVirialOrbits}).

{\normalfont \bfseries Subhalo Merging:} If your merger trees contain subhalo information, that information can be used to specify when, and with which other node, each subhalo merges. Specifically, a subhalo is assumed to merge at the time at which it is not the primary progenitor of its descendent halo---possibly with some other delay to be described below. Recommended settings are:
\begin{verbatim}
<mergerTreeReadPresetMergerTimes          value="true"             />
<mergerTreeReadPresetMergerNodes          value="true"             />
<mergerTreeReadSubresolutionMergingMethod value="boylanKolchin2008"/>
\end{verbatim}
The first two options cause subhalos to merge at the time described above, and with their descendent node. The final option accounts for the possibility that the subhalo should not actually merge immediately at this time. For example, in N-body simulations, the subhalo may have simply been lost due to limitations of resolution or halo finder algorithms. The final option specifies that some additional time until merging be added based on the subhalo merging timescale algorithm of \citeauthor{boylan-kolchin_dynamical_2008}~[\citeyear{boylan-kolchin_dynamical_2008}; see \S\ref{phys:satelliteMergingTimescales:satelliteMergingTimescalesBoylanKolchin2008}], and computed using the last known orbital properties of the subhalo.

{\normalfont \bfseries Halo Scale Radii:} If your merger trees contain information on halo scale radii or half-mass radii, these can be used to preset the scale radius of each \gls{node}. This requires the use of a dark matter profile component which allows presetting of scale length. Recommended settings are therefore:
\begin{verbatim}
<mergerTreeReadPresetScaleRadii                     value="true"     />
<mergerTreeReadPresetScaleRadiiFailureIsFatal       value="true"     />
<mergerTreeReadPresetScaleRadiiConcentrationMinimum value="3"        />
<mergerTreeReadPresetScaleRadiiConcentrationMaximum value="60"       />
<mergerTreeReadPresetScaleRadiiMinimumMass          value="see below"/>
\end{verbatim}
Minimum and maximum concentrations are specified---these are used to restrict the range of scale radii that are allowed for a given halo. If scale radii are to be determined based on half-mass radii given in the merger tree file, and if the computed scale radius does not result in a concentration between these limits, then a fatal error is issued.

Finally, you can set a minimum halo mass via the {\normalfont \ttfamily [mergerTreeReadPresetScaleRadiiMinimumMass]} parameter below which the scale radii or half-mass radii in your file should be considered not reliable. For halos below this mass, scale radii will instead be assigned via the selected dark matter halo concentration method (see \S\ref{sec:DarkMatterProfileConcentration}).

{\normalfont \bfseries Halo Angular Momenta:} If your merger trees contain spin or angular momentum information these can be preset for each node. Recommended settings are:
\begin{verbatim}
<treeNodeMethodSpin                  value="preset"/>
<mergerTreeReadPresetSpins           value="true"  />
<mergerTreeReadPresetUnphysicalSpins value="true"  />
\end{verbatim}
The last of these options causes any halos for which the spin given in the merger tree file is non-positive to be assigned a spin at random instead, drawn from the specified cosmological distribution (see \S\ref{sec:SpinParameterDistribution}).

If subhalo masses are not included in their host halo masses in your merger tree file, you should specify how the angular momenta of subhalos should be accounted for when adding their mass to their host halo. If positions and 3D angular momenta are available in your merger tree file, the recommended setting is:
\begin{verbatim}
<mergerTreeReadSubhaloAngularMomentaMethod value="summation"/>
\end{verbatim}
If this information is not present 
\begin{verbatim}
<mergerTreeReadSubhaloAngularMomentaMethod value="scale"    />
\end{verbatim}
should be used instead.

If your merger tree file contains 3D spin or angular momentum information, you can choose to make that information available within \glc\ be using the settings:
\begin{verbatim}
<treeNodeMethodSpin          value="preset3D"/>
<mergerTreeReadPresetSpins3D value="true"    />
\end{verbatim}

{\normalfont \bfseries Subhalo Indices:} If your merger trees contain subhalos, you can tell \glc\ to keep track of the indices of subhalos by setting:
\begin{verbatim}
<treeNodeMethodSatellite            value="preset"/>
<mergerTreeReadPresetSubhaloIndices value="true"  />
\end{verbatim}
The \glc\ output file will then contain {\normalfont \ttfamily satelliteNodeIndex} datasets which list the index (as given in the merger tree file) for all subhalos and halos. Without specifying this presetting, the index of subhalos is frozen at the index of the halo immediately prior to it becomming a subhalo.

The remainder of this section gives more detail about many of the parameters described above and how they affect handling of merger trees read from file. Further parameters can be set to control what information from the stored trees will be used in \glc. Examples are given below.

\subsection{Further Details}

Further details of the effects of the many parameters controlling merger trees read from file are given below.

\subsubsection{Node Positions}

If position and velocity information for tree nodes is available within the merger tree file then \glc\ can be instructed to use this information by using the ``preset'' method for tree node positions and telling the merger tree construction method to preset node positions as follows:
\begin{verbatim}
  <!-- Use merger tree node positions -->
  <treeNodeMethodPosition        value="preset"/>
  <mergerTreeReadPresetPositions value="true"  />
\end{verbatim}
If position information is unavailable, the ``null'' position method can be selected and the merger tree construction method instructed not to preset positions as follows:
\begin{verbatim}
  <!-- Do not use merger tree node positions -->
  <treeNodeMethodPosition        value="null" />
  <mergerTreeReadPresetPositions value="false"/>
\end{verbatim}

\subsubsection{Virial Orbits}\index{orbits!virial}\index{orbits!setting}\index{orbits!N-body}

If position and velocity information for tree nodes is available within the merger tree file then \glc\ can be instructed to use this information to estimate the orbit of each subhalo at the point at which it crosses the virial radius of its host halo. This ``virial orbit'' may then be used by, for example, calculations of merging timescales.
\begin{verbatim}
  <!-- Use merger tree node positions to compute orbits at the virial radius -->
  <mergerTreeReadPresetOrbits             value="true"/>
  <mergerTreeReadPresetOrbitsBoundOnly    value="true"/>
  <mergerTreeReadPresetOrbitsSetAll       value="true"/>
  <mergerTreeReadPresetOrbitsAssertAllSet value="true"/>
\end{verbatim}
Typically, a merging halo is not seen at precisely the time at which it crosses the virial radius of its host (due to the fact that N-body simulations are output at discretely spaced timesteps). Therefore, \glc\ computes the orbit at the time just prior to merging and assumes that the orbital parameters (energy and angular momentum) remain fixed to propagate the orbit to the virial radius of the host. The second parameter in the above example, {\normalfont \ttfamily [mergerTreeReadPresetOrbitsBoundOnly]}, specifies whether or not only bound orbits should be set. Some calculations (e.g. of subhalo merging times) assume bound orbits and may fail if given an unbound orbit. Setting this option to {\normalfont \ttfamily true} causes only bound orbits to be preset---unbound orbits are ignored. Note that some orbits cannot be propagated to the virial radius (i.e. their pericenter is larger than the virial radius). The {\normalfont \ttfamily [mergerTreeReadPresetOrbitsSetAll]} option, if true, will cause such orbits to be assigned randomly using the selected {\normalfont \ttfamily [virialOrbitsMethod]}, such that all orbits are assigned. The {\normalfont \ttfamily [mergerTreeReadPresetOrbitsAssertAllSet]} option requires that all orbits be set---if {\normalfont \ttfamily [mergerTreeReadPresetOrbitsSetAll]}$=${\normalfont \ttfamily false} and {\normalfont \ttfamily [mergerTreeReadPresetOrbitsAssertAllSet]}$=${\normalfont \ttfamily true} then \glc\ will exit with an error message if any orbit cannot be set.

If the satellite component additionally permits setting of the satellite position and velocity, these properties will also be assigned based on the relative position and velocity of the satellite and host halos.

\subsubsection{Merging Times and Targets}

The times at which subhalos merge with their host halo can be determined directly from the merger tree file if subhalo information is included in that file. Merging is assumed to occur when the subhalo no longer has a distinct descendent (i.e. it descends into a non-subhalo). If merging times are to be computed in this way set
\begin{verbatim}
  <treeNodeMethodSatellite         value="preset"/>
  <mergerTreeReadPresetMergerTimes value="true"  />
\end{verbatim}
which select a satellite orbit method that allows merger times to be present and tell the merger tree construction method to preset those merger times respectively. If merger times are not to be computed in this way then instead set, for example,
\begin{verbatim}
  <treeNodeMethodSatellite         value="standard" />
  <mergerTreeReadPresetMergerNodes value="false"    />
  <satelliteMergingMethod          value="Jiang2008"/>
\end{verbatim}
which selects a standard satellite orbit method, prevents attempts to preset the merger times and selects the {\normalfont \ttfamily Jiang2008} method for computing merger times instead.

In addition to setting the times of merger events, it is possible to set the target node with which a merging node should merge. By default, \glc\ will assume that all merging occurs with the non-subhalo host node in which a subhalo is located. This may not be the desired behavior when using N-body merger trees. For example, such trees may indicate that a subhalo merges with another subhalo. Setting
\begin{verbatim}
  <mergerTreeReadPresetMergerNodes value="true"/>
\end{verbatim}
will cause the target node with which each merger should occur to be determined from the merger tree structure and preset for use in \glc.

It is possible to add a delay between the last time at which a subhalo was seen in a simulation and the time at which it is considered to merge. This functionality is motivated by the consideration that a subhalo vanishing from a simulation may be simply due to it dropping below resolution rather than it actually having undergone a merger. The parameter {\normalfont \ttfamily [mergerTreeReadSubresolutionMergingMethod]} can be used to select a satellite merging timescale method (see \S\ref{sec:SatelliteMergingTimescales}) to use in this case. (It is set by default to ``{\normalfont \ttfamily null}'' such that no delay before merging occurs.) The orbit of the subhalo around its parent at the last time it is present in the merger tree is passed to this method and used to estimate a time until merging. This delay is added to the time at which the subhalo merges and, if merge target nodes are being set, the target node is updated accordingly.

\subsubsection{Subhalo Indices}

The indices of subhalos are usually frozen at the index of the halo just prior to becoming a subhalo. The index of the corresponding halo in the original tree (as read from file) can be tracked as follows:
\begin{verbatim}
  <treeNodeMethodSatellite            value="preset"/>
  <mergerTreeReadPresetSubhaloIndices value="true"  />
\end{verbatim}
to first select the ``preset'' satellite orbit method (which allows subhalo indices to be preset) and, second, to instruct the merger tree construction algorithm to preset those indices. The index will then be available in output as {\normalfont \ttfamily satelliteNodeIndex}.

\subsubsection{Subhalo Masses}

The masses of subhalos (specifically their time evolution after they become subhalos) can be set using the values stored in the merger tree file (if available). To set subhalo masses in this way use
\begin{verbatim}
  <treeNodeMethodSatellite           value="preset"/>
  <mergerTreeReadPresetSubhaloMasses value="true"  />
\end{verbatim}
to first select the ``preset'' satellite orbit method (which allows subhalo masses to be preset) and, second, to instruct the merger tree construction algorithm to preset those masses.

\subsubsection{Node Spins}

If information on the angular momenta of nodes is available in the merger tree file, this can be used to preset the value of the spin parameter in each node\footnote{Before doing this, it is important to be sure that the angular momenta of the nodes are reliable. For example, in low mass nodes extracted from an N-body simulation resolution effect may limit the accuracy of the measured angular momentum.} by setting:

\begin{verbatim}
  <mergerTreeReadPresetSpins value="true"/>
\end{verbatim}

The spin parameter is set using the spin of each node if available, or otherwise using the angular momentum of each node stored in the merger tree file using:
\begin{equation}
 \lambda = {|\mathbf{J}| |E|^{1/2} \over \mathrm{G} M^{5/2}}
\end{equation}
where $|\mathbf{J}|$ is the magnitude of the node's angular momentum, $M$ is the node's mass and $E$ is its energy. Additionally, by setting:

\begin{verbatim}
  <mergerTreeReadPresetSpins3D value="true"/>
\end{verbatim}
the spin vector of each node will be set (assuming that the vector spin or angular momenta of nodes are available in the merger tree file) using:
\begin{equation}
 \mathbf{\lambda} = {\mathbf{J} |E|^{1/2} \over \mathrm{G} M^{5/2}}.
\end{equation}

If spins could not be determined for some halos the spin (or angular momentum) should be set to zero in the merger tree file, and the parameter {\normalfont \ttfamily [mergerTreeReadPresetUnphysicalSpins]} set to {\normalfont \ttfamily true}. \glc\ will then assign a spin to such halos by sampling from the selected spin distribution (see \S\ref{sec:SpinParameterDistribution}). 

\subsubsection{Node Scale Radii}

If information on the half-mass or scale radii of nodes is available in the merger tree file, it can be used to preset the value of the dark matter halo scale radius in each node by setting:

\begin{verbatim}
  <mergerTreeReadPresetScaleRadii value="true"/>
\end{verbatim}

Before doing this, it is important to be sure that the half-mass or scale radii of the nodes are reliable. For example, in low mass nodes extracted from an N-body simulation resolution effect may limit the accuracy of the measured half-mass or scale radius. In such cases, use the {\normalfont \ttfamily [mergerTreeReadPresetScaleRadiiMinimumMass]} parameter to specify the lowest mass halos for which the scale radii should be preset---lower mass halos will be assigned a scale radius using the method specified by the {\normalfont \ttfamily [mergerTreeReadConcentrationFallbackMethod]} parameter (which will default to the value of {\normalfont \ttfamily [darkMatterConcentrationMethod]}; see \S\ref{sec:DarkMatterProfileConcentration}). It is also possible to specify minimum and maximum allowed concentrations when computing the scale radius from the half mass radius using the {\normalfont \ttfamily [mergerTreeReadPresetScaleRadiiConcentrationMinimum]} and {\normalfont \ttfamily [mergerTreeReadPresetScaleRadiiConcentrationMaximum]} parameters. If matching the half mass radius would require a concentration outside of this range, \glc\ will abort unless {\normalfont \ttfamily [mergerTreeReadPresetScaleRadiiFailureIsFatal]}$=${\normalfont \ttfamily false}, in which case it will instead silently use the fallback concentration method described above.

If only half-mass radii are available, the scale radius is set by using a root finding algorithm to ensure that half of the total halo mass is enclosed within the specified half-mass radius.

\subsubsection{Miscellaneous N-body Properties}

Several miscellaneous properties often available from N-body merger trees can also be preset by setting the following parameters to {\normalfont \ttfamily true}:
\begin{description}
\item[{mergerTreeReadPresetParticleCounts}] Sets the number of particles in each halo (requires the {\normalfont \ttfamily particleCount} dataset to be present in the merger tree file);
\item[{mergerTreeReadPresetVelocityMaxima}] Sets the maxima of halo rotation curves (requires the {\normalfont \ttfamily velocityMaximum} dataset to be present in the merger tree file);
\item[{mergerTreeReadPresetVelocityDispersions}] Sets the velocity dispersion of halos (requires the {\normalfont \ttfamily velocityDispersion} dataset to be present in the merger tree file).
\end{description}

\subsubsection{Subhalo Promotion}\label{sec:Tutorial:NbodyTrees:SubhaloPromotion}

A subhalo may, at a later time, become an isolated halo once again. \glc\ allows you to control whether such behavior is allowed, or should be prohibited. To allow such ``subhalo promotion'', set:
\begin{verbatim}
<mergerTreeReadAllowSubhaloPromotions value="true"/>
\end{verbatim}
If you choose to inhibit this behavior by setting the above parameter to false, a halo that becomes a subhalo will remain a subhalo forever thereafter. Note that the isolated halo to which it would have been promoted will still exist, and may therefore form its own galaxy. This can result in double counting of mass, and so inhibiting subhalo promotion is not recommended.

\subsubsection{``Fly-by'' Halos}\label{sec:Tutorial:NbodyTrees:BranchJump}

In some cases, a halo that is part of one tree can later become part of another tree. This can happen in so-called ``fly-by'' encounters where a halo may briefly become a subhalo in a halo in tree A then leave that halo and become a subhalo in tree B.

The correct way to handle this issue is to combine trees A and B into a single tree (which will now have multiple base nodes). \glc\ will then process these two trees simultaneously, correctly handling the fly-by, and outputting the trees as two separate trees.

If for some reason this is not possible or desired, the fly-by problem will normally cause \glc\ to complain that the host halo of a node cannot be found (since it exists in a different tree). This problem can be avoided by setting:
\begin{verbatim}
  <mergerTreeReadMissingHostsAreFatal value="false"/>
\end{verbatim}
In this case, nodes with missing hosts are simply treated as being isolated halos. This will avoid an error condition, but is not a physically correct way to handle such cases, so use with caution.

\subsection{Using Particles to Track Unresolved Subhalos}

In N-body simulations it is possible that a subhalo can become ``lost'' from the simulation (i.e. can no longer be identified by a halo finder due to resolution issues) before it has actually merged with the central galaxy or been completely tidally destroyed. In such cases it is useful to be able to assign a position to the subhalo at later times. A common approach to assigning a position (and velocity) is to use that of the most bound particle in the subhalo at the last time it was identified. \glc\ allows for particle tracking in this way through the addition of particle information to the merger tree file.

To add particle tracking data to a merger tree file, follow these steps:
\begin{enumerate}
\item Identify all subhalos which are lost from the simulation prior to the final timestep;
\item Determine the index of the most bound particle in each such subhalo in the last timestep in which it was identified;
\item For each subhalo, extract the redshift, position, and velocity of that particle (which is usally trivial to do once its index is known) at each subsequent timestep in the simulation;
\item Write these data (along with the particle index) to the {\normalfont \ttfamily particles} group in the merger tree file as described in \S\ref{sec:MergerTreeFormatDescription:Particles};
\item Add two datasets to the {\normalfont \ttfamily forestHalos} group:
  \begin{enumerate}
  \item {\normalfont \ttfamily particleIndexStart} which should indicate the index in the datasets in the {\normalfont \ttfamily particles} group at which the data for each halo begins (or $-1$ if no particle data is included for the halo);
  \item {\normalfont \ttfamily particleIndexCount} which should indicate the number of entries in the datasets in the {\normalfont \ttfamily particles} group for each halo (or $-0$ if no particle data is included for the halo).
  \end{enumerate}
\end{enumerate}

\subsection{Handling of Extremely Large Merger Tree Forests}\index{merger trees!large}\index{forests!large}

Halos can move between merger trees (see \S\ref{sec:Tutorial:NbodyTrees:SubhaloPromotion} and \S\ref{sec:Tutorial:NbodyTrees:BranchJump}), leading to the necessity of merger tree forests---interconnected groups of merger trees that \glc\ typically processes as a whole. These forests can become very large---in some cases so large that they do not fit within the available memory. \glc\ can handle such forests by splitting them into individual trees. Each tree is processed separately, and nodes are moved between trees as needed. If a tree needs a node from another tree before its evolution can continue, its state can be suspended to disk, and later re-read once the node it requires becomes available. In this way, very large forests can be processed without running out of memory (as trees are stored to disk while they are not being processed).

To cause forests to be split in this way, the following parameters should be set:
\begin{verbatim}
  <treeEvolveSuspendToRAM                   value="false"            />
  <treeEvolveSuspendPath                    value="/my/scratch/path/"/>
  <mergerTreeReadForestSizeMaximum          value="10000000"         />
  <mergerTreeReadSubresolutionMergingMethod value="infinite"         />
\end{verbatim}

Here, {\normalfont \ttfamily treeEvolveSuspendToRAM} specifies that merger trees should be suspended to disk (i.e. not to RAM which is the default), and {\normalfont \ttfamily treeEvolveSuspendPath} gives a path where the suspended trees can be written---typically scratch space local to the compute node where \glc\ is being run is a good option.
 
{\normalfont \ttfamily mergerTreeReadForestSizeMaximum} specifies the maximum number of nodes allowed in a forest before it will be split. A suitable number for this depends on the details of the available RAM, the number of threads sharing that RAM, and the characteristics of the \glc\ model being used (which will affect the memory required per node).
 
Finally, {\normalfont \ttfamily mergerTreeReadSubresolutionMergingMethod} is set to {\normalfont \ttfamily infinite} to prevent any merging (which is not supported for split forests at present, although it should be soon).

\subsection{Analyzing the Output}

\subsubsection{Positions and Velocities}

Components of the position of each node are output as {\normalfont \ttfamily positionX}, {\normalfont \ttfamily positionY} and {\normalfont \ttfamily positionZ} and can be accessed in the same way as other output properties from \glc\ (see \S\ref{sec:nodeDataGroup} and \S\ref{sec:perlModuleDataExtraction}).

\subsubsection{Subhalo Masses}

The current mass of subhalos is available via the {\normalfont \ttfamily nodeBoundMass} output dataset and can be accessed in the same way as other output properties from \glc\ (see \S\ref{sec:nodeDataGroup} and \S\ref{sec:perlModuleDataExtraction}). For non-subhalos this property is equal to the usual {\normalfont \ttfamily nodeMass} property.

\section{Generating Mock Catalogs with Lightcones from the Millennium Simulation}\index{lightcone}\index{Millennium Simulation}\index{mock catalog}

Suppose that you want to create a catalog of galaxies as would be found in a survey of an area of the sky out to some redshift. Such a ``mock catalog'' can be built by populating with galaxies all of the dark matter halos which happen to lie within the cone which that area makes as it is projected from the observer through the Universe.

Generating such a mock catalog using \glc\ involves first extracting the halos (and their merger trees) within this ``lightcone'' from a suitable N-body simulation, and then processing them through \glc. In this tutorial, we will specifically make use of the \href{http://gavo.mpa-garching.mpg.de/MyMillennium3/MyDB}{Millennium Simulation database} to provide the merger trees, but the same principles apply to any N-body simulation.

The script, {\normalfont \ttfamily scripts/aux/Millennium\_Lightcone\_Grab.pl} can be used to retrieve merger trees that intersect a given lightcone from the Millennium Database and to store them in \glc's format (see \S\ref{sec:MergerTreeFileFormat}). The script is used as follows:
\begin{verbatim}
scripts/aux/Millennium_Lightcone_Grab.pl <lightconeDirectory> <fieldSize> <maximumRedshift>
    --user <myUserName> --password <myPassword> --treesPerFile <treesPerFile>
\end{verbatim}
Here, {\normalfont \ttfamily \textless lightconeDirectory\textgreater} is the name of a (pre-existing) directory into which merger tree data will be stored, {\normalfont \ttfamily \textless fieldSize\textgreater} is the length (in degrees) of one side of the square field of view of the lightcone, {\normalfont \ttfamily \textless maximumRedshift\textgreater} is the highist redshift for which halos should be included in the catalog. The {\normalfont \ttfamily --user} and {\normalfont \ttfamily --password} options allow you to specify your username and password for accessing the Millennium Simulation database. Finally, the {\normalfont \ttfamily --treesPerFile} specifies how many merger trees should be stored in each file (the script will split the lightcone between many files---this is primarily so that each request sent to the Millennium Database server is not too large). If no value is specified a default of 200 trees per file will be used.

The script generates multiple SQL queries to the Millennium database in order to first find all halos which intersect the lightcone and second to retrieve the complete merger tree associated with each such halo. These merger trees are then stored in \glc's merger tree file format in files named {\normalfont \ttfamily Lightcone\_Trees\_AAA:BBB.hdf5} in the given {\normalfont \ttfamily \textless lightconeDirectory\textgreater}, where {\normalfont \ttfamily AAA} and {\normalfont \ttfamily BBB} are numbers giving the first and last trees in the file\footnote{Note that these are not the ID numbers of the trees, just a sequential count of all trees retrieved.}

Each of the merger tree files created can then be run through \glc\ in the usual way (see \S\ref{sec:nBodyRun}).  Outputs should be requested at every Millennium snapshot (up to the largest redshift to be considered), and the {\normalfont \ttfamily lightcone} filter should be used to cause only those galaxies which intersect the lightcone to be output---for example:
\begin{verbatim}
<!-- Set output redshifts to the snapshots in the milliMillennium. -->
<outputRedshifts value=
   "0.0000 0.0199 0.0414 0.0645 0.0893 0.1159 0.1444 0.1749 0.2075 0.2425
    0.2798 0.3197 0.3623 0.4079 0.4566 0.5086 0.5642 0.6236 0.6871 0.7550
    0.8277 0.9055 0.9887 1.0779 1.1734 1.2758 1.3857 1.5036 1.6303 1.7663
    1.9126 2.0700 2.2395 2.4220 2.6189 2.8312 3.0604 3.3081 3.5759 3.8657
    4.1795 4.5196 4.8884 5.2888 5.7239 6.1968"
/>

<!-- Add a lightcone filter with the required geometry -->
<mergerTreeOutput>
  <galacticFilterMethod value="lightcone"/>
</mergerTreeOutput>

<!-- Switch on output of lightcone data -->
<outputLightconeData value="true"/>

<!-- Prune away trees not appearing in the lightcone -->
<mergerTreeOperatorMethod value="pruneLightcone"/>

<!-- Specify lightcone geometry -->
<geometryLightconeMethod value="square">
  <origin value="0 0 0"/>
  <unitVector1 value=" 1 1  1"/>
  <unitVector2 value=" 0 1 -1"/>
  <unitVector3 value="-2 1  1"/>
  <lengthReplication value="500"/>
  <lengthHubbleExponent value="-1"/>
  <lengthUnitsInSI value="3.08567758135e22"/>
  <angularSize value="0.5"/>
  <timeEvolvesAlongLightcone value="true"/>
  <redshift value=
   "0.0000 0.0199 0.0414 0.0645 0.0893 0.1159 0.1444 0.1749 0.2075 0.2425
    0.2798 0.3197 0.3623 0.4079 0.4566 0.5086 0.5642 0.6236 0.6871 0.7550
    0.8277 0.9055 0.9887 1.0779 1.1734 1.2758 1.3857 1.5036 1.6303 1.7663
    1.9126 2.0700 2.2395 2.4220 2.6189 2.8312 3.0604 3.3081 3.5759 3.8657
    4.1795 4.5196 4.8884 5.2888 5.7239 6.1968"
  />
</geometryLightconeMethod>
\end{verbatim}
In the above {\normalfont \ttfamily [outputLightconeData]} causes lightcone coordinate information (i.e. the position and velocity of each galaxy in a coordinate system with axes aligned along the line of sight of the lightcone and parallel to the two edges of the square field of view, along with the redshift) to be output (see \S\ref{sec:OutputLightcone}), and {\normalfont \ttfamily [mergerTreeOperatorMethod]} is set to {\normalfont \ttfamily pruneLightcone} to cause any merger trees which have no nodes within the lightcone volume to be pruned away (as there is no need to process them). Finally, the {\normalfont \ttfamily geometryLightconeMethod} parameter describes the geometry of the lightcone to be used---see \S\ref{sec:methodsGeometryLightcone} for details.

\section{Using the Instantaneous Recycling Approximation}\index{recycling!instantaneous}\index{instantaneous recycling approximation}

Choosing {\normalfont \ttfamily [stellarPopulationPropertiesMethod]}$=${\normalfont \ttfamily instantaneous} will cause \glc\ to use the instantaneous recycling approximation for all calculations of stellar populations. The recyling rate and yield to use are set by the {\normalfont \ttfamily [imfNAMERecycledInstantaneous]} and {\normalfont \ttfamily [imfNAMEYieldInstantaneous]} parameters respectively, where {\normalfont \ttfamily NAME} is the name of the appropriate \gls{imf}.

Setting {\normalfont \ttfamily [stellarPopulationPropertiesMethod]}$=${\normalfont \ttfamily noninstantaneous} causes \glc\ to use a fully non-instantaneous, metal-depdendent calculation of recycling, metal production and \gls{sne} rates. However, it is possible to force this method to operate in the instantaneous recycling approximation limit (which can be useful for testing and comparison) by setting:
\begin{verbatim}
  <!-- Force the calculation of recycling, yields etc. to   -->
  <!-- be done assuming instantaneous recycling             -->
  <starFormationImfInstantaneousApproximation value="true"/>
  <!-- Set the mass of stars which should be used as the    -->
  <!-- dividing line between long-lived and instantaneously -->
  <!-- evolving in this approximation.                      -->
  <starFormationImfInstantaneousApproximationMassLongLived value="1.0"/>
  <!-- Set the effective age of populations to use in this -->
  <!-- approximation when computing SNe numbers.           -->
  <starFormationImfInstantaneousApproximationEffectiveAge value="13.8"/>
\end{verbatim}

\section{Computing Dust Attenuated Luminosities for All Galaxies}\label{sec:TutorialDustAttenuation}\index{dust!attenuation}

As described in \S\ref{sec:DerivedProperties}, dust-attenuated luminosities can be computed for galaxies using the calculations of \cite{ferrara_atlas_1999} (among other methods). A script is provided which will automatically perform this calculation for all filters, in all galaxies, at all output redshifts in a \glc\ output file and store the results (along with the assumed galaxy inclinations) back to the \gls{hdf5} file. The script is used as follows:
\begin{verbatim}
./scripts/analysis/dustExtinguish.pl <galacticusFileName>
\end{verbatim}

\section{Computing Dust Attenuation and Emission Using Galacticus+Grasil}\label{sec:TutorialGrasil}\index{dust!emission}\index{dust!attenutation}\index{Grasil@{\normalfont \scshape Grasil}}

\glc\ can interface with the \href{http://adlibitum.oat.ts.astro.it/silva/grasil/grasil.html}{\normalfont \scshape Grasil} code to compute the attenutation of starlight by dust, along with the re-emission of absorbed energy by that dust. To do this, it is necessary to store the entire star formation history of galaxies in a \glc\ model, as {\normalfont \scshape Grasil} uses this information to determine the attenuation of stellar populations as a function of their age.

Recording star formation histories is as simple as setting the {\normalfont \ttfamily [starFormationHistoriesMethod]} parameter to {\normalfont \ttfamily metallicitySplit}. This particular star formation history method stores the star formation in each galaxy as a function of time and metallicity, as required by {\normalfont \scshape Grasil}. The level of detail with which the star formation history is stored is controlled by several parameters:
\begin{description}
\item [{\normalfont \ttfamily starFormationHistoryTimeStep}] The timestep used in discretizing star formation histories.
\item [{\normalfont \ttfamily starFormationHistoryFineTimeStep}] The timestep to use in discretizing star formation histories just prior to output times. This should typically be smaller than {\normalfont \ttfamily [starFormationHistoryTimeStep]} to give improved resolution in the star formation history for recently formed stars.
\item [{\normalfont \ttfamily starFormationHistoryFineTime}] The period before each output for which the {\normalfont \ttfamily [starFormationHistoryFineTimeStep]} should be used.
\item [{\normalfont \ttfamily starFormationHistoryMetallicityCount}] The number of bins in metallicity to use when discretizing the star formation history.
\item [{\normalfont \ttfamily starFormationHistoryMetallicityMinimum}] The upper limit to the metallicity in the lowest metallicity bin (i.e. the lowest metallicity bin will extend from zero to this value).
\item [{\normalfont \ttfamily starFormationHistoryMetallicityMaximum}] The upper limit to the metallicity in the highest metallicity bin.
\end{description}
Default values set a timestep of 0.1~Gyr, with 0.01~Gyr timesteps for 0.1~Gyr before each output, along with 10 metallicity bins ranging from $10^{-4}Z_\odot$ to $10Z_\odot$. It is always recommended to check that these values result in a sufficiently well-resolved star formation history for your purposes.

When run with these parameter settings \glc\ will output an additional group to the output file called {\normalfont \ttfamily starFormationHistories}. This contains a hierarchically arranged set of datasets describing the star formation histories. The hierarchy extends through output number, and merger tree index. For example {\normalfont \ttfamily starFormationHistories/Output5/mergerTree3/} will contain the star formation history for merger tree 3 at output 5. This group will, in general, contain many datasets, e.g.
\begin{verbatim}
diskSFH7819       Dataset {11, 34}
diskTime7819      Dataset {34}
spheroidSFH7819   Dataset {11, 34}
spheroidTime7819  Dataset {34}
\end{verbatim}
In this case, datasets are present for both a disk and bulge component of node 7819. (If a node does not contain one of these components, the corresponding dataset will be missing.) The ``{\normalfont \ttfamily Time}'' datasets give the times at which the star formation history is stored, while the ``{\normalfont \ttfamily SFH}'' datasets give the mass of stars formed in each time/metallicity bin. (The metallicities themselves are available in the {\normalfont \ttfamily starFormationHistories/metallicities} dataset.)

Properties of the {\normalfont \scshape Grasil} \gls{sed} can now be accessed using the {\normalfont \ttfamily Galacticus::Grasil} module (see \S\ref{sec:Grasil}). When such properties are requested, {\normalfont \scshape Grasil} will be automatically run on each selected galaxy, the \gls{sed} computed and stored to the \glc\ file\footnote{{\normalfont \scshape Grasil} \glspl{sed} are stored in the {\normalfont \ttfamily grasilSEDs} group in a hierarchy of output, merger tree, and node groups, as for the star formation histories. Within each node group three datasets are stored, giving the {\normalfont \ttfamily wavelength}, {\normalfont \ttfamily inclination}, and {\normalfont \ttfamily SED} of the galaxy.}, and the relevant fluxes computed. If necessary, {\normalfont \scshape Grasil} and its data files will be downloaded automatically. Multiple {\normalfont \scshape Grasil} models will be run simultaneously if multiple cores are available.

For example:
\begin{verbatim}
# Specify model.                                                                                                                 
my $galacticus;
$galacticus->{'file' } = "/galacticus.hdf5";
$galacticus->{'store'} = 0;
$galacticus->{'tree' } = "all";

# Specify Grasil options.                                                                                                        
$galacticus->{'grasilOptions'}->{'includePAHs'            } = 1;
$galacticus->{'grasilOptions'}->{'fluctuatingTemperatures'} = 1;
$galacticus->{'grasilOptions'}->{'wavelengthCount'        } = 1000;
$galacticus->{'grasilOptions'}->{'radialGridCount'        } = 30;
$galacticus->{'grasilOptions'}->{'recomputeSEDs'          } = 0;
$galacticus->{'grasilOptions'}->{'launchMethod'           } = "pbs";

# Read results from model.                                                                                                       
&HDF5::Select_Output($galacticus,2.0);
&HDF5::Get_Dataset  ($galacticus,
                           [
                            'grasilFlux850microns',
                            'grasilFlux250microns',
                            'grasilFlux350microns',
                            'grasilFlux500microns',
                            'grasilInfraredLuminosity'
                           ]
\end{verbatim}
The {\normalfont \ttfamily grasilOptions} block in the above controls the behavior of {\normalfont \scshape Grasil}. Here we've chosen to include calculations of \gls{pah} features, have accounted for fluctuating tempertures in small grains (both of which slow down the calculation but make it more accurate), have specified the number of wavelengths and the size of the radial grid used to model each galaxy. We have also specified that the \gls{sed} should not be recomputed---if {\normalfont \scshape Grasil} fluxes are requested in future for galaxies in this model, they will be computed from the stored {\normalfont \scshape Grasil} \gls{sed}. If you want to change the parameters of the {\normalfont \scshape Grasil} calculation then set the {\normalfont \ttfamily recomputeSED} option to 1 instead\footnote{Exercise caution when using this option. Recomputing SEDs requires deleting the old SED group. The HDF5 library currently does not clean up the space occupied by the datasets in this deleted group, so the file size can grow rapidly if you repeatedly recompute {\normalfont \scshape Grasil} SEDs.}.

Finally, the {\normalfont launchMethod} option specifies how {\normalfont \scshape Grasil} is to be run. Currently supported options are {\normalfont \ttfamily local} and {\normalfont \ttfamily pbs}. Selecting {\normalfont \ttfamily local} causes {\normalfont \scshape Grasil} to be run on the local machine. Multiple threads are launched automatically, up to one per available CPU core unless otherwise specified. Selecting {\normalfont \ttfamily pbs} causes {\normalfont \scshape Grasil} jobs to be submitted to  a PBS queue.

Fluxes are returned in units of Janskys, while the total infrared luminosity ({\normalfont \ttfamily grasilInfraredLuminosity}) is returned in units of Solar luminosities.

A simple plotting script is provided which illustrates how to access and use the {\normalfont \scshape Grasil} \glspl{sed} stored in \glc\ files. For example:
\begin{verbatim}
scripts/plotting/plotGrasilSpectrum.pl galacticus.hdf5 5 9 217 43.2 SED.pdf
\end{verbatim}
will plot the \gls{sed} of node 217, in merger tree 9, at output 5 from the {\normalfont \ttfamily galacticus.hdf5} file. The \gls{sed} will be shown for an inclination of $43.2^\circ$ and the plot will be written to {\normalfont \ttfamily SED.pdf}.

\section{Outputting Stellar Luminosities}\index{luminosities!stellar}\index{stellar!luminosities}\index{luminosities!galactic}\index{galaxy!luminosities}

\glc\ can compute the stellar luminosity of galaxies in any required combination of filter, redshift, and frame. To cause luminosities to be computed add something such as the following to your input parameter file:
\begin{verbatim}
 <luminosityFilter   value="SDSS_r"  />
 <luminosityRedshift value="0.1"     />
 <luminosityType     value="observed"/>
\end{verbatim}
This would result in a dataset called {\normalfont \ttfamily diskLuminositiesStellar:SDSS\_r:observed:z0.1000} being output (along with a similar dataset for the spheroid component), corresponding to the luminosity in the SDSS r-band filter, as observed at $z=0.1$. To get the same filter but in the rest-frame of the galaxy, change the {\normalfont \ttfamily luminosityType} to ``{\normalfont \ttfamily rest}''. If instead of specifying a unique redshift you instead specify ``{\normalfont \ttfamily all}'' for a filter in the {\normalfont \ttfamily luminosityRedshift} element, then the filter will be replicated to all output redshifts.

Available filters can be found in the {\normalfont \ttfamily data/filters} folder. Additionally, it is possible to specify top-hat filters (which have unit transmission over a range of wavelengths) without the need to create a filter file for them. A filter named {\normalfont \ttfamily topHat\_L\_R} will be interpretted as a top-hat filter where {\normalfont \ttfamily L}$=\lambda$ is the central wavelength (in \AA ngstroms) and {\normalfont \ttfamily R}$=R$ is the resolution. A top-hat filter is constructed such that the transmission is unity between $\lambda_1$ and $\lambda_2$, and zero outside that range, and such that $\lambda_1\lambda_2=\lambda^2$, $\lambda_2-\lambda_1=\lambda/R$. Furthermore, a filter specified as {\normalfont \ttfamily topHat\_Llow\_Lhigh\_R} will be expanded into a set of contiguous top-hat filters with resolution {\normalfont \ttfamily R} spanning the wavelength range {\normalfont \ttfamily Llow} to {\normalfont \ttfamily Lhigh} with the first filter's lower wavelenght limit aligned with {\normalfont \ttfamily Llow} and continuing until the central wavelength of the filter is no longer below {\normalfont \ttfamily Lhigh}.

Luminosities are always output in units of the zero-point of the AB magnitude system, such that $-2.5\log_{10}L$ (where $L$ is the output luminosity) gives the AB absolute magnitude of the galaxy.

You can add additional luminosities by simply adding more entries in these parameter values. For example:
\begin{verbatim}
 <luminosityFilter   value="SDSS_r   SDSS_g"/>
 <luminosityRedshift value="0.1      0.3"   />
 <luminosityType     value="observed rest"  />
\end{verbatim}
would result in datasets {\normalfont \ttfamily diskLuminositiesStellar:SDSS\_r:observed:z0.1000} and {\normalfont \ttfamily diskLuminositiesStellar:SDSS\_g:rest:z0.3000}. 

\subsection{Postprocessing of Stellar Spectra}

Stellar luminosities are computed by convolving a library of simple stellar populations with the star formation history of each galaxy. \glc\ allows the spectra of those simple stellar populations to be postprocessed (after being read from file or internally generated for example) before they are utilized in the convolution integral. This postprocessing can modify the spectra in arbitrary ways that depend on wavelength, redshift, and age of stellar population. Furthermore, \glc\ allows you to chain together stellar spectra postprocessors into a set to allow multiple postprocessings to be applied. Furthermore again, you can define an arbitrary number of sets and apply different sets to different luminosities.

Typical uses of stellar spectra postprocessors include accounting for absorption of galaxy light by the intervening \gls{igm}, or capturing only the light from recent star formation\footnote{Perhaps so that additional dust extinction can be applied to the light of recently formed stars.}. A full list of the available postprocessors can be found in \S\ref{sec:StellarSpectraPostprocessing}.

If you don't specify a postprocessing set, the ``default'' set (consisting of the {\normalfont \ttfamily inoue2014} postprocessor; see \S\ref{phys:spectraPostprocessor:spectraPostprocessorInoue2014}) is applied to each luminosity calculation. To specify other postprocessing sets add the following to your parameter file:
\begin{verbatim}
 <luminosityPostprocessSet value="default recent unabsorbed recentUnabsorbed"/>
\end{verbatim}
where one set must be specified for each luminosity specified in the {\normalfont \ttfamily luminosityFilter} parameter. Note that set names can be reused in order to apply the same postprocessor set to multiple luminosities.

The chain of postprocessors to apply for each set is then specified as follows:
\begin{verbatim}
 <stellarPopulationSpectraPostprocessRecentMethods           value="inoue2014 recent"/>
 <stellarPopulationSpectraPostprocessUnabsorbedMethods       value="identity"        />
 <stellarPopulationSpectraPostprocessRecentUnabsorbedMethods value="recent"          />
\end{verbatim}
In this case we've constructed three new sets, in addition to the default set (which applies just the {\normalfont \ttfamily inoue2014} postprocessor). The {\normalfont \ttfamily recent} set applies both the {\normalfont \ttfamily inoue2014} \gls{igm} absorption postprocessor, followed by the {\normalfont \ttfamily recent} postprocessor to retain only recently emitted light. The {\normalfont \ttfamily unabsorbed} set ignores \gls{igm} absorption entirely---it does this by using the {\normalfont \ttfamily identity} postprocessor which leaves the spectrum unaffected. Finally, the {\normalfont \ttfamily recentUnabsorbed} set applies only the {\normalfont \ttfamily recent} filter while ignoring \gls{igm} absorption.

In this way it is relatively easy to extract multiple different measures of luminosity from a \glc\ model. For example, you could construct four postprocessor sets, each corresponding to one of the four different \gls{igm} absorption models ({\normalfont \ttfamily lycSuppress}, {\normalfont \ttfamily madau1995}, {\normalfont \ttfamily meiksin2006}, and {\normalfont \ttfamily inoue2014}) and apply these to the same luminosity filter to assess how luminosity depends on the \gls{igm} model used.

\subsection{Migrating Parameter Files to a New Version}\label{sec:MigrateParameters}\index{migration}\index{parameters}

The names and allowed values of parameters often change between versions of \glc. To permit easy and error-free migration between versions a script is provided to translate parameter files from earlier to later versions. To migrate a parameter file simply use:
\begin{verbatim}
scripts/aux/parametersMigrate.pl parameters.xml newParameters.xml
\end{verbatim}
By default, this script will translate from the previous to the current version of \glc. If your parameter file contains a {\normalfont \ttfamily version} element then this will be used to determine which version of \glc\ the parameter file was constructed for. The migration script will then migrate the parameter file through all intermediate versions to bring it into compliance with the current version. You can also specify input and output versions directly:
\begin{verbatim}
scripts/aux/parametersMigrate.pl parameters.xml newParameters.xml --inputVersion 0.9.0 --outputVersion 0.9.3
\end{verbatim}
will convert {\normalfont \ttfamily parameters.xml} from version 0.9.0 syntax to version 0.9.3 syntax.

\subsection{Computing Emission Lines}\label{sec:EmissionLineTutorial}\index{emission lines}\index{lines!emission}

\glc\ can compute emission line luminosities for galaxies. This calculation is based on the methodology of \cite{panuzzo_dust_2003}. Briefly, HII region models are constructed using {\normalfont \scshape Cloudy} for a variety of gas densities and metallicities, and HI, HeI, and OII ionizing luminosities. Emission line luminosities are then computed by interpolating in these tables based on the instantaneous properties of model galaxies.

To compute emission line luminosities it is therefore necessary to run \glc\ including the following rest-frame luminosity filters at each redshift of interest: {\normalfont \ttfamily Lyc}, {\normalfont \ttfamily HeliumContinuum}, {\normalfont \ttfamily OxygenContinuum}. This causes the ionizing luminosity for each three species to be computed and output. Emission line luminosities can then be found using \glc's data extraction modules (see \S\ref{sec:perlModuleDataExtraction}), by simply importing the {\normalfont \ttfamily Galacticus::EmissionLines} module. Emission line luminosites (in units of Solar luminosities) can then be accessed as named properties using names such as {\normalfont \ttfamily totalLineLuminosity:balmerAlpha6563:rest:z0.0000}, which will return the H$\alpha$ luminosity at $z=0$. Equivalent properties for disk and spheroid are provided (simply replace ``{\normalfont \ttfamily total}'' with ``{\normalfont \ttfamily disk}'' or ``{\normalfont \ttfamily spheroid}''). Currently available lines are:
\begin{itemize}
\item {\normalfont \ttfamily balmerAlpha6563}
\item {\normalfont \ttfamily balmerBeta4861}
\item {\normalfont \ttfamily oxygenII3726}
\item {\normalfont \ttfamily oxygenII3729}
\item {\normalfont \ttfamily oxygenIII4959}
\item {\normalfont \ttfamily oxygenIII5007}
\item {\normalfont \ttfamily nitrogenII6584}
\item {\normalfont \ttfamily sulfurII6731}
\item {\normalfont \ttfamily sulfurII6716}
\end{itemize}

Additionally, if a line is requested as {\normalfont \ttfamily totalLineLuminosity:balmerAlpha6563:<filterName>:rest:z0.0000} then the line luminosity is computed under the provided filter, and the luminosity is returned in units of \glspl{maggie} for easy conversion to magnitudes.

\subsection{Reionization Calculations}\label{sed:ReionziationTutorial}\index{reionization}

\glc\ can self-consistently solve for the evolution of the \gls{igm} as it becomes photoionized by light emitted by stars and AGN. To activate this calculation, include the following in your parameters file:
\begin{verbatim}
  <!-- IGM evolver -->
  <intergalacticMediumStateMethod  value="internal"/>
  <igmPropertiesCompute            value="true"    />
  <igmPropertiesTimeCountPerDecade value="10"      />
  
  <!-- Background radiation -->
  <backgroundRadiationCompute                  value="true"    />
  <radiationIntergalacticBackgroundMethod      value="internal"/>
  <backgroundRadiationWavelengthCountPerDecade value="50"      />
  <backgroundRadiationTimeCountPerDecade       value="10"      />

  <!-- Halo accretion options -->
  <accretionHaloMethod value="naozBarkana2007"/>
\end{verbatim}
The first block of parameters switches \glc\ to using an internal calculation for the state of the \gls{igm}, instructs it to solve for \gls{igm} properties as a function of time, and specifies that \gls{igm} properties should be updated 10 times per decade of cosmic time. Specifically, at each of these time intervals, solving of galaxy evolution is halted and the \gls{igm} evolved up to this time using the currently computed photoionizing background spectrum.

The second block of parameters activates an internal calculation of cosmic background radiation, in which the background is computed from the emissivities of model galaxies and AGN. The number of points at which to tabulate the background per decade of wavelength and cosmic time are specified.

Finally, the third block of parameters tells \glc\ to use the \cite{naoz_formation_2007} prescription for computing gas accretion into halos from the \gls{igm}. This prescription uses the filtering mass to determine accretion rates, and will take the filtering mass from the internal \gls{igm} evolution calculation.

With these three sets of configurations, \glc\ will perform a self-consistent evolution of the \gls{igm}---in the sense that the \gls{igm} is ionized by photons emitted by model galaxies and AGN, while galaxy evolution is affected by the computed state of the model \gls{igm}. Note that, when run in this way, \glc\ needs to keep all merger trees in memory simultaneously (as they are run synchronously to allow the \gls{igm} properties to evolved alongside galaxy properties).

Once completed, data on the \gls{igm} and background radiation are written to the output file in the {\normalfont \ttfamily igmProperties} and {\normalfont \ttfamily backgroundRadiation} groups respectively.
