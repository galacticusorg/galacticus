\chapter{Coding \glc}

\section{Numerical Tools}

\glc\ provides a variety of tools to solve basic numerical problems. These can be found in files {\tt source/numerical.*}. \glc\ makes use of the \href{http://www.gnu.org/software/gsl/}{GNU Scientific Library} for many of these tools, but typically provides a higher-level wrapper around those functions, providing a cleaner interface and, in some cases, additional functionality.

\subsection{Finding Roots of Equations}\index{root finding}\index{numerical algorithms!root finding}

Tools for solving equations of the form $f(x)=0$ are provided by the {\tt rootFinder} object (available via the {\tt Root\_Finder} module). Typical use of this object is as follows:
\begin{lstlisting}
! Import the module.
use Root_Finder
...
! Create a rootFinder object - make it OpenMP threadprivate so it can be used
! simultaneously by all threads.
type(rootFinder), save :: finder
!$omp threadprivate(finder)                                                                                                      
...
! Check if our root finder has been initialized.
if (.not.finder%isInitialized()) then
  ! Specify the function that evaluates f(x).
  call finder%rootFunction   (myRootFunction                     )
  ! Specify the type of root-finding algorithm - this is optional (Brent's
  ! method will be used by default).
  call finder%type           (FGSL_Root_fSolver_Brent            )
  ! Specify the tolerances to use in finding the root. Both arguments are
  !optional - values of 1.0d-10 will be used for both absolute and relative
  ! tolerance by default.
  call finder%tolerance      (toleranceAbsolute,toleranceRelative)
  ! Specify how the initially provided range can be expanded to bracket the
  ! root. This is optional - if not provided no range expansion will be attempted.
  call finder%rangeExpand                                               & 
       &  (                                                             &
       &   rangeExpandDownward          =0.5d0                        , &
       &   rangeExpandUpward            =2.0d0                        , &
       &   rangeExpandType              =rangeExpandMultiplicative    , &
       &   rangeDownwardLimit           =1.0d-3                       , &
       &   rangeUpwardLimit             =1.0d+3                       , &
       &   rangeExpandDownwardSignExpect=rangeExpandSignExpectPositive, &
       &   rangeExpandUpwardSignExpect  =rangeExpandSignExpectNegative
       &  )
end if
x=finder%find(rootGuess=1.0d0)
.
.
.
double precision function myRootFunction(x)
  implicit none
  double precision, intent(in   ) :: x
  ...
  return
end function myRootFunction
\end{lstlisting}
The above example begins by importing the {\tt Root\_Finder} module and then creating a {\tt rootFinder} object called {\tt finder}. This is made OpenMP {\tt threadprivate} so that it may be used simultaneously by all threads. The first step is to initialize {\tt finder}---the {\tt isInitialized} method tells us if this has already happened. The most important step is to specify the function that will evaluate $f(x)$. This is done via the {\tt rootFunction} method---once done, the {\tt rootFinder} object is marked as initialized (and the {\tt isInitialized} method will return {\tt true}). All other initialization steps are optional. In this example, we use the {\tt type} method to specify that the {\tt Brent} algorithm should be used for root finding. Any valid \href{http://www.gnu.org/software/gsl/manual/html_node/Root-Bracketing-Algorithms.html}{GSL-supported root finding algorithm} can be used. We then use the {\tt tolerance} method to specify both the absolute and relative tolerances in the $x$ variable that must be attained to declare the root to be found. Both arguments are optional---default values of $10^{-10}$ will be used if either tolerance is not specified. 

The final step of initialization is to call the {\tt rangeExpand} method. This specifies how the initial guessed value or range for $x$ should be expanded to bracket the root. If you plan to always specify an initial range, and know that it will always bracket the root, you do not need to specify how the range should be expanded. In this case we've specified that range expansion is multiplicative---that is, the lower and upper values of $x$ defining the range will be multiplied by fixed factors until the root is bracketed---via the {\tt rangeExpandType=rangeExpandMultiplicative} option. Alternatively, additive expansion is possible using {\tt rangeExpandType=rangeExpandAdditive}. The factors by which to multiply the lower and upper bounds of the range (or the factor to add in the case of additive expansion) are specified by the {\tt rangeExpandDownward} and {\tt rangeExpandUpward} options. Iit is possible to specify absolute lower/upper limits to the range via the {\tt rangeDownwardLimit} and {\tt rangeUpwardLimit} options. The range will not be expanded beyond these limits---if the root cannot be bracketed without exceeding these limits an error condition will occur. Finally, it is possible to indicate the expected sign of $f(x)$ at the lower and/or upper limits via the {\tt rangeExpandDownwardSignExpect} and {\tt rangeExpandUpwardSignExpect} options. Valid settings are {\tt rangeExpandSignExpectNegative}, {\tt rangeExpandSignExpectPositive}, and {\tt rangeExpandSignExpectNone} (the default---implying that there is no expectation for the sign). If the sign of $f(x)$ is specified, then range expansion will stop once the expected sign is found. This can often improve efficiency, by allowing the range expander to expand the range in only one direction, resulting in a narrower range in which to search for the root.

Finally, we use the {\tt find} method to return the value of the root. The first argument to {\tt find} is the name of the function that evaluates $f(x)$. Additionally, we must supply either {\tt rootGuess} (a scalar value guess to use as the initial value for both the lower and upper values of the range---note that range expansion must be allowed in this case), or {\tt rootRange} (a two-element array to use as the initial lower and upper values of the range bracketing the root).

The function evaluating $f(x)$ must have a form compatible with that shown for {\tt myRootFunction} in the above example.

\section{Computation Dependencies and Data Files}\index{depdencies, computation}\index{labels, unique}\index{unique labels}

In many situations, some module in \glc\ might want to perform a calculation and then store the results to a file so that they can be reused later. A good example is the {\tt CMBFast} transfer function method (see \S\ref{sec:TransferFunction:CMBFast}), which computes a transfer function using {\sc CMBFast} and stores this function in a file so that it can be re-read next time, avoiding the need to recompute the transfer function. A problem arises in such cases as the calculation may depend on the values of parameters (in our example, the transfer function will depend on cosmological parameters for example). We would like to record which parameter values this calculation refers to, perhaps encoding these into the file name, so that we can reuse these data in a future run only if the parameter values are unchanged. Given the modular nature of \glc\ it is impossible to know in advance which parameters will be relevant (e.g. does the cosmological parameter implementation have a parameter that describes a time varying equation of state for dark energy?). 

To addres this problem, \glc\ provides a mechanism to generate a unique label for a given module. This label encodes the names of modules on which the module depends, and the names and values of any parameters used by those modules. Functions to consruct these labels can be generated automatically, and intelligently determine which specific implementation of any method is active in a given run.

To create a unique labelling function, use the {\tt uniqueLabel} directive. For example, in the {\tt CMBFast} transfer function method the following code is used:
\begin{verbatim}
 !# <uniqueLabel>
 !#  <function>Transfer_Function_CMBFast_Label</function>
 !#  <ignore>transferFunctionFile</ignore>
 !#  <ignoreRegex>^imf.*</ignoreRegex>
 !# </uniqueLabel>
\end{verbatim}
This XML block specifies that the labelling function should be called {\tt Transfer\_Function\_CMBFast\_Label}. This function will be generated automatically during \glc\ build and will be available from the {\tt Input\_Parameters} module. The {\tt ignore} element specifies that the function should not encode the value of the {\tt transferFunctionFile} parameter in the label (in this case, the {\tt CMBFast} method sets the file name directly). Similarly, the {\tt ignoreRegex} element specifies that the function should not encode the value of any parameter which matches the regular expression provided (in this case, any parameter that begins with ``{\tt imf}''). Any number of {\tt ignore} and {\tt ignoreRegex} elements may be present.

The function returns a {\tt type(varying\_string)} object with the encoded label. For the {\tt CMBFast} method this might be:
\begin{verbatim}
 write (0,*) char(Transfer_Function_CMBFast_Label())
 
 ::cosmological_parameters#Omega_b[0.0455]#Omega_Matter[0.2725]#Omega_DE[0.7275]#T_CMB[2.72548]#H_0[70.2]
\end{verbatim}
Note that the relevant cosmological parameters have been encoded into the label. If called with {\tt includeVersion=.true.} then the \glc\ version string is appended to the label:
\begin{verbatim}
 write (0,*) char(Transfer_Function_CMBFast_Label(includeVersion=.true.))
 
 ::cosmological_parameters#Omega_b[0.0455]#Omega_Matter[0.2725]#Omega_DE[0.7275]#T_CMB[2.72548]#H_0[70.2]_v0.9.1.r764
\end{verbatim}
This can be useful to ensure that a file was generated by the exact same version of \glc. Finally, since the returned label can be long and cumbersome, if called with {\tt asHash=.true.} the labelling function will return an \gls{MD5hash} of the label
\begin{verbatim}
 write (0,*) char(Transfer_Function_CMBFast_Label(includeVersion=.true.,asHash=.true.))
 
 tudE3GawpjAXBzprr5azU0
\end{verbatim}
This hash can be used as part of the name of the file to which data is written.

\section{Optimization}\label{sec:Optimization}\index{optimization}

In designing \glc, we opted for simplicity and clarity over speed. However, there are numerous parts of the code where optimization has been performed without a significant loss of clarity. In this section we discuss some of the techniques used.

\subsection{Unique IDs and Stored Properties}\index{unique ID}

Frequently, a given property of a node may be required in many different aspects of the calculation. For example, the dark matter halo virial radius is used extensively in several distinct calculations within \glc. Frequently such calculations are performed for the same node, with the same properties several times\footnote{For example, \glc's ODE solver will fix the properties of a node and then request that derivatives of all properties be computed. Some functions will then be called multiple times for the same node with unchanged properties.}. Obviously this is inefficient. It can be advantageous in such cases to store the result of a calculation and, if the function is called again with the same unchanged node to simply return the stored value. \glc\ facilitates this by two features.

The first feature is the ``unique ID''---an integer number assigned to each node in \glc\ and which uniquely identifies a node (i.e. no two nodes processed in a \glc\ run will have the same unique ID). This number, which can be retrieved using the \href{method:uniqueID}{{\tt uniqueID}} property of a tree node, can be recorded each time a function is called. If called again for a node with the same unique ID as the previous call, the function can simply return the same answer as on the previous call.

The second feature accounts for the fact that the properties of a node will change, so even if a function is called on a node with the same unique ID it may occasionally need to recompute its result. \glc\ provides a calculation reset task\index{calculation reset task}\index{task, calculation reset} (see \S\ref{sec:CalculationResetTask}). All such tasks are performed just prior to the computation of derivatives for a node being evolved. A function can register a calculation reset task and use it to flag that it must update its calculations even if called again with the same node.

\section{Mixed Language Coding}\label{sec:MixedLanguageCoding}\index{coding!mixed language}\index{mixed language coding}\index{C (language) coding}

It is possible to incorporate C or C++ code into \glc. The implementation of C++-integration into \glc\ is currently only partially complete---if there is a specific function or feature that you would like to be C++-interoperable \href{mailto:abenson@obs.carnegiescience.edu}{contact us}. For an example of the various C++ interoperability see the {\tt star\_formation.timescales.disks.Baugh2005.cpp} file.

\subsection{Component Property Methods}

C++-wrappers are currently automatically built for the ``get'' method for all real scalar properties defined for \glc\ components. To use these wrappers include the following lines:
\begin{verbatim}
//: ./work/build/objects.nodes.bindings.C.o
#include <objects.nodes.bindings.C.h>
\end{verbatim}
The first line adds an explicit dependency on the bindings file, while the second includes it. A component of a given class can be retrieved from a supplied node pointer using:
\begin{verbatim}
nodeComponent<Class> this<Class>Component (thisNode);
\end{verbatim}
Then, real scalar get methods are available using:
\begin{verbatim}
value=this<Class>Component.<property>();
\end{verbatim}

\subsection{Using Functions in C++}

Where functions have been made available in C++ the approach is to make an identical interface as in Fortran, as far as is possible. So, for example, getting the expansion factor for some cosmological time would work as follows in the two languages:

\noindent Fortran
\begin{verbatim}
use Cosmology_Functions
expansionFactor=Expansion_Factor(cosmologicalTime)
\end{verbatim}

\noindent C++
\begin{verbatim}
//: ./work/build/cosmology.functions.o
#include <cosmology.functions.h>
expansionFactor=Expansion_Factor(cosmologicalTime)
\end{verbatim}

Currently, the only function with C++-wrappers are {\tt Expansion\_Factor} and the double precision and integer scalar versions of {\tt Get\_Input\_Parameter}. Further wrappers will be added as needed or \href{mailto:abenson@obs.carnegiescience.edu}{requested}.

\subsection{Adding New Implementations in C++}

Adding a new implementation of a method is done in a very similar way as in Fortran. For example, the {\tt Baugh2005} disk star formation timescale method initializes as follows:

\begin{verbatim}
//# <starFormationTimescaleDisksMethod>
//#  <unitName>Star_Formation_Timescale_Disk_Baugh2005_Initialize</unitName>
//# </starFormationTimescaleDisksMethod>
typedef double (func)(void *thisNode);
void  Star_Formation_Timescale_Disk_Baugh2005_Initialize(char *starFormationTimescaleDisksMethod,func **Star_Formation_Timescale_Disk_Get)
{
  char ourName[] = "Baugh2005";
  if (strcmp(starFormationTimescaleDisksMethod,ourName) == 0) {
    *Star_Formation_Timescale_Disk_Get=&Star_Formation_Timescale_Disk_Baugh2005;
  }
}
\end{verbatim}
The usual embedded XML directives specifies that this function should be called to initialize the method. The function is passed both the name of the method that has been selected and a function pointer. If the method is matched, the function simply sets the function pointer to point to the specific function implementing the timescale calculation.

\section{Objects}

\subsection{Enumerations}

Enumerations are used to communicate options to many functions in \glc. All available enumerations, along with their members, are described below.

\input{dataEnumerations}

\subsection{Object Methods}

The type of each method, and the type and names of its arguments are specified for each method of each object. Types are shown in red, enclosed by angle brackets, with a ``{\tt *}'' indicating a pointer. A {\tt \textless void\textgreater} type indicates a subroutine. Blue arrows after each argument show the argument intent: \textcolor{blue}{$\leftarrow$} implies {\tt intent(in)},  \textcolor{blue}{$\rightarrow$} implies {\tt intent(out)}, and \textcolor{blue}{$\leftrightarrow$} implies {\tt intent(inout)}.

\input{dataMethods}

