\chapter{Coding \glc}

\section{Galacticus Preprocessor Directives}

\glc\ has its own preprocessor for Fortran source files. This preprocesses parses each source file into an internal tree representation, performs various manipulations on that tree, and then outputs the preprocessed file for compilation. The preprocessor is used to automate and standardize many common tasks, through the inclusion of directives into the source code. Directives are specified in comment lines beginning {\normalfont \ttfamily !\#}, and are written in XML. The remainder of this section describes the various preprocessor functionalities, and gives examples of their usage.

\subsection{Source Digest}

The {\normalfont \ttfamily sourceDigest} directive will generate an \gls{MD5hash} hash of the source code of the file in which the directive is placed, along with the source code of any files upon which it depends. This can be useful in generating unique labels (e.g. to use as suffixes in file names) which automatically update if the source code is modified. To generate a source digest simply use:

\begin{lstlisting}
  !# <sourceDigest name="mySourceDigest"/>
\end{lstlisting}

A source digest will be generated and stored as a {\normalfont \ttfamily character(len=22)} variable called {\normalfont \ttfamily mySourceDigest}.

\subsection{Object Builder}

When constructing instances of a class from a provided parameter set, a common pattern is to need to construct other objects based on those parameters, which will be used by the instance. For example, a transfer function class might require a cosmological parameters object for its operation. In such cases, we often want to use the default instance of the required class unless a different instance is explicitly specified. The {\normalfont \ttfamily objectBuilder} directive automates this process.

As an example, the following constructor requires an instance of the {\normalfont \ttfamily cosmologyParameters} class, which is passes to an internal constructor:

\begin{lstlisting}  
  function myConstructorParameters(parameters)
    use Input_Parameters2
    implicit none
    type(myClass                  )                :: myConstructorParameters
    type(inputParameters          ), intent(in   ) :: parameters
    class(cosmologyParametersClass), pointer       :: cosmologyParameters_    

    !# <objectBuilder class="cosmologyParameters" name="cosmologyParameters_" source="parameters"/>
    myConstructorParameters=myConstructorInternal(cosmologyParameters_)
    return
  end function myConstructorParameters
\end{lstlisting}

The {\normalfont \ttfamily objectBuilder} directive will assign a member of the class specified by the {\normalfont \ttfamily class} attribute to the variable specified by the {\normalfont \ttfamily name} attribute. If the parameter set specified by the {\normalfont \ttfamily parameters} attribute contains an explicit definition of the relevant class, that definition will be used to construct the instance. Otherwise the default instance will be used.

\subsection{Object Destructor}

This directive can (and should) be used to destroy objects built by the {\normalfont \ttfamily objectBuilder} directive. The {\normalfont \ttfamily objectDestructor} directive automates the process of deciding if these objects should be destroyed (or merely have pointers to them nullified). As an example, the following destructor destroys two associated objects:
\begin{lstlisting}  
  subroutine simpleDestructor(self)
    implicit none
    type(powerSpectrumPrimordialTransferredSimple), intent(inout) :: self

    !# <objectDestructor name="self%transferFunction_"       />
    !# <objectDestructor name="self%powerSpectrumPrimordial_"/>
   return
  end subroutine simpleDestructor
\end{lstlisting}

\subsection{Optional Arguments}

Fortran supports optional arguments to functions, but does not provide for a default value if those arguments are not present. The {\normalfont \ttfamily optionalArgument} directive allows a default value to be specified. In the following example, a default value is defined for the {\normalfont \ttfamily units} argument:

\begin{lstlisting}
  double precision function simpleHubbleConstant(self,units)
    implicit none
    class  (cosmologyParametersSimple), intent(inout)           :: self
    integer                           , intent(in   ), optional :: units
    !# <optionalArgument name="units" defaultsTo="hubbleUnitsStandard" />

    select case (units_)
    case (hubbleUnitsStandard)
       ! Return the value using the default units.
    case ....
       ! Return the value using some other units.
    end select
    return
  end function simpleHubbleConstant
\end{lstlisting}
The {\normalfont \ttfamily optionalArgument} directive should appear after variable declarations and before any attempt to use the optional argument, and should have two attributes, {\normalfont \ttfamily name} and {\normalfont \ttfamily defaultsTo} which give the name of the argument variable and its default value respectively. The preprocessor will add a new variable with the same name plus an underscore suffix, and will ensure that it is initialized to the default value if the optional variable is not present, otherwise setting it to the value of the optional variable.

Note that for optional arguments that are {\normalfont \ttfamily intent(out)} or {\normalfont \ttfamily intent(inout)} the preprocessor currently \emph{does not} ensure that the value of the new variable is copied back to the argument prior to exit from the function.

\subsection{Enumerations}

The {\normalfont \ttfamily enumeration} directive allows specification of an enumeration (a set of labels), and (optionally) functions to decode such a label from user input. The following example illustrates this usage:

\begin{lstlisting}
module Cosmology_Parameters

  !# <enumeration>
  !#  <name>hubbleUnits</name>
  !#  <description>Specifies the units for the Hubble constant.</description>
  !#  <visibility>public</visbility> 
  !#  <encodeFunction>yes</encodeFunction>
  !#  <entry label="standard" />
  !#  <entry label="time"     />
  !#  <entry label="littleH"  />
  !# </enumeration>

contains

  subroutine Test_Enumeration()
    implicit none
    class(cosmologyParametersClass), pointer :: cosmologyParameters_
    cosmologyParameters_ => cosmologyParameters()
    write (0,*) "Hubble constant in little-h units is: ",cosmologyParameters_%HubbleConstant(hubbleUnitsLittleH)
    if (enumerationComponentTypeEncode('hubbleUnitsStandard') == hubbleUnitsStandard) then
      write (0,*) "Enumeration decoding succeeded"
    else
      write (0,*) "Enumeration decoding failed"
    end if
    if (enumerationComponentTypeEncode('standard',includesPrefix=.false.) == hubbleUnitsStandard) then
      write (0,*) "Enumeration decoding succeeded"
    else
      write (0,*) "Enumeration decoding failed"
    end if
    return
  end subroutine Test_Enumeration

end module Cosmology_Parameters
\end{lstlisting}

Enumerations must be defined in the declaration section of a {\normalfont \ttfamily module}. The encoding function will only be generated if the {\normalfont \ttfamily encode} element is present and has content {\normalfont \ttfamily yes}. The enumeration variables are given {\normlafont \ttfamily public} visibility by default---this can be overridden using the {\normalfont \ttfamily visibility} element. Note that the {\normalfont \ttfamily description} element is used to generate an entry for the enumeration in the document, and so should be written in \LaTeX\ syntax.

\subsection{Input Parameters}

The {\normalfont \ttfamily inputParameter} directive reads an input parameter and assigns the appropriate value to the given variable. {\normalfont \ttfamily inputParameter} directives must occur within the main body of a function, subroutine, or program. A default value can be specified if desired. The following example illustrates this usage:

\begin{lstlisting}
  subroutine simpleParametersRead()
    implicit none
    double precision :: hubbleConstant
    !# <inputParameter>
    !#   <name>HubbleConstant</name>
    !#   <source>myParameters</source>
    !#   <variable>hubbleConstant</variable>
    !#   <defaultValue>69.7d0</defaultValue>
    !#   <defaultSource>(\citealt{hinshaw_nine-year_2012}; CMB$+H_0+$BAO)</defaultSource>
    !#   <description>The present day value of the Hubble parameter in units of km/s/Mpc.</description>
    !#   <type>real</type>
    !#   <cardinality>0..1</cardinality>
    !# </inputParameter>
    if (hubbleConstant < 0.0d0) write (0,*) "The universe is collapsing!"
    return
  end subroutine simpleParametersRead
\end{lstlisting}

In this case, the value of the {\normalfont \ttfamily HubbleConstant} parameter is assigned to the {\normalfont \ttfamily hubbleConstant} variable, with a default of $69.7$ if no value was specified in the input parameter file. If the {\normalfont \ttfamily source} element is present, the parameter will be read from the named {\normalfont \ttfamily inputParameters} set, otherwise the parameter will be read from the top-level of the parameters file. The {\normalfont \ttfamily defaultSource}, {\normalfont \ttfamily <description>The}, {\normalfont \ttfamily type}, and {\normalfont \ttfamily cardinality} elements are used only for adding an entry for the input parameter to the documentation, and so should be written in \LaTeX\ syntax.

It is also possible to specify a set of parameter which iterate over names defined by other directives. The following example would read one parameter named ``{\normalfont \ttfamily fileNameForXXXXXXIMF}'' where ``{\normalfont \ttfamily XXXXXX}'' equals the {\normalfont \ttfamily name} element each {\normalfont \ttfamily imfRegisterName} dircetive:
\begin{lstlisting}
    !# <inputParameter>
    !#   <iterator>fileNameFor(#imfRegisterName->name)IMF</iterator>
    !#   <source>parameters</source>
    !#   <variable>fileNames(IMF_Index("$1"))</variable>
    !#   <defaultValue>Galacticus_Input_Path()//"data/SSP_Spectra_imf$1.hdf5"</defaultValue>
    !#   <description>The name of the file of stellar populations to use for the named \gls{imf}.</description>
    !#   <type>string</type>
    !#   <cardinality>0..1</cardinality>
  !# </inputParameter>
\end{lstlisting}

\subsection{Input Parameter Lists}

The {\normalfont \ttfamily inputParameterList} directive will construct a {\normalfont \ttfamily varying\_string} array containing the names of all input parameters which are defined in the unit in which the directive appears. The name of the array is specified by the {\normalfont \ttfamily label} attribute of the {\normalfont \ttfamily inputParameterList} directive. Such a list can be used to validate the names of parameters passed to a function for example.

\subsection{Function Classes}

Most\footnote{At this time the \protect\glc\ code base is being transitioned to use this approach.} of the internal functionality within \glc\ is provided by ``function classes''. These are classes (in the object oriented sense) which model some particular physical entity or concept (e.g. the underlying cosmological model) and provide one or more functions associated with that entity or concept. A default implementation of each function class can be selected at run-time, allowing for simple user-defined control of model behavior. A function class is specified by a {\normalfont \ttfamily functionClass} directive, together with one or more implementations of the function class specified by their own directives.

An example of a function class directive, which defines a class for cosmological parameters (which in this case, for simplicity, consists of just the Hubble constant) is given below:

\begin{lstlisting}
  !# <functionClass>
  !#  <name>cosmologyParameters</name>
  !#  <descriptiveName>Cosmological Parameters</descriptiveName>
  !#  <description>Object providing various cosmological parameters.</description>
  !#  <default>simple</default>
  !#  <defaultThreadPrivate>no</defaultThreadPrivate>
  !#  <stateful>no</stateful>
  !#  <calculationReset>no</calculationReset>
  !#  <method name="HubbleConstant" >
  !#   <description>Return the Hubble constant at the present day. The optional {\normalfont \ttfamily units} argument specifies if the return value should be in units of km/s/Mpc (hubbleUnitsStandard), Gyr$^{-1}$ (hubbleUnitsTime), or 100 km/s/Mpc (hubbleUnitsLittleH).</description>
  !#   <type>double precision</type>
  !#   <pass>yes</pass>
  !#   <argument>integer, intent(in   ), optional :: units</argument>
  !#  </method>
  !# </functionClass>
\end{lstlisting}

The directive should contain the following elements:
\begin{description}
\item[{\normalfont \ttfamily name}] The name of this function class.
\item[{\normalfont \ttfamily descriptiveName}] A descriptive name for the function class, suitable for inclusion in the documentation.
\item[{\normalfont \ttfamily description}] A description of the purpose of this function class. This description will be included into the documentation so should be written in \LaTeX\ syntax.
\item[{\normalfont \ttfamily default}] The default implementation to use for this function class if no choice is made in the input parameter file.
\item[{\normalfont \ttfamily defaultThreadPrivate}] \emph{(optional)} If present and set to {\normalfont \ttfamily yes} then the default implementation of this function class will be made OpenMP thread private. Otherwise, the default implementation is shared between threads. A thread private default implementation can be useful if the function class may need to generate look-up tables unique to each thread on the fly for example.
\item[{\normalfont \ttfamily stateful}] \emph{(optional)} If present and set to {\normalfont \ttfamily yes} then the default implementation of the function class is deemed to be stateful, in the sense that it may have internal state to be stored and restored from file (see \S\ref{sec:Restarting}). In this case, additional methods are generated for the function class: {\normalfont \ttfamily stateStore}, {\normalfont \ttfamily stateRestore}, and {\normalfont \ttfamily stateSnapshot} with interfaces:
  \begin{lstlisting}
    subroutine stateStore(self,stateFile,fgslStateFile)
      class  (functionClassBaseName), intent(inout) :: self
      integer                       , intent(in   ) :: stateFile
      type   (fgsl_file            ), intent(in   ) :: fgslStateFile
    end subroutine stateStore

    subroutine stateRestore(self,stateFile,fgslStateFile)
      class  (functionClassBaseName), intent(inout) :: self
      integer                       , intent(in   ) :: stateFile
      type   (fgsl_file            ), intent(in   ) :: fgslStateFile
    end subroutine stateRestore

    subroutine stateSnapshot(self)
      class  (functionClassBaseName), intent(inout) :: self
    end subroutine stateSnapshot
  \end{lstlisting}
  These methods have null implementations for the base class of the function class, but can be overridden to store/restore the state of any given implementation.
\item[{\normalfont \ttfamily calculationReset}] \emph{(optional)} If present and set to {\normalfont \ttfamily yes} then the default implementation of the function class is assumed to possibly want to reset its calculations when the active \gls{node} changes (see \S\ref{sec:CalculationResetTask}). In this case, an additional method is generated for the function class: {\normalfont \ttfamily calculationReset} with interface:
  \begin{lstlisting}
    subroutine calculationReset(self,thisNode)
      class  (functionClassBaseName), intent(inout)          :: self
      type   (treeNode             ), intent(inout), pointer :: thisNode
    end subroutine calculationReset
  \end{lstlisting}
  This method has a null implementation for the base class of the function class, but can be overridden to reset calculations of any given implementation.
\item[{\normalfont \ttfamily method}] Each {\normalfont \ttfamily method} element defines a method which the function class will support, the name of which is given by a {\normalfont \ttfamily name} attribute. The method definition must contain the following elements:
  \begin{description}
  \item[{\normalfont \ttfamily description}] A description of this method (in \LaTeX\ syntax) suitable for inclusion into the documentation.
  \item[{\normalfont \ttfamily type}] The type of the function (e.g. {\normalfont \ttfamily double precision}; use {\normalfont \ttfamily void} for a subroutine).
  \item[{\normalfont \ttfamily pass}] If {\normalfont \ttfamily yes} pass the object that the method was called on as the first argument.
  \item[{\normalfont \ttfamily argument}] \emph{(optional)} Zero or more declarations (in standard Fortran syntax) for the method arguments (there is no need to specify the declaration for the object upon which the method was called in the case where this object is passed to the method function).
  \end{description}
\end{description}

Implementations of this function class must be declared with a directive having the same name as the function class (i.e. {\normalfont \ttfamily cosmologyParameters} in the example above). The directive must give the name of the implementation as an attribute, and a description of the implementation suitable for inclusion into the documentation. Each implementation should be placed in a separate file---the preprocessor will find these files and merge the implementations and function class definition into a single file for compilation. Each implementation should declare a class which extends the basic function class, constructor interfaces, and any module-scope data required by the class. The implementation should also define all necessary functions required by the class (separated from the declarations by a {\normalfont \ttfamily contains} keyword). An example is given below:

\begin{lstlisting}
  !# <cosmologyParameters name="cosmologyParametersSimple">
  !#  <description>Provides the Hubble constant: $H_0$.</description>
  !# </cosmologyParameters>
  type, extends(cosmologyParametersClass) :: cosmologyParametersSimple
     private
     double precision :: HubbleConstantValue
   contains
     final     ::                    simpleDestructor
     procedure :: HubbleConstant  => simpleHubbleConstant
  end type cosmologyParametersSimple

  interface cosmologyParametersSimple
     module procedure simpleDefaultConstructor
     module procedure simpleConstructor
  end interface cosmologyParametersSimple

contains

  function simpleDefaultConstructor()
    implicit none
    type(cosmologyParametersSimple) :: simpleDefaultConstructor

    ! Construct an instance of this class using a value of the Hubble constant read from the input parameter file.
    !# <inputParameter>
    !#   <name>H_0</name>
    !#   <variable>simpleDefaultConstructor%HubbleConstantValue</variable>
    !#   <defaultValue>69.7d0</defaultValue>
    !#   <defaultSource>(\citealt{hinshaw_nine-year_2012}; CMB$+H_0+$BAO)</defaultSource>
    !#   <description>The present day value of the Hubble parameter in units of km/s/Mpc.</description>
    !#   <type>real</type>
    !#   <cardinality>0..1</cardinality>
    !# </inputParameter>
    return
  end function simpleDefaultConstructor

  function simpleConstructor(HubbleConstant)
    implicit none
    type            (cosmologyParametersSimple)                :: simpleConstructor
    double precision                           , intent(in   ) :: HubbleConstant

    ! Construct an instance of this class using a value of the Hubble constant provided directly.
    simpleConstructor%HubbleConstantValue=HubbleConstant
    return
  end function simpleConstructor

  elemental subroutine simpleDestructor(self)
    implicit none
    type(cosmologyParametersSimple), intent(inout) :: self

    ! Do any clean-up required by this class when an instance goes out-of-scope.
    return
  end subroutine simpleDestructor

  double precision function simpleHubbleConstant(self,units)
    implicit none
    class  (cosmologyParametersSimple), intent(inout)           :: self
    integer                           , intent(in   ), optional :: units

    ! Do whatever is necessary to return the Hubble constant in the appropriate units.
    return
  end function simpleHubbleConstant
\end{lstlisting}

In the above example, we define a ``simple'' implementation of the {\normalfont cosmologyParameters} class. Key points are:
\begin{description}
\item[Name:] The name should always be prefixed with the function class name. In this case, we have a {\normalfont \ttfamily simple} implementation of the {\normalfont \ttfamily cosmologyParameters} function class, and so our name is {\normalfont \ttfamily cosmologyParametersSimple}.
\item[Extends:] The base class for the function class is always the function class name suffixed with {\normalfont \ttfamily Class}, in this case {\normalfont \ttfamily cosmologyParametersClass}. Implementations must always be extensions of either this base class, or of another implementation.
\item[Procedures:] The implementation must define procedures for all methods of the function class, \emph{except} for where a method specified a {\normalfont \ttfamily code} element in the function class directive (in which case a procedure for the method may still be optionally defined). Specification of a {\normalfont \ttfamily final} function is encouraged.
\item[Constructors:] The implementation must specify at least one constructor, which takes no arguments (usually known as the default constructor). This constructor must create an instance of the implementation, setting any parameters from the input parameter file as necessary. Additional constructors may be defined as required.
\item[Procedures:] All required procedures (including constructors and destructors) should be given after a line containing the {\normalfont \ttfamily contains} keyword. \glc\ coding policy is that all procedures associated with an implementation should be prefixed with the implementation name, {\normalfont \ttfamily simple} in this case.
\end{description}

\subsection{Generic Programming}

The preprocessor supports generic programming by allowing generic types to be defined, which are automatically expanded to a set of specific types. Significant flexibility is provided to allow control over how each specific type is handled. A generic type is specific via a {\normalfont \ttfamily generic} directive such as:
\lstset{escapechar=@}
\begin{lstlisting}
  !# <generic identifier="Type">
  !#  <instance label="Logical"        intrinsic="logical"                         outputConverter="regEx@\textbrokenbar@(.*)@\textbrokenbar@char($1)@\textbrokenbar@"/>
  !#  <instance label="Integer"        intrinsic="integer"                         outputConverter="regEx@\textbrokenbar@(.*)@\textbrokenbar@$1@\textbrokenbar@"      />
  !#  <instance label="Double"         intrinsic="double precision"                outputConverter="regEx@\textbrokenbar@(.*)@\textbrokenbar@$1@\textbrokenbar@"      />
  !#  <instance label="LogicalRank1"   intrinsic="logical          , dimension(:)" outputConverter="regEx@\textbrokenbar@(.*)@\textbrokenbar@char($1)@\textbrokenbar@"/>
  !#  <instance label="IntegerRank1"   intrinsic="integer          , dimension(:)" outputConverter="regEx@\textbrokenbar@(.*)@\textbrokenbar@$1@\textbrokenbar@"      />
  !#  <instance label="DoubleRank1"    intrinsic="double precision , dimension(:)" outputConverter="regEx@\textbrokenbar@(.*)@\textbrokenbar@$1@\textbrokenbar@"      />
  !# </generic>
\end{lstlisting}
The above defines a generic type, which will be identified using the label ``{\normalfont \ttfamily Type}''. The directive contains several {\normalfont \ttfamily instance} elements, each of which specifies a specific type which should be implemented for the generic type. Each instance can contain an arbitrary number of attributes which specify strings or regular expressions which will be used to construct the specific implementation.

A generic directive applies to the entire unit within which it is scoped. The preprocessor will examine every element within that unit. If a generic tag (see below) is found in the opening of any subunit, that entire subunit is copied once for each instance, and any generic tags replaced with the appropriate content from the {\normalfont \ttfamily instance} element. Where a generic tag is found in a non-opening line (and that line is not contained within a subunit whose opener \emph{does} contain a generci tag), the line itself is replicated in the same way.

An example of the usage of generic tags using the above generic directive is:
\lstset{escapechar=@}
\begin{lstlisting}

  type :: exampleType
     private
     .
     .
     .
   contains
     final     ::        exampleTypeDestroy
     procedure ::        exampleTypeSet{Type@\textbrokenbar@label}
     generic   :: set => exampleTypeSet{Type@\textbrokenbar@label}
  end type exampleType

contains

  subroutine exampleTypeSet{Type@\textbrokenbar@label}(self,setValue)
    implicit none
    class           (exampleType), intent(in   ) :: self
    {Type@\textbrokenbar@intrinsic}             , intent(in   ) :: setValue

    {Type@\textbrokenbar@match@\textbrokenbar@^Logical@\textbrokenbar@! Do something to set a logical value.@\textbrokenbar@! Do something different to set a numerical value.@\textbrokenbar@}
    write (0,*) "Value is: ",{Type@\textbrokenbar@outputConverter@\textbrokenbar@setValue}
  end subroutine exampleTypeSet{Type@\textbrokenbar@label}
\end{lstlisting}

In this example, the {\normalfont \ttfamily exampleType} class is defined to have a generic {\normalfont \ttfamily set} method. The presence of the {\normalfont \ttfamily \{Type@\textbrokenbar@label\}} generic tag will cause those lines to be replicated with the tag replaced by the content of the {\normalfont \ttfamily label} attribute of each instance of the generic type. In the contained subroutine, a generic tag appears in the opener. As such, the entire subroutine will be replicated once for each instance of the generic type, and the generic tags replaced as appropriate.

When a generic instance attribute begins with {\normalfont \ttfamily regEx}, matching generic tags are handled differently. In particular, a match-and-replace regular expression is applied to the third element of the generic tag (elements are separated by broken vertical bar characters). The match and replace components of the regular expression are defined in the instance attribute, once again separated by broken vertical bars.

Finally, the special generic tag {\normalfont \ttfamily match} acts as a ternary operator. If the regular expression specified in the third element matches the {\normalfont \ttfamily label} attribute of a specific instance, the generic tag is replaced with its fourth element, otherwise it is replaced with its fifth element.

\section{Numerical Tools}

\glc\ provides a variety of tools to solve basic numerical problems. These can be found in files {\normalfont \ttfamily source/numerical.*}. \glc\ makes use of the \href{http://www.gnu.org/software/gsl/}{GNU Scientific Library} for many of these tools, but typically provides a higher-level wrapper around those functions, providing a cleaner interface and, in some cases, additional functionality.

\subsection{Finding Roots of Equations}\index{root finding}\index{numerical algorithms!root finding}

Tools for solving equations of the form $f(x)=0$ are provided by the {\normalfont \ttfamily rootFinder} object (available via the {\normalfont \ttfamily Root\_Finder} module). Typical use of this object is as follows:
\begin{lstlisting}
! Import the module.
use Root_Finder
...
! Create a rootFinder object - make it OpenMP threadprivate so it can be used
! simultaneously by all threads.
type(rootFinder), save :: finder
!$omp threadprivate(finder)                                                                                                      
...
! Check if our root finder has been initialized.
if (.not.finder%isInitialized()) then
  ! Specify the function that evaluates f(x).
  call finder%rootFunction   (myRootFunction                     )
  ! Specify the type of root-finding algorithm - this is optional (Brent's
  ! method will be used by default).
  call finder%type           (FGSL_Root_fSolver_Brent            )
  ! Specify the tolerances to use in finding the root. Both arguments are
  !optional - values of 1.0d-10 will be used for both absolute and relative
  ! tolerance by default.
  call finder%tolerance      (toleranceAbsolute,toleranceRelative)
  ! Specify how the initially provided range can be expanded to bracket the
  ! root. This is optional - if not provided no range expansion will be attempted.
  call finder%rangeExpand                                               & 
       &  (                                                             &
       &   rangeExpandDownward          =0.5d0                        , &
       &   rangeExpandUpward            =2.0d0                        , &
       &   rangeExpandType              =rangeExpandMultiplicative    , &
       &   rangeDownwardLimit           =1.0d-3                       , &
       &   rangeUpwardLimit             =1.0d+3                       , &
       &   rangeExpandDownwardSignExpect=rangeExpandSignExpectPositive, &
       &   rangeExpandUpwardSignExpect  =rangeExpandSignExpectNegative
       &  )
end if
x=finder%find(rootGuess=1.0d0)
.
.
.
double precision function myRootFunction(x)
  implicit none
  double precision, intent(in   ) :: x
  ...
  return
end function myRootFunction
\end{lstlisting}
The above example begins by importing the {\normalfont \ttfamily Root\_Finder} module and then creating a {\normalfont \ttfamily rootFinder} object called {\normalfont \ttfamily finder}. This is made OpenMP {\normalfont \ttfamily threadprivate} so that it may be used simultaneously by all threads. The first step is to initialize {\normalfont \ttfamily finder}---the {\normalfont \ttfamily isInitialized} method tells us if this has already happened. The most important step is to specify the function that will evaluate $f(x)$. This is done via the {\normalfont \ttfamily rootFunction} method---once done, the {\normalfont \ttfamily rootFinder} object is marked as initialized (and the {\normalfont \ttfamily isInitialized} method will return {\normalfont \ttfamily true}). All other initialization steps are optional. In this example, we use the {\normalfont \ttfamily type} method to specify that the {\normalfont \ttfamily Brent} algorithm should be used for root finding. Any valid \href{http://www.gnu.org/software/gsl/manual/html_node/Root-Bracketing-Algorithms.html}{GSL-supported root finding algorithm} can be used. We then use the {\normalfont \ttfamily tolerance} method to specify both the absolute and relative tolerances in the $x$ variable that must be attained to declare the root to be found. Both arguments are optional---default values of $10^{-10}$ will be used if either tolerance is not specified. 

The final step of initialization is to call the {\normalfont \ttfamily rangeExpand} method. This specifies how the initial guessed value or range for $x$ should be expanded to bracket the root. If you plan to always specify an initial range, and know that it will always bracket the root, you do not need to specify how the range should be expanded. In this case we've specified that range expansion is multiplicative---that is, the lower and upper values of $x$ defining the range will be multiplied by fixed factors until the root is bracketed---via the {\normalfont \ttfamily rangeExpandType=rangeExpandMultiplicative} option. Alternatively, additive expansion is possible using {\normalfont \ttfamily rangeExpandType=rangeExpandAdditive}. The factors by which to multiply the lower and upper bounds of the range (or the factor to add in the case of additive expansion) are specified by the {\normalfont \ttfamily rangeExpandDownward} and {\normalfont \ttfamily rangeExpandUpward} options. Iit is possible to specify absolute lower/upper limits to the range via the {\normalfont \ttfamily rangeDownwardLimit} and {\normalfont \ttfamily rangeUpwardLimit} options. The range will not be expanded beyond these limits---if the root cannot be bracketed without exceeding these limits an error condition will occur. Finally, it is possible to indicate the expected sign of $f(x)$ at the lower and/or upper limits via the {\normalfont \ttfamily rangeExpandDownwardSignExpect} and {\normalfont \ttfamily rangeExpandUpwardSignExpect} options. Valid settings are {\normalfont \ttfamily rangeExpandSignExpectNegative}, {\normalfont \ttfamily rangeExpandSignExpectPositive}, and {\normalfont \ttfamily rangeExpandSignExpectNone} (the default---implying that there is no expectation for the sign). If the sign of $f(x)$ is specified, then range expansion will stop once the expected sign is found. This can often improve efficiency, by allowing the range expander to expand the range in only one direction, resulting in a narrower range in which to search for the root.

Finally, we use the {\normalfont \ttfamily find} method to return the value of the root. The first argument to {\normalfont \ttfamily find} is the name of the function that evaluates $f(x)$. Additionally, we must supply either {\normalfont \ttfamily rootGuess} (a scalar value guess to use as the initial value for both the lower and upper values of the range---note that range expansion must be allowed in this case), or {\normalfont \ttfamily rootRange} (a two-element array to use as the initial lower and upper values of the range bracketing the root).

The function evaluating $f(x)$ must have a form compatible with that shown for {\normalfont \ttfamily myRootFunction} in the above example.

\section{Computation Dependencies and Data Files}\index{depdencies, computation}\index{labels, unique}\index{unique labels}

In many situations, some module in \glc\ might want to perform a calculation and then store the results to a file so that they can be reused later. A good example is the {\normalfont \ttfamily CAMB} transfer function method (see \S\ref{sec:TransferFunction:CAMB}), which computes a transfer function using {\normalfont \scshape CAMB} and stores this function in a file so that it can be re-read next time, avoiding the need to recompute the transfer function. A problem arises in such cases as the calculation may depend on the values of parameters (in our example, the transfer function will depend on cosmological parameters for example). We would like to record which parameter values this calculation refers to, perhaps encoding these into the file name, so that we can reuse these data in a future run only if the parameter values are unchanged. Given the modular nature of \glc\ it is impossible to know in advance which parameters will be relevant (e.g. does the cosmological parameter implementation have a parameter that describes a time varying equation of state for dark energy?). 

To addres this problem, \glc\ provides a mechanism to generate a unique label for a given module. This label encodes the names of modules on which the module depends, and the names and values of any parameters used by those modules. Functions to consruct these labels can be generated automatically, and intelligently determine which specific implementation of any method is active in a given run.

To create a unique labelling function, use the {\normalfont \ttfamily uniqueLabel} directive. For example, in the {\normalfont \ttfamily CAMB} transfer function method the following code is used:
\begin{verbatim}
 !# <uniqueLabel>
 !#  <function>Transfer_Function_CAMB_Label</function>
 !#  <ignore>transferFunctionFile</ignore>
 !#  <ignoreRegex>^imf.*</ignoreRegex>
 !#  <hashFile>myExtraFile.txt</hashFile>
 !# </uniqueLabel>
\end{verbatim}
This XML block specifies that the labelling function should be called {\normalfont \ttfamily Transfer\_Function\_CAMB\_Label}. This function will be generated automatically during \glc\ build and will be available from the {\normalfont \ttfamily Input\_Parameters} module. The {\normalfont \ttfamily ignore} element specifies that the function should not encode the value of the {\normalfont \ttfamily transferFunctionFile} parameter in the label (in this case, the {\normalfont \ttfamily CAMB} method sets the file name directly). Similarly, the {\normalfont \ttfamily ignoreRegex} element specifies that the function should not encode the value of any parameter which matches the regular expression provided (in this case, any parameter that begins with ``{\normalfont \ttfamily imf}''). Any number of {\normalfont \ttfamily ignore} and {\normalfont \ttfamily ignoreRegex} elements may be present. Finally, a {\normalfont \ttfamily hashFile} element specifies the name of a file on which this calculation depends, but which will not be detected automatically (see below). An MD5 digest of the file will be included in the label if the {\normalfont \ttfamily includeSourceDigest} argument is set to true.

The function returns a {\normalfont \ttfamily type(varying\_string)} object with the encoded label. For the {\normalfont \ttfamily CAMB} method this might be:
\begin{verbatim}
 write (0,*) char(Transfer_Function_CAMB_Label())
 
 ::cosmology.parameters.simple#Omega_b[0.0455]#Omega_Matter[0.2725]#Omega_DE[0.7275]#T_CMB[2.72548]#H_0[70.2]
\end{verbatim}
Note that the relevant cosmological parameters have been encoded into the label. If called with {\normalfont \ttfamily includeVersion=.true.} then the \glc\ version string is appended to the label:
\begin{verbatim}
 write (0,*) char(Transfer_Function_CAMB_Label(includeVersion=.true.))
 
 ::cosmology.parameters.simple#Omega_b[0.0455]#Omega_Matter[0.2725]#Omega_DE[0.7275]#T_CMB[2.72548]#H_0[70.2]_v0.9.3.r2022
\end{verbatim}
This can be useful to ensure that a file was generated by the exact same version of \glc. It is also possible, by setting the optional {\normalfont \ttfamily includeBuild} argument to {\normalfont \ttfamily .true.}, to append full build information (library versions, environment variables) to the label.

By setting the optional {\normalfont \ttfamily includeSourceDigest} argument to {\normalfont \ttfamily .true.}, an MD5 digest of each source file on which the function depends will be incorporated into the label. In addition to source files, any data file referenced by those source files will be included in the digest calculation. Data files are taken to be any file referenced in the {\normalfont \ttfamily data/} directory and having suffix {\normalfont \ttfamily .xml} or {\normalfont \ttfamily .hdf5}.

Since the returned label can be long and cumbersome, if called with {\normalfont \ttfamily asHash=.true.} the labelling function will return an \gls{MD5hash} of the label
\begin{verbatim}
 write (0,*) char(Transfer_Function_CAMB_Label(includeVersion=.true.,asHash=.true.))
 
 tudE3GawpjAXBzprr5azU0
\end{verbatim}
This hash can be used as part of the name of the file to which data is written.

Finally, each function can return a list of parameter names and values (as an {\normalfont \ttfamily inputParameterList} object) which are included in the unique label. These parameters can then be easily written to a generated file using the {\normalfont \ttfamily outputToXML} method of the {\normalfont \ttfamily inputParameterList} object.

\section{Optimization}\label{sec:Optimization}\index{optimization}

In designing \glc, we opted for simplicity and clarity over speed. However, there are numerous parts of the code where optimization has been performed without a significant loss of clarity. In this section we discuss some of the techniques used.

\subsection{Unique IDs and Stored Properties}\index{unique ID}

Frequently, a given property of a node may be required in many different aspects of the calculation. For example, the dark matter halo virial radius is used extensively in several distinct calculations within \glc. Frequently such calculations are performed for the same node, with the same properties several times\footnote{For example, \glc's ODE solver will fix the properties of a node and then request that derivatives of all properties be computed. Some functions will then be called multiple times for the same node with unchanged properties.}. Obviously this is inefficient. It can be advantageous in such cases to store the result of a calculation and, if the function is called again with the same unchanged node to simply return the stored value. \glc\ facilitates this by two features.

The first feature is the ``unique ID''---an integer number assigned to each node in \glc\ and which uniquely identifies a node (i.e. no two nodes processed in a \glc\ run will have the same unique ID). This number, which can be retrieved using the \href{method:uniqueID}{{\normalfont \ttfamily uniqueID}} property of a tree node, can be recorded each time a function is called. If called again for a node with the same unique ID as the previous call, the function can simply return the same answer as on the previous call.

The second feature accounts for the fact that the properties of a node will change, so even if a function is called on a node with the same unique ID it may occasionally need to recompute its result. \glc\ provides a calculation reset task\index{calculation reset task}\index{task, calculation reset} (see \S\ref{sec:CalculationResetTask}). All such tasks are performed just prior to the computation of derivatives for a node being evolved. A function can register a calculation reset task and use it to flag that it must update its calculations even if called again with the same node.

\section{Mixed Language Coding}\label{sec:MixedLanguageCoding}\index{coding!mixed language}\index{mixed language coding}\index{C (language) coding}

It is possible to incorporate C or C++ code into \glc. The implementation of C++-integration into \glc\ is currently only partially complete---if there is a specific function or feature that you would like to be C++-interoperable \href{mailto:abenson@obs.carnegiescience.edu}{contact us}. For an example of the various C++ interoperability see the {\normalfont \ttfamily star\_formation.timescales.disks.Baugh2005.cpp} file.

\subsection{Component Property Methods}

C++-wrappers are currently automatically built for the ``get'' method for all real scalar properties defined for \glc\ components. To use these wrappers include the following lines:
\begin{verbatim}
//: ./work/build/objects.nodes.bindings.C.o
#include <objects.nodes.bindings.C.h>
\end{verbatim}
The first line adds an explicit dependency on the bindings file, while the second includes it. A component of a given class can be retrieved from a supplied node pointer using:
\begin{verbatim}
nodeComponent<Class> this<Class>Component (thisNode);
\end{verbatim}
Then, real scalar get methods are available using:
\begin{verbatim}
value=this<Class>Component.<property>();
\end{verbatim}

\subsection{Using Functions in C++}

Where functions have been made available in C++ the approach is to make an identical interface as in Fortran, as far as is possible. So, for example, getting the expansion factor for some cosmological time would work as follows in the two languages:

\noindent Fortran
\begin{verbatim}
use Cosmology_Functions
expansionFactor=Expansion_Factor(cosmologicalTime)
\end{verbatim}

\noindent C++
\begin{verbatim}
//: ./work/build/cosmology.functions.o
#include <cosmology.functions.h>
expansionFactor=Expansion_Factor(cosmologicalTime)
\end{verbatim}

Currently, the only function with C++-wrappers are {\normalfont \ttfamily Expansion\_Factor} and the double precision and integer scalar versions of {\normalfont \ttfamily Get\_Input\_Parameter}. Further wrappers will be added as needed or \href{mailto:abenson@obs.carnegiescience.edu}{requested}.

\subsection{Adding New Implementations in C++}

Adding a new implementation of a method is done in a very similar way as in Fortran. For example, the {\normalfont \ttfamily Baugh2005} disk star formation timescale method initializes as follows:

\begin{verbatim}
//# <starFormationTimescaleDisksMethod>
//#  <unitName>Star_Formation_Timescale_Disk_Baugh2005_Initialize</unitName>
//# </starFormationTimescaleDisksMethod>
typedef double (func)(void *thisNode);
void  Star_Formation_Timescale_Disk_Baugh2005_Initialize(char *starFormationTimescaleDisksMethod,func **Star_Formation_Timescale_Disk_Get)
{
  char ourName[] = "Baugh2005";
  if (strcmp(starFormationTimescaleDisksMethod,ourName) == 0) {
    *Star_Formation_Timescale_Disk_Get=&Star_Formation_Timescale_Disk_Baugh2005;
  }
}
\end{verbatim}
The usual embedded XML directives specifies that this function should be called to initialize the method. The function is passed both the name of the method that has been selected and a function pointer. If the method is matched, the function simply sets the function pointer to point to the specific function implementing the timescale calculation.

\section{Global Functions}

In very exceptional circumstances it is necessary to subvert the module hierarchy used by \glc\ to permit one module to call a function in a higher level module\footnote{This usually arises because circular dependencies would arise if the called function were placed in a lower level module.}. Examples of where this approach is necessary usuually involve initial bootstrapping (i.e. to establish halo density contrasts, which requires knowledge of the halo density profile, which in turn requires knowledge of the halo density contrast\ldots).

\glc\ provides for global functions which facilitate this---specifically, it is possible to generate function pointers to higher level functions which are accessible via a very low-level module. To create a globally callable copy of a function use add the follow prior to the function definition:
\begin{verbatim}
  !# <functionGlobal>
  !#  <unitName>myFunction</unitName>
  !#  <type>double precision</type>
  !#  <arguments>double precision , intent(in   ) :: mass, time</arguments>
  !# </functionGlobal>
\end{verbatim}
Here, {\normalfont \ttfamily myFunction} is the name of the function to make global, while the {\normalfont \ttfamily type} and {\normalfont \ttfamily arguments} (of which there may be more than one) elements are used to generate a suitable interface for the function. At run-time, a pointer to this function is then available from the {\normalfont \ttfamily Functions\_Global} module, named {\normalfont \ttfamily myFunction\_}. Note that {\normalfont \ttfamily Functions\_Global\_Set} provided by the {\normalfont \ttfamily Functions\_Global\_Utilities} module must be called once to initialize these global function pointers prior to their use.

\section{Objects}

\subsection{Enumerations}

Enumerations are used to communicate options to many functions in \glc. All available enumerations, along with their members, are described below.

\input{autoEnumerationDefinitions}

\input{dataEnumerations}

\subsection{Object Methods}

The type of each method, and the type and names of its arguments are specified for each method of each object. Types are shown in red, enclosed by angle brackets, with a ``{\normalfont \ttfamily *}'' indicating a pointer. A {\normalfont \ttfamily \textless void\textgreater} type indicates a subroutine. Blue arrows after each argument show the argument intent: \textcolor{blue}{$\leftarrow$} implies {\normalfont \ttfamily intent(in)},  \textcolor{blue}{$\rightarrow$} implies {\normalfont \ttfamily intent(out)}, and \textcolor{blue}{$\leftrightarrow$} implies {\normalfont \ttfamily intent(inout)}.

\input{dataMethods}

