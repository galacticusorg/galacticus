\chapter{Adding New Methods}

\section{Code Directives}\label{sec:CodeDirectives}\index{directives}\index{code!directives}

\glc\ is designed to be flexible and extensible, allowing you to add new methods and functionality without having to hack the code extensively. To achieve this it makes much use of embedded code directives which, for example, explain to the build system how a particular subroutine or function connects into the \glc\ code. Such code directives are indicated by lines beginning with {\normalfont \ttfamily !\#}, and take the form of short blocks of XML. For example, a typical code directive might look like:
\begin{verbatim}
 !# <accretionDisksMethod>
 !#  <unitName>Accretion_Disks_Shakura_Sunyaev_Initialize</unitName>
 !# </accretionDisksMethod>
\end{verbatim}
This directive would typically appear just prior to a subroutine which initializes the Shakura-Sunyaev accretion disk module (it could appear anywhere throughout that module, but it makes sense to keep it close to the subroutine that it references). The {\normalfont \ttfamily accretionDisksMethod} tag explains to the \glc\ build system that this module contains an implementation of black hole accretion disks. The {\normalfont \ttfamily unitName} tag specifies the name of a program unit which (in this case) should be called to initialize this accretion disk implementation. The build system will then insert appropriate {\normalfont \ttfamily use} and {\normalfont \ttfamily call} statements into the \glc\ code such that this routine will be called if and when accretion disks are required by \glc.

\section{Identifying Components and Mass Types}\label{sec:ComponentMassTypes}

Many functions can be applied to different components or groups of components and to different types of mass within a node. In general, these functions make use of a set of label defined in the \hyperlink{galactic_structure.options.F90:galactic_structure_options}{{\normalfont \ttfamily Galactic\_Structure\_Options}} module. Components are identified by a {\normalfont \ttfamily componentType} label which can take on the following values:
\begin{description}
 \item [{\normalfont \ttfamily componentTypeAll}] All components are matched;
 \item [{\normalfont \ttfamily componentTypeDisk}] Only disk components are matched;
 \item [{\normalfont \ttfamily componentTypeSpheroid}] Only spheroid components are matched.
 \item [{\normalfont \ttfamily componentTypeBlackHole}] Only black hole components are matched.
 \item [{\normalfont \ttfamily componentTypeHotHalo}] Only hot halo components are matched.
 \item [{\normalfont \ttfamily componentTypeDarkHalo}] Only dark matter halo components are matched.
\end{description}
Types of mass are identified by a {\normalfont \ttfamily massType} which can take one of the following values:
\begin{description}
 \item [{\normalfont \ttfamily massTypeAll}] All mass is included;
 \item [{\normalfont \ttfamily massTypeDark}] Only dark matter is included;
 \item [{\normalfont \ttfamily massTypeBaryonic}] Only baryonic mass is included;
 \item [{\normalfont \ttfamily massTypeGalactic}] Only galactic mass is included.
 \item [{\normalfont \ttfamily massTypeGaseous}] Only gaseous mass is included.
 \item [{\normalfont \ttfamily massTypeStellar}] Only stellar mass is included.
 \item [{\normalfont \ttfamily massTypeBlackHole}] Only black hole mass is included.
\end{description}

\section{Components}\index{components}

This section describes the internal structure of node components, and how a component is implemented.

\subsection{Component Structure}\index{components!structure}

Each node in the merger tree consists of an arbitrary number of ``components'', each of which can actually be an array, allowing multiple components of a given class. Each component represents a specific class of object, which could be a dark matter halo, a galactic disk or a black hole etc. A component of each class may be of one or more differnt implementations of that component class. Component classes are extensions of the {\normalfont \ttfamily nodeComponent} base class, while each implementation is an extension of its component class (or, sometimes, of another implementation of that same class). Each component implementation type consists of a set of data\footnote{Data objects in components can be real, integer, boolean or of derived type. For derived types, currently {\normalfont \ttfamily history}, {\normalfont \ttfamily abundances}, {\normalfont \ttfamily chemicals}, and {\normalfont \ttfamily keplerOrbit} are supported. Adding additional derived types is possible, providing that the type supports the required methods for output, serialization, etc. Data objects can currently be scalar or rank-1 arrays.}, representing the properties (mass, size etc.) of the component, along with the rates of change (and ODE solver tolerances) for any properties which are evolvable. Additionally, each component contains a large number of methods (functions) which can be used to access its properties, query its interfaces and which are used internally to perform ODE evolution, output etc. The {\normalfont \ttfamily nodeComponent} base class and all classes derived from it are built automatically by {\normalfont \ttfamily Galacticus::Build::Components} at compile time (take a look in {\normalfont \ttfamily work/build/objects.nodes.components.Inc} if you want to see the generated code).

\subsection{Extending Components}

It is possible to create a component which extends an existing component (see the discussion of the {\normalfont \ttfamily extends} element in \S\ref{sec:ComponentDefinition}). This capability is intended to allow new properties to be added to a component without having to create a whole new copy of the component. It is \emph{not} intended to allow changes in the way in which the component is evolved through the halo hierarchy. (With the exception that rules to describe how the newly added properties will evolve through the halo hierarchy can be added of course.)

A simple example of this extension capability can be found in the {\normalfont \ttfamily scaleShape} dark matter profile component (\S\ref{sec:DarkMatterProfileScaleShape}), which extends the {\normalfont \ttfamily scale} dark matter profile component (\S\ref{sec:DarkMatterProfileScale}). In this case, the {\normalfont \ttfamily scaleShape} component adds a new property, {\normalfont \ttfamily shape}, and specifies how it is to be initialized, evolved, output, and change by node promotion events. It \emph{does not} affect how the {\normalfont \ttfamily scale} property, inherited from the {\normalfont \ttfamily scale} dark matter profile component, is evolved.

\subsection{Implementing a New Component}\label{sec:ComponentImplement}\index{components!implementing}

Implementing a new component involves writing some modules and functions which contain a definition of the component and, if necessary, handle initialization, creation, evolution, and responses to any events. Frequently, the easiest way to make a new component is to copy a previously existing one and modify it as needed. Details of the various functions that component modules must perform are given below.

By convention, a component's implementation is split into three or four files, although some components might not need all of these files. These files are named as follows (with {\normalfont \ttfamily \textless component\textgreater} acting as a placeholder for the name of the component in question):
\begin{description}
 \item [{\normalfont \ttfamily objects.nodes.components.\textless component\textgreater.F90}] The primary file which describes the component and its properties, and which contains functions that manipulate the component as it evolves through a merger tree (ODE rates, behavior during mergers, etc.);
 \item [{\normalfont \ttfamily objects.nodes.components.\textless component\textgreater.bound\_functions.F90}] Contains functions which will be bound to the component object (i.e. the {\normalfont \ttfamily nodeComponent\textless Class\textgreater\textless Implementation\textgreater} class), and so will be available as type bound procedures. Generally, these functions will include any which get or set values of properties in the component, those which return information about its internal state (such as the density at some position in the component; see \S\ref{sec:GalacticComponentDensity}), and any other functions which we may want to be overridden by extensions to the component.
 \item [{\normalfont \ttfamily objects.nodes.components.\textless component\textgreater.data.F90}] Contains any data which may need to be shared between the above two files. This might contain parameters which control some property of the component that is the same for all instances (e.g. if spheroids are modelled as S\'ersic profiles all with the same value of the S\'ersic index, that value might be placed into this file).
 \item [{\normalfont \ttfamily objects.nodes.components.\textless component\textgreater.structure.F90}] Contains any functions which implement the structure (e.g. density, rotation curve) of the component and which cannot be placed in {\normalfont \ttfamily objects.nodes.components.\textless component\textgreater.bound\_functions.Inc} due to dependencies on modules which in turn depend on the {\normalfont \ttfamily Galacticus\_Nodes} module.
\end{description}
In general, {\normalfont \ttfamily objects.nodes.components.\textless component\textgreater.F90} is the place for the component definition and functions which process the component during tree evolution (including output), while {\normalfont \ttfamily objects.nodes.components.\textless component\textgreater.bound\_functions.Inc} is intended for functions which record or report the internal state of the component.

\subsubsection{Component Definition}\label{sec:ComponentDefinition}

Component definition itself takes the form of an embedded XML document. The following example illustrates such a document:
\begin{verbatim}
  !# <component>
  !#  <class>disk</class>
  !#  <name>exponential</name>
  !#  <isDefault>yes</isDefault>
  !#  <properties>
  !#   <property>
  !#     <name>isInitialized</name>
  !#     <type>logical</type>
  !#     <rank>0</rank>
  !#     <attributes isSettable="true" isGettable="true" isEvolvable="false" />
  !#   </property>
  !#   <property>
  !#     <name>massStellar</name>
  !#     <type>real</type>
  !#     <rank>0</rank>
  !#     <attributes isSettable="true" isGettable="true" isEvolvable="true" />
  !#     <output unitsInSI="massSolar" comment="Mass of stars in the exponential disk."/>
  !#   </property>
  !#   <property>
  !#     <name>abundancesStellar</name>
  !#     <type>abundances</type>
  !#     <rank>0</rank>
  !#     <attributes isSettable="true" isGettable="true" isEvolvable="true" />
  !#     <output unitsInSI="massSolar" comment="Mass of metals in the stellar phase of the exponential disk."/>
  !#   </property>
  !#   <property>
  !#     <name>massGas</name>
  !#     <type>real</type>
  !#     <rank>0</rank>
  !#     <attributes isSettable="true" isGettable="true" isEvolvable="true" createIfNeeded="true" makeGeneric="true" />
  !#     <output unitsInSI="massSolar" comment="Mass of gas in the exponential disk."/>
  !#   </property>
  !#   <property>
  !#     <name>coolingMass</name>
  !#     <attributes isSettable="false" isGettable="false" isEvolvable="true" isDeferred="rate" bindsTo="top" />
  !#     <type>real</type>
  !#     <rank>0</rank>
  !#     <isVirtual>yes</isVirtual>
  !#   </property>
  !#   <property>
  !#     <name>halfMassRadius</name>
  !#     <attributes isSettable="false" isGettable="true" isEvolvable="false" />
  !#     <type>real</type>
  !#     <rank>0</rank>
  !#     <isVirtual>yes</isVirtual>
  !#     <getFunction>Node_Component_Disk_Exponential_Half_Mass_Radius</getFunction>
  !#   </property>
  !#   <property>
  !#     <name>luminositiesStellar</name>
  !#     <type>real</type>
  !#     <rank>1</rank>
  !#     <attributes isSettable="true" isGettable="true" isEvolvable="true" />
  !#     <classDefault modules="Stellar_Population_Properties_Luminosities" count="Stellar_Population_Luminosities_Count()">0.0d0</classDefault>
  !#     <output labels="':'//Stellar_Population_Luminosities_Name({i})" count="Stellar_Population_Luminosities_Count()" condition="Stellar_Population_Luminosities_Output({i},time)" modules="Stellar_Population_Properties_Luminosities" unitsInSI="luminosityZeroPointAB" comment="Luminosity of disk stars."/>
  !#   </property>
  !#  </properties>
  !#  <bindings>
  !#   <binding method="attachPipes" function="Node_Component_Disk_Exponential_Attach_Pipes" type="void" bindsTo="component" />
  !#  </bindings>
  !#  <functions>objects.nodes.components.disk.exponential.custom_methods.inc</functions>
  !# </component>
\end{verbatim}

The elements of this document have the following meaning:
\begin{description}
\item [{\normalfont \ttfamily class}] \emph{[Required]} Specifies the component class of which this is an implementation.
\item [{\normalfont \ttfamily name}] \emph{[Required]} Specifies the name of this specific implementation.
\item [{\normalfont \ttfamily extends}] \emph{[Optional]} If present, this element must contain {\normalfont \ttfamily class} and {\normalfont \ttfamily name} elements which specify the type of component which should be extended. The component then automatically inherits all properties and type-bound functions of the extended type.
\item [{\normalfont \ttfamily isDefault}] \emph{[Required]} Specifies whether or not this should be the default implementation of this class. Note that only one implementation of each class can be declared to be the default. If no implementation of a given class is declared to be the default then the (automatically generated) {\normalfont \ttfamily null} implementation will be made the default.
\item [{\normalfont \ttfamily properties}] \emph{[Optional]} Contains an array of {\normalfont \ttfamily property} elements which specify the properties of this implementation. Each member {\normalfont \ttfamily property} has the following structure:
\begin{description}
\item [{\normalfont \ttfamily name}] \emph{[Required]} The name of the property. 
\item [{\normalfont \ttfamily type}] \emph{[Required]} The type (one of {\normalfont \ttfamily real}, {\normalfont \ttfamily integer}, {\normalfont \ttfamily logical}, {\normalfont \ttfamily history}, {\normalfont \ttfamily abundances}, {\normalfont \ttfamily chemicals}, or {\normalfont \ttfamily keplerOrbit} at present) of the property.
\item [{\normalfont \ttfamily rank}] \emph{[Required]} The rank of this property (currently {\normalfont \ttfamily 0} for a scalar or {\normalfont \ttfamily 1} for a 1-D array).
\item [{\normalfont \ttfamily attributes}] \emph{[Required]} Attributes of this property:
\begin{description}
\item [{\normalfont \ttfamily isSettable}] If {\normalfont \ttfamily true} then the value of this property can be set directory.
\item [{\normalfont \ttfamily isGettable}] If {\normalfont \ttfamily true} then the value of this property can be got directory.
\item [{\normalfont \ttfamily isEvolvable}] If {\normalfont \ttfamily true} this property evolves as part of the \glc\ \gls{ode} system.
\item [{\normalfont \ttfamily createIfNeeded}] If {\normalfont \ttfamily true} then any attempt to get, set, or adjust the rate of this property will cause the component to be created if it does not already exist. This is useful if the component should be created in response to mass transfer from some other component for example.
\item [{\normalfont \ttfamily makeGeneric}] If {\normalfont \ttfamily true} then any {\normalfont \ttfamily rate} method for this property will have a version created which binds to the base {\normalfont \ttfamily nodeComponent} class. This version is suitable for attaching to deferred rate functions of components of another class. For example, the disk gas mass rate function is made generic, and then attached to the deferred cooling rate of the hot halo using:
\begin{verbatim}
  call hotHalo%hotHaloCoolingMassRateFunction(DiskExponentialMassGasRateGeneric)
\end{verbatim}
\item [{\normalfont \ttfamily isDeferred}] Contains a ``{\normalfont \ttfamily :}'' separated list which can contain {\normalfont \ttfamily get}, {\normalfont \ttfamily set}, and {\normalfont \ttfamily rate}. The methods present in this list will not have functions bound to them at compile time. Instead a function will be created which allows a function to be bound to these methods at run time. For example:
\begin{verbatim}
  call myComponent%massFunction    (My_Component_Mass_Get_Function)
  call myComponent%massSetFunction (My_Component_Mass_Set_Function)
  call myComponent%massRateFunction(My_Component_Mass_Rate_Function)
\end{verbatim}
Additionally, a method is created which returns true or false depending on whether the method has been attached to a function yet, e.g.
\begin{verbatim}
 myComponent%massIsAttached    ()
 myComponent%massSetIsAttached ()
 myComponent%massRateIsAttached()
\end{verbatim}
\item [{\normalfont \ttfamily bindsTo}] Specifies to which level in the class hierarchy set, get and rate methods should be bound. Normally, these are bound to the component implementation itself. However, it can be useful to specify a binding of ``{\normalfont \ttfamily top}'' to bind to the base {\normalfont \ttfamily nodeComponent} class to make these methods interoperable with properties of other classes (see the discussion of the {\normalfont \ttfamily makeGeneric} element above).
\end{description}
\item [{\normalfont \ttfamily output}] \emph{[Optional]} If present, the property will be included in the \glc\ output file. The following attributes control the details of that output:
\begin{description}
\item [{\normalfont \ttfamily unitsInSI}] The units of the output quantity in the SI system.
\item [{\normalfont \ttfamily comment}] A comment to be included with the HDF5 dataset for this property.
\item [{\normalfont \ttfamily condition}] A statement which must evaluate to {\normalfont \ttfamily true} or {\normalfont \ttfamily false} and which will be used to determine if the property will be output. The present output time for is available as {\normalfont \ttfamily time}. In the case of an array property the construct ``{\normalfont \ttfamily \{i\}}'' can be used to pass the index of the element for which the condition should be evaluated.
\item [{\normalfont \ttfamily modules}] A comma-separated list of any modules required to perform the output (e.g. modules which contain functions or values that are used).
\end{description}
Additional attributes are required for array properties:
\begin{description}
\item [{\normalfont \ttfamily labels}] This can be an array, declared as ``{\normalfont \ttfamily [$L_1$,\ldots,$L_N$]}'', specifying the suffix to be added to the property name for each component of the array in the output, or a function which returns the suffix. In the case of a function the construct ``{\normalfont \ttfamily \{i\}}'' can be used to pass the index of the element for which the suffix is required.
\item [{\normalfont \ttfamily count}] A statement which evaluates the the number of elements to be output (i.e. the length of the array).
\end{description}
\item [{\normalfont \ttfamily isVirtual}] \emph{[Optional]} If present and set to ``{\normalfont \ttfamily yes}'', this property is a virtual property. A virtual property has no data associated with it and must supply its own functions for getting, setting and adjusting its rate of change (if allowed by the property's attributes). Virtual properties are used for quantities which are derived from actual properties of the component implementation (for example, a star formation rate could be a virtual property if it is derived from an actual gas mass property) or for adjusting the rates of several actual properties simultaneously.
\item [{\normalfont \ttfamily getFunction}] \emph{[Optional]} Specifies the function to be used for getting the value of the property, overriding the default get function. The function must be included in the \hyperlink{objects.nodes.F90:galacticus_nodes}{\normalfont \ttfamily Galacticus\_Nodes} module by use of the {\normalfont \ttfamily functions} element described below. Note that this function, by virtue of its priveleged access to the itnernal structure of node components, can access the value of the data associated with the propery using:
\begin{verbatim}
myComponent%<property>Data%value
\end{verbatim}
\item [{\normalfont \ttfamily setFunction}] \emph{[Optional]} The same as {\normalfont \ttfamily getFunction} but defines a function to set the value of the property.
\item [{\normalfont \ttfamily classDefault}] \emph{[Optional]} Specifies the default value for this property if the component class has not been created (i.e. has no specific implementation yet). The content of this element gives the default value (which can be a scalar, an array, a function, etc.). Additional, optional attributes control the use of this element:
\begin{description}
 \item [{\normalfont \ttfamily modules}] Specifies a comma-separated list of modules which are required to set the default values (e.g. modules which contain the value or function to be used).
 \item [{\normalfont \ttfamily count}] For array properties whose size is not known at compile-time, it is possible to specify a function which will return the appropriate size of the array at run-time. The scalar default value given in the {\normalfont \ttfamily classDefault} element will then be replicated the appropriate number of times.
\end{description}
\end{description}
\item [{\normalfont \ttfamily bindings}] \emph{[Optional]} Contains an array of {\normalfont \ttfamily binding} elements which specify functions to bind to this implementation. Each member {\normalfont \ttfamily binding} has the following structure:
\begin{description}
\item [{\normalfont \ttfamily method}] The name of the bound method, such that the function can be accessed using
\begin{verbatim}
 myComponent%<method>(...)
\end{verbatim}
\item [{\normalfont \ttfamily function}] The function to which the method should be bound. (This function must be included in the \hyperlink{objects.nodes.F90:galacticus_nodes}{\normalfont \ttfamily Galacticus\_Nodes} module by use of the {\normalfont \ttfamily functions} element described below.
\item [{\normalfont \ttfamily type}] The type of function.
\item [{\normalfont \ttfamily bindsTo}] Specifies where this method should be bound. ``{\normalfont \ttfamily component}'' specifies binding to the specific implementation of this component class, ``{\normalfont \ttfamily componentClass}'' specifies binding to the component class, while ``{\normalfont \ttfamily top}'' specifies binding to the base {\normalfont \ttfamily nodeComponent} class.
\end{description}
\item [{\normalfont \ttfamily functions}] \emph{[Optional]} Contains the name of a file which will be included into the \hyperlink{objects.nodes.F90:galacticus_nodes}{\normalfont \ttfamily Galacticus\_Nodes} module. This file can contain functions which will be bound to this implementation. By virtue of being included in the \hyperlink{objects.nodes.F90:galacticus_nodes}{\normalfont \ttfamily Galacticus\_Nodes} module these functions have privelged access to the internal structure of all node component objects.
\end{description}

\subsubsection{Component Initialization}\index{components!initialization}

Initialization of a component module (if necessary, for example, to read parameters or allocate workspace) can occur at a number of different points in the execution of \glc. Providing initialization occurs in advance of any calculations then any point is acceptable. One possibility is simply to call an initialization function at the head of all functions defined in the component module. This initialization function should return immediately if it has already been called (to avoid duplicate initialization). Another option is to use the {\normalfont \ttfamily mergerTreePreTreeConstructionTask} event (see \S\ref{sec:MergerTreePreConstructionTask}) to perform initialization just before merger trees are constructed (the initialization function must again return immediately if it has been previously called).

Optionally, a component may include a {\normalfont \ttfamily mergerTreeEvolveThreadInitialize} directive, which gives the name of a subroutine in its {\normalfont \ttfamily unitName} element. The routine specified by {\normalfont \ttfamily mergerTreeEvolveThreadInitialize} is called by all threads prior to merger tree evolution, and can therefore be used to perform any ``per thread'' initialization. Note that this routine will be called many times during a given \glc\ run---it is the responsibility of the routine to ensure that it performs any initialization only once.

\subsubsection{Component Access, Creation and Destruction}\index{components!creation}\index{components!destruction}

When a node is created, it initially contains no components. A component must therefore create itself on the fly as needed. Typically, a component is first created when an attempt is made to set a property value, or to adjust the rate of change of a property value or in response to some event (e.g. a satellite component may be created in response to a node merging with a larger node). Requests for property values frequently \emph{do not} require that the component exist, as a zero value can often be returned instead\footnote{Or some other value if a {\normalfont \ttfamily classDefault} has been specified (see \S\ref{sec:ComponentImplement}).}.

To access a component from a node, use:
\begin{verbatim}
 myComponent => thisNode%<class>([instance=<N>,autoCreate=<create>])
\end{verbatim}
where {\normalfont \ttfamily class} is the component class required, the optional {\normalfont \ttfamily instance} argument requests a specific instance of the component (relevant if the node contains more than one of a particular component, e.g. if it contains two supermassive black holes for example; if no {\normalfont \ttfamily instance} is specified the first instance will be returned), and the {\normalfont \ttfamily autoCreate} option specifies whether or not the component should be automatically created (assuming it does not already exist). {\normalfont \ttfamily autoCreate}$=${\normalfont \ttfamily true} should be used to create components initially.

A component of a node can be destroyed using:
\begin{verbatim}
call thisNode%<class>Destroy()
\end{verbatim}

\subsubsection{Component Methods}\label{sec:ComponentMethods}\index{components!methods}

Component implementations optionally provide functions to get and set their properties (and to set the rate of change of evolvable properties) so that other components and functions within \glc\ to can interact with them in a way that is independent of the specific component implementation chosen. To permit this, \glc\ creates functions for each property to access it in all permitted ways. For example, the {\normalfont \ttfamily exponential} implementation of the {\normalfont \ttfamily disk} component class has a ``{\normalfont \ttfamily massStellar}'' property defined by:
\begin{verbatim}
 <method>
   <name>massStellar</name>
   <type>real</type>
   <rank>0</rank>
   <attributes isSettable="true" isGettable="true" isEvolvable="true" />
 </method>
\end{verbatim}
This causes \glc\ to define several functions bound to the {\normalfont \ttfamily nodeComponentDisk} class:
\begin{description}
\item [{\normalfont \ttfamily massStellarIsSettable}] Returns {\normalfont \ttfamily true} if this property is settable;
\item [{\normalfont \ttfamily massStellarIsGettable}] Returns {\normalfont \ttfamily true} if this property is gettable;
\item [{\normalfont \ttfamily massStellarSet}] Sets the value of this property to the supplied argument;
\item [{\normalfont \ttfamily massStellarGet}] Gets the value of this property;
\item [{\normalfont \ttfamily massStellarRate}] Cumulates its argument to the rate of change of this property;
\item [{\normalfont \ttfamily massStellarScale}] Sets the absolute scale for this property used in ODE error control;
\end{description}
along with several others used internally for output, serialization etc.

\subsubsection{Component Evolution}\label{sec:ComponentEvolution}\index{evolution}\index{components!evolution}

All component properties which have an {\normalfont \ttfamily isEvolvable} attribute set to {\normalfont \ttfamily true} are included in \glc's ODE solver as the node is evolved forward in time. As described in \S\ref{sec:ComponentMethods}, \glc\ will create two functions that permit the rate of change of a property adjusted and for the absolute scale used in ODE error control to be set.

A ``rate compute'' function should be defined to perform any calculations necessary to determine the rate of change of the property and adjust the rate appropriately. Below is an example of the rate compute subroutine for the stellar mass property of the exponential disk component, with only the basic structure shown:
\begin{lstlisting}[escapechar=@,breaklines,prebreak=\&,postbreak=\&]
  !# <rateComputeTask>
  !#  <unitName>Node_Component_Disk_Exponential_Rate_Compute</unitName>
  !# </rateComputeTask>
  subroutine Node_Component_Disk_Exponential_Rate_Compute(node,odeConverged,interrupt,interruptProcedure,propertyType)
    implicit none
    type     (treeNode             ), pointer, intent(inout) :: node
    logical                                  , intent(in   ) :: odeConverged
    logical                                  , intent(inout) :: interrupt
    procedure(                     ), pointer, intent(inout) :: interruptProcedure
    integer                                  , intent(in   ) :: propertyType
    class    (nodeComponentDisk    ), pointer                :: disk
 
    ! Get the disk and check that it is of our class.
    disk => node%disk()
    select type (disk)
    class is (nodeComponentDiskExponential)
      ...
      call disk%massStellarRate(stellarMassRate)
      ...
    end select
    return
  end subroutine Node_Component_Disk_Exponential_Rate_Comput
\end{lstlisting}
Here, we get the disk component and check that it of the {\normalfont \ttfamily exponential} variety. If it is, we compute the rates of change for one or more properties and then adjust their rates appropriately. If multiple instances of a component are used then the rate compute function should loop over all instances and adjust rates appropriately. The {\normalfont \ttfamily propertyType} argument will be set either to {\normalfont \ttfamily propertyTypeActive} or {\normalfont \ttfamily propertyTypeInactive}, and indicates if rates should be computed for active or inactive variables. (Rates for active variables can be computed and set even if inactive variables are requested, and vice versa. They will simply be ignored, and so this merely wastes compute time.) The {\normalfont \ttfamily odeConverged} variable indicates if the ODE solver has reached convergence---in some instances it is useful to trigger interrupts only once convergence is reached. If an interrupt occurs, {\normalfont \ttfamily interrupt} should be set to {\normalfont \ttfamily true}, and {\normalfont \ttfamily interruptProcedure} should be set to point to the function to call on interrupt.

When evolving ODEs the ODE solver aims to keep the error on property $i$ below
\begin{equation}
 D_i = \epsilon_\mathrm{abs} s_i + \epsilon_\mathrm{rel} |y_i|,
\end{equation}
where $epsilon_\mathrm{abs}=${\normalfont \ttfamily [odeToleranceAbsolute]}, $epsilon_\mathrm{rel}=${\normalfont \ttfamily [odeToleranceRelative]}, $y_i$ is the value of property $i$ and $s_i$ is a scaling factor which controls the absolute tolerance for this property. By default, $s_i=1$, but this can be changed for a component utilizing the {\normalfont \ttfamily scaleSetTask} directive. This allows a function to be called in which the component sets suitable scale factors for each of its properties prior to any ODE evolution being carried out. This can be very useful, for example, in cases where two components are coupled. Consider a case where a disk is transferring material to a spheroid via a bar instability. If the disk is orders of magnitude more massive that the spheroid then the rate of mass transfer can be very high (i.e. $\dot{y}/y$ for the spheroid will be large). With just a relative tolerance (i.e. the $\epsilon_\mathrm{rel} |y_i|$ term) this would require very short timesteps for the spheroid. However, in such cases we don't care about such tiny tolerances for the spheroid (since it will grow to be substantially more massive). Therefore, it may be appropriate to set $s_i$ to be equal to the sum of the disk and spheroid properties for example. The scale set directive and associated subroutine should follow this template:
\begin{verbatim}
  !# <scaleSetTask>
  !#  <unitName>Node_Component_Disk_Exponential_Scale_Set</unitName>
  !# </scaleSetTask>
  subroutine Node_Component_Disk_Exponential_Scale_Set(thisNode)
    implicit none
    type (treeNode         ), pointer, intent(inout) :: thisNode
    class(nodeComponentDisk), pointer                :: disk

    ! Get the disk component.
    disk => thisNode%disk()
    ! Check if an exponential disk component exists.
    select type (disk)
    class is (nodeComponentDiskExponential)
      ...
      call disk%massStellarScale(massScale)
      ...
    end select
    return
  end subroutine Node_Component_Disk_Exponential_Scale_Set
\end{verbatim}
Sensible choices for the $s_i$ factors can significantly speed-up execution of \glc.

\subsubsection{Evolution Interrupts}\index{interrupts}\index{evolution!interrupt}

It is often necessary to interrupt the smooth ODE evolution of a node in \glc. This can happen if, for example, a galaxy mergers with another galaxy (in which case the merger must be processed prior to further evolution) or if a component must be created before evolution can continue. The rate adjust and rate compute subroutines allow for interrupts to be flagged via their {\normalfont \ttfamily interrupt} and {\normalfont \ttfamily interruptProcedure} arguments. If an interrupt is required then {\normalfont \ttfamily interrupt} should be set to true, while {\normalfont \ttfamily interruptProcedure} should be set to point to a procedure which will handle the interrupt. Then, providing no other interrupt occurred earlier, the evolution will be stopped and the interrupt procedure called before evolution is continued.

An interrupt procedure should have the form:
\begin{lstlisting}[escapechar=@,breaklines,prebreak=\&,postbreak=\&]
  subroutine My_Interrupt_Procedure(thisNode)
    implicit none
    type(treeNode), pointer, intent(inout) :: thisNode
  
    ! Do whatever needs to be done to handle the interrupt.

    return
  end subroutine My_Interrupt_Procedure
\end{lstlisting}

\section{Existing Method Types}

\subsection{Functions}

Functions implement basic calculations (e.g. computing the power spectrum).

\IfFileExists{./autoMethods.tex}{\input{autoMethods}}{}

\subsubsection{Accretion Disks}\label{sec:AccretionDisks}

Additional methods for accretion disk properties can be added using the {\normalfont \ttfamily accretionDisksMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily Shakura-Sunyae} method is described by a directive:
\begin{verbatim}
 !# <accretionDisksMethod>
 !#  <unitName>Accretion_Disks_Shakura_Sunyaev_Initialize</unitName>
 !# </accretionDisksMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Accretion\_Disks\_Shakura\_Sunyaev\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(accretionDisksMethod,Accretion_Disk_Radiative_Efficiency_Get,Black_Hole_Spin_Up_Rate_Get,Accretion_Disk_Jet_Power_Get)
    implicit none
    type(varying_string),          intent(in)    :: accretionDisksMethod
    procedure(),          pointer, intent(inout) :: Accretion_Disk_Radiative_Efficiency_Get,Black_Hole_Spin_Up_Rate_Get,Accretion_Disk_Jet_Power_Get
    
    if (accretionDisksMethod == 'myMethod') then
       Accretion_Disk_Radiative_Efficiency_Get => My_Accretion_Disk_Radiative_Efficiency_Get
       Black_Hole_Spin_Up_Rate_Get             => My_Black_Hole_Spin_Up_Rate_Get
       Accretion_Disk_Jet_Power_Get            => My_Accretion_Disk_Jet_Power_Get
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily accretionDisksMethod} input parameter. The procedure pointers {\normalfont \ttfamily Accretion\_Disk\_Radiative\_Efficiency\_Get}, {\normalfont \ttfamily Black\_Hole\_Spin\_Up\_Rate\_Get} and {\normalfont \ttfamily Accretion\_Disk\_Jet\_Power\_Get} must be set to point to functions which return the radiative efficiency, black hole spin up rate and jet power for the accretion disk respectively as described below. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The radiative efficiency function must have the form:
\begin{verbatim}
 double precision function My_Accretion_Disk_Radiative_Efficiency_Get(thisNode,massAccretionRate)
    implicit none
    type(treeNode),   intent(inout), pointer :: thisNode
    double precision, intent(in)             :: massAccretionRate
    .
    .
    .
    return
 end function My_Accretion_Disk_Radiative_Efficiency_Get
\end{verbatim}
The function must return the radiative efficiency for the accretion disk in {\normalfont \ttfamily thisNode}. The black hole spin function must have the form:
\begin{verbatim}
 double precision function My_Black_Hole_Spin_Up_Rate_Get(thisNode,massAccretionRate)
    implicit none
    type(treeNode),   intent(inout), pointer :: thisNode
    double precision, intent(in)             :: massAccretionRate
    .
    .
    .
    return
 end function My_Black_Hole_Spin_Up_Rate_Get
\end{verbatim}
The function must return the spin-up rate for the black hole in {\normalfont \ttfamily thisNode} given the {\normalfont \ttfamily massAccretionRate}. The jet power function must have the form:
\begin{verbatim}
 double precision function My_Accretion_Disk_Jet_Power_Get(thisNode,massAccretionRate)
    implicit none
    type(treeNode),   intent(inout), pointer :: thisNode
    double precision, intent(in)             :: massAccretionRate
    .
    .
    .
    return
 end function My_Accretion_Disk_Jet_Power_Get
\end{verbatim}
The function must return (in units of $M_\odot$ (km/s)$^2$ Gyr$^{-1}$) the jet power for the black hole/accretion disk system in {\normalfont \ttfamily thisNode} given the {\normalfont \ttfamily massAccretionRate}.

Currently defined accretion disk methods are:
\begin{description}
 \item [{\normalfont \ttfamily Shakura-Sunyaev}] Computes the properties of a thin, radiatively efficiency accretion disk.
 \item [{\normalfont \ttfamily ADAF}] Computes the properties of an ADAF using the model of \cite{benson_maximum_2009}.
 \item [{\normalfont \ttfamily switched}] Select either {\normalfont \ttfamily Shakura-Sunyaev} or {\normalfont \ttfamily ADAF} accretion disks based on the accretion rate:
 \begin{eqnarray}
  \dot{m}_\mathrm{minimum} < \dot{M}_{\bullet, 0}/\dot{M}_\mathrm{Eddington} < \dot{m}_\mathrm{maximum} &\rightarrow& \hbox{ Shakura-Sunyaev} \nonumber \\
  \hbox{otherwise } &\rightarrow& \hbox{ ADAF},
 \end{eqnarray}
 where $\dot{m}_\mathrm{minimum}$={\normalfont \ttfamily accretionRateThinDiskMinimum} and $\dot{m}_\mathrm{maximum}$={\normalfont \ttfamily accretionRateThinDiskMaximum} are input parameters.
 \item [{\normalfont \ttfamily eddingtonLimited}] Assumes no specific disk structure, instead setting the radiative efficiency to a fixed number and the jet power to a fixed fraction of the Eddington luminosity.
\end{description}

\subsubsection{Analysis}

Additional methods for on-the-fly analysis of merger trees can be added using the {\normalfont \ttfamily mergerTreeAnalysisTask} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the mass distributions method is described by a directive:
\begin{verbatim}
 !# <mergerTreeAnalysisTask>
 !#  <unitName>Galacticus_Output_Analysis_Mass_Dpndnt_Sz_Dstrbtins</unitName>
 !# </mergerTreeAnalysisTask>
\end{verbatim}
Here, {\normalfont \ttfamily Galacticus\_Output\_Analysis\_Mass\_Dpndnt\_Sz\_Dstrbtins} is the name of a subroutine which will be called to perform the analysis. The analysis subroutine must have the following form:
\begin{verbatim}
  subroutine Tree_Analyze(thisTree,thisNode,iOutput,mergerTreeAnalyses)
    implicit none
    type            (mergerTree    ), intent(in   )                 :: thisTree
    type            (treeNode      ), intent(inout), pointer        :: thisNode
    integer                         , intent(in   )                 :: iOutput
    type            (varying_string), intent(in   ), dimension(:  ) :: mergerTreeAnalyses
    .
    .
    .
    return
  end subroutine Method_Initialize
\end{verbatim}
This function will be called once for each node in each tree being output. The function is passed the merger tree object as {\normalfont \ttfamily thisTree}, along with a pointer to the node to be analyzed as {\normalfont \ttfamily thisNode}. Additionally, the current output number is passed as {\normalfont \ttfamily iOutput}. Finally, a list of analyses that were requested (by user input) to be performed is given in the {\normalfont \ttfamily mergerTreeAnalyses} array. The function should check if one or more of the entries in {\normalfont \ttfamily mergerTreeanalyses} correspond to analyses that it performs. (Note that this need only be done on the first call to this function---the values of {\normalfont \ttfamily mergerTreeAnalyses} will not change between calls.) If an analysis is matched in this way it should be performed. Typically, an analysis function might accumulate the results of analysis and then finalize and output them prior to completion of the \glc\ model through the use of a {\normalfont \ttfamily hdfPreCloseTask} (see \S\ref{sec:HDFFileClose}).

Currently defined merger tree analysis methods are (see \S\ref{sec:OnTheFlyAnalysis}):
\begin{description}
 \item [mass functions] Constructs mass functions for a variety of different surveys. Currently supported analysis names are: {\normalfont \ttfamily sdssStellarMassFunctionZ0.07}, {\normalfont \ttfamily alfalfaHiMassFunctionZ0.00}, {\normalfont \ttfamily primusStellarMassFunctionZ0.100}, {\normalfont \ttfamily primusStellarMassFunctionZ0.250}, {\normalfont \ttfamily primusStellarMassFunctionZ0.350}, {\normalfont \ttfamily primusStellarMassFunctionZ0.450}, {\normalfont \ttfamily primusStellarMassFunctionZ0.575}, {\normalfont \ttfamily primusStellarMassFunctionZ0.725}, and {\normalfont \ttfamily primusStellarMassFunctionZ0.900}. Each such analysis is defined internally to this module through the appropriate redshift, binning, random and systematic errors, and arbitrary mapping of component masses into observed masses. The covariance matrix of the mass function is also computed (see \S\ref{sec:AnalysisALFALFAHIMassFunction} for details).
 \item [mass-dependent size distributions] Constructs a two-dimensional histogram of galaxy sizes in bins of stellar mass. Currently supported analyses are {\normalfont \ttfamily sdssSizeFunctionZ0.07}. Each such analysis is defined internally to this module through the appropriate redshift, binning, random and systematic errors, and arbitrary mapping of component masses/radii into observed masses/radii. The covariance matrix of the size function is also computed (see \S\ref{sec:SDSSLateTypeGalaxySizeDistribution} for details).
\end{description}

\subsubsection{Atomic Photoionization Cross-Sections}

Additional methods for atomic photoionization cross-section calculations can be added using the {\normalfont \ttfamily atomicPhotoIonizationMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily Verner} method is described by a directive:
\begin{verbatim}
 !# <atomicPhotoIonizationMethod>
 !#  <unitName>Atomic_Cross_Section_Ionization_Photo_Verner_Initialize</unitName>
 !# </atomicPhotoIonizationMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Atomic\_Cross\_Section\_Ionization\_Photo\_Verner\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(atomicPhotoIonizationMethod,Atomic_Cross_Section_Ionization_Photo_Get)
    implicit none
    type(varying_string),          intent(in)    :: atomicPhotoIonizationMethod
    procedure(),          pointer, intent(inout) :: Atomic_Cross_Section_Ionization_Photo_Get
    
    if (atomicPhotoIonizationMethod == 'myMethod') Atomic_Cross_Section_Ionization_Photo_Get => My_Method_Get_Procedure
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily atomicPhotoIonizationMethod} input parameter. The procedure pointer {\normalfont \ttfamily Atomic\_Cross\_Section\_Ionization\_Photo\_Get} must be set to point to a function which returns the cross-section (in units of cm$^2$) for photoionization. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The cross-section function must have the form:
\begin{verbatim}
 double precision function My_Method_Get_Procedure(atomicNumber,ionizationState,shellNumber,wavelength)
    implicit none
    integer,          intent(in) :: atomicNumber,ionizationState,shellNumber
    double precision, intent(in) :: wavelength
    .
    .
    .
    return
 end function My_Method_Get_Procedure
\end{verbatim}
The function must return the cross-section for photoionization (in units of cm$^2$) of electrons in the specified {\normalfont \ttfamily shellNumber} for ions of the given {\normalfont \ttfamily atomicNumber} and {\normalfont \ttfamily ionizationState} (where ionization state is the atomic number plus 1 minus the number of electrons) at the specified {\normalfont \ttfamily wavelength} (given in units of \AA).

Currently defined photoionization cross-section methods are:
\begin{description}
 \item [{\normalfont \ttfamily Verner}]  Computes the cross-sections by use of the fits from \citeauthor{verner_atomic_1996_1}~(\citeyear{verner_atomic_1996_1}; Version 2, March 25, 1996).
\end{description}

\subsubsection{Atomic Radiative Recombination Rates}

Additional methods for atomic radiative recombination rate calculations can be added using the {\normalfont \ttfamily atomicRadiativeRecombinationMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily Verner} method is described by a directive:
\begin{verbatim}
 !# <atomicRadiativeRecombinationMethod>
 !#  <unitName>Atomic_Rate_Recombination_Radiative_Verner_Initialize</unitName>
 !# </atomicRadiativeRecombinationMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Atomic\_Rate\_Recombination\_Radiative\_Verner\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(atomicRadiativeRecombinationMethod,Atomic_Rate_Recombination_Radiative_Get)
    implicit none
    type(varying_string),          intent(in)    :: atomicRadiativeRecombinationMethod
    procedure(),          pointer, intent(inout) :: Atomic_Rate_Recombination_Radiative_Get
    
    if (atomicRadiativeRecombinationMethod == 'myMethod') Atomic_Rate_Recombination_Radiative_Get => My_Method_Get_Procedure
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily atomicRadiativeRecombinationMethod} input parameter. The procedure pointer {\normalfont \ttfamily Atomic\_Rate\_Recombination\_Radiative\_Get} must be set to point to a function which returns the rate coefficient of atomic radiative recombination under given physical conditions. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The radiative recombination rate function must have the form:
\begin{verbatim}
 double precision function My_Method_Get_Procedure(atomicNumber,ionizationState,temperature)
    implicit none
    integer,          intent(in) :: atomicNumber,ionizationState
    double precision, intent(in) :: temperature
    .
    .
    .
    return
 end function My_Method_Get_Procedure
\end{verbatim}
The function must return the radiative recombination rate coefficient (in units of cm$^3$ s$^{-1}$) to ions of the given {\normalfont \ttfamily atomicNumber}, {\normalfont \ttfamily ionizationState} (where ionization state is the atomic number plus 1 minus the number of electrons) and {\normalfont \ttfamily temperature}.

Currently defined radiative recombination rate methods are:
\begin{description}
 \item [{\normalfont \ttfamily Verner}]  Computes the rate coefficient of radiative recombination using the compilation of results from Dima Verner as originally encapsulated in \href{ftp://gradj.pa.uky.edu//dima//rec//rrfit.f}{{\normalfont \ttfamily rrfit.f}}.
\end{description}

\subsubsection{Bar Instabilities}

Additional methods for bar instabilities in disks can be added using the {\normalfont \ttfamily barInstabilityMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily ELN} method is described by a directive:
\begin{verbatim}
 !# <barInstabilityMethod>
 !#  <unitName>Galactic_Dynamics_Bar_Instabilities_ELN_Initialize</unitName>
 !# </barInstabilityMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Galactic\_Dynamics\_Bar\_Instabilities\_ELN\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(barInstabilityMethod,Bar_Instability_Timescale_Get)
    implicit none
    type(varying_string),          intent(in)    :: barInstabilityMethod
    procedure(),          pointer, intent(inout) :: Bar_Instability_Timescale_Get
    
    if (barInstabilityMethod == 'myMethod') then
       Bar_Instability_Timescale_Get => My_Bar_Instability_Timescale_Get
       .
       .
       .
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily barInstabilityMethod} input parameter. The procedure pointer {\normalfont \ttfamily Bar\_Instability\_Timescale\_Get} must be set to point to a function which returns the timescale on which the bar instability depletes material from the disk to the pseudo-bulge. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The bar instability timesacale function must have the form:
\begin{verbatim}
  subroutine My_Bar_Instability_Timescale(thisNode,barInstabilityTimeScale,barInstabilityExternalDrivingSpecificTorque)
    implicit none
    type            (treeNode), intent(inout), pointer :: thisNode
    double precision          , intent(  out)          :: barInstabilityTimeScale,barInstabilityExternalDrivingSpecificTorque
    .
    .
    .
    return
  end subroutine My_Bar_Instability_Timescale
\end{verbatim}
The function should compute and return, in {\normalfont \ttfamily barInstabilityTimeScale} the timescale (in Gyr) for the bar instability in the disk in {\normalfont \ttfamily thisNode} to transfer material from the disk to the pseudo-bulge. If no instability is present, a negative timescale should be returned. Additionally, any specific torque external to the galaxy driving the instability should be returned in {\normalfont \ttfamily barInstabilityExternalDrivingSpecificTorque}.

Currently defined bar instability methods are:
\begin{description}
 \item [{\normalfont \ttfamily null}] A null method in which disks are never bar unstable;
 \item [{\normalfont \ttfamily ELN}] The bar instability is determined using the algorithm of \cite{efstathiou_stability_1982}.
 \item [{\normalfont \ttfamily ELN+tidal}] The bar instability is determined using the algorithm of \cite{efstathiou_stability_1982} with an additional term to account for an external tidal field.
\end{description}

\subsubsection{Black Hole Binaries: Initial Separation}

Additional methods for black hole binary initial separation calculations can be added using the {\normalfont \ttfamily blackHoleBinaryInitialRadiiMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily spheroidRadiusFraction} method is described by a directive:
\begin{verbatim}
 !# <blackHoleBinaryInitialRadiiMethod>
 !#  <unitName>Black_Hole_Binary_Initial_Radii_Spheroid_Size_Initialize</unitName>
 !# </blackHoleBinaryInitialRadiiMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Black\_Hole\_Binary\_Initial\_Radii\_Spheroid\_Size\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(blackHoleBinaryInitialRadiiMethod,Black_Hole_Binary_Initial_Radius_Get)
    implicit none
    type(varying_string),          intent(in)    :: blackHoleBinaryInitialRadiiMethod
    procedure(),          pointer, intent(inout) :: Black_Hole_Binary_Initial_Radius_Get
    
    if (blackHoleBinaryInitialRadiiMethod == 'myMethod') Black_Hole_Binary_Initial_Radius_Get => My_Method_Get
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily blackHoleBinaryInitialRadiiMethod} input parameter. The procedure pointer {\normalfont \ttfamily Black\_Hole\_Binary\_Initial\_Radius\_Get} must be set to point to a function which returns the initial separation of a just-formed black hole binary. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The initial separation function must have the form:
\begin{verbatim}
 double precision function My_Method_Get(thisNode,hostNode)
    implicit none
    type(treeNode), intent(inout), pointer :: thisNode,hostNode
    .
    .
    .
    return
 end subroutine My_Method_Get
\end{verbatim}
The function must return the initial separation (in Mpc) of the active black hole in {\normalfont \ttfamily thisNode} as it merges into {\normalfont \ttfamily hostNode}.

Currently defined black hole binary initial separation methods are:
\begin{description}
 \item [{\normalfont \ttfamily spheroidRadiusFraction}] Assumes that the initial separation is equal to a fraction {\normalfont \ttfamily [blackHoleInitialRadiusSpheroidRadiusRatio]} of the larger of the spheroid scale radii in {\normalfont \ttfamily thisNode} and {\normalfont \ttfamily hostNode}.
 \item [{\normalfont \ttfamily Volonteri2003}] Assumes that the initial separation follows the relationship described in \cite{volonteri_assembly_2003} following the black hole masses in {\normalfont \ttfamily thisNode} and {\normalfont \ttfamily hostNode}.
\item [{\normalfont \ttfamily tidalRadius}] Solves the radius at which the satellite galaxy is stripped of its stars, and assume only the central black hole remains, at that specific radius. This uses the masses in {\normalfont \ttfamily thisNode} and {\normalfont \ttfamily hostNode}.
\end{description}

\subsubsection{Black Hole Binaries: Separation Growth Rate}\label{sec:SMBHRadialMotion}

Additional methods for black hole binary separation growth rate calculations can be added using the {\normalfont \ttfamily blackHoleBinarySeparationGrowthRateMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily Volonteri2003} method is described by a directive:

\begin{verbatim}
  !# <blackHoleBinarySeparationGrowthRateMethod>
  !#  <unitName>Black_Hole_Binary_Separation_Growth_Rate_Standard_Init</unitName>
  !# </blackHoleBinarySeparationGrowthRateMethod>
\end{verbatim}

Currently defined black hole binary separation growth rate methods are:
\begin{description}
 \item [{\normalfont \ttfamily null}] Assumes that the initial separation stays constant.
 \item [{\normalfont \ttfamily standard}] Assumes that the separation growth rate follows \cite{volonteri_assembly_2003} following the black hole masses in {\normalfont \ttfamily thisNode}. Although it innovates as it encompasses all three influences: Dynamical Friction, Hardening due to stars and finally due to Gravitational Wave expulsion. Dynamical friction here occurs until a certain hardening separation is reached, it then is replaced by the (faster) three-body interactions with stars.
\end{description}

\subsubsection{Black Hole Binaries: Recoil Velocity}

Additional methods for the recoil velocity of a binary black hole can be added using the {\normalfont \ttfamily blackHoleBinaryRecoilVelocityMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily Standard} method is described by a directive:

\begin{verbatim}
  !# <blackHoleBinaryRecoilVelocityMethod>
  !#  <unitName>Black_Hole_Binary_Recoil_Velocity_Standard_Initialize</unitName>
  !# </blackHoleBinaryRecoilVelocityMethod>
\end{verbatim}

Currently defined black hole binary recoil velocity methods are:
\begin{description}
 \item [{\normalfont \ttfamily null}] Assumes that there is zero recoil velocity.
 \item [{\normalfont \ttfamily Campanelli2008}] Assumes that the recoil velocity follows \cite{campanelli_large_2007}, utilizing the black hole masses and spins in {\normalfont \ttfamily thisNode}. For now it does not take the direction of the spin into account, and assumes a zero perpendicular velocity.
\end{description}

\subsubsection{Black Hole Binaries: Mergers}\label{sec:BlackHoleBinaryMergers}

Additional methods for black hole binary merger calculations can be added using the {\normalfont \ttfamily blackHoleBinaryMergersMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily Rezzolla2008} method is described by a directive:
\begin{verbatim}
 !# <blackHoleBinaryMergersMethod>
 !#  <unitName>Black_Hole_Binary_Merger_Initialize</unitName>
 !# </blackHoleBinaryMergersMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Black\_Hole\_Binary\_Merger\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(blackHoleBinaryMergersMethod,Black_Hole_Binary_Merger_Do)
    implicit none
    type(varying_string),          intent(in)    :: blackHoleBinaryMergersMethod
    procedure(),          pointer, intent(inout) :: Black_Hole_Binary_Merger_Do
    
    if (blackHoleBinaryMergersMethod == 'myMethod') Black_Hole_Binary_Merger_Do => My_Method_Do_Procedure
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily blackHoleBinaryMergersMethod} input parameter. The procedure pointer {\normalfont \ttfamily Black\_Hole\_Binary\_Merger\_Do} must be set to point to a function which returns the properties (mass and spin) of the merged black hole as described below. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The cooling radius function must have the form:
\begin{verbatim}
 subroutine My_Method_Do_Procedure(blackHoleMassA,blackHoleMassB,blackHoleSpinA,blackHoleSpinB,blackHoleMassFinal,blackHoleSpinFinal)
    implicit none
    double precision, intent(in)  :: blackHoleMassA,blackHoleMassB,blackHoleSpinA,blackHoleSpinB
    double precision, intent(out) :: blackHoleMassFinal,blackHoleSpinFinal
    .
    .
    .
    return
 end subroutine My_Method_Do_Procedure
\end{verbatim}
The function must return the mass and spin (in {\normalfont \ttfamily blackHoleMassFinal} and {\normalfont \ttfamily blackHoleSpinFinal} respectively) of the black hole resulting from the merger of black holes with masses {\normalfont \ttfamily blackHoleMassA} and {\normalfont \ttfamily blackHoleMassB} and spins {\normalfont \ttfamily blackHoleSpinA} and {\normalfont \ttfamily blackHoleSpinB}. The subroutine should make no assumptions about the mass ordering of the input black holes (i.e. A could be more massive than B or vice versa).

Currently defined black hole binary merger methods are:
\begin{description}
 \item [{\normalfont \ttfamily Rezzolla2008}] Computes the properties of the merged black hole using the approximations of \cite{rezzolla_final_2008}.
\end{description}

\subsubsection{Conditional Mass Functions}

Additional methods for empirical conditional mass functions can be added using the {\normalfont \ttfamily conditionalMassFunctionMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily Behroozi2010} method is described by a directive:
\begin{verbatim}
  !# <conditionalMassFunctionMethod>
  !#  <unitName>Conditional_Mass_Functions_Behroozi2010_Initialize</unitName>
  !# </conditionalMassFunctionMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Conditional\_Mass\_Functions\_Behroozi2010\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(conditionalMassFunctionMethod&
       &,Cumulative_Conditional_Mass_Function_Get,Cumulative_Conditional_Mass_Function_Var_Get)
    implicit none
    type(varying_string),                 intent(in)    :: conditionalMassFunctionMethod
    procedure(double precision), pointer, intent(inout) :: Cumulative_Conditional_Mass_Function_Get,Cumulative_Conditional_Mass_Function_Var_Get
    
    if (conditionalMassFunctionMethod == 'myMethod') then
       Cumulative_Conditional_Mass_Function_Get     => My_Cumulative_Conditional_Mass_Function
       Cumulative_Conditional_Mass_Function_Var_Get => My_Cumulative_Conditional_Mass_Function_Var
       .
       .
       .
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily timePerTreeMethod} input parameter. The procedure pointer {\normalfont \ttfamily Galacticus\_Time\_Per\_Tree\_Get} must be set to point to a function which returns an estimate of the time taken (in seconds) to process a merger tree. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The functionw must have the form:
\begin{verbatim}
   double precision function My_Cumulative_Conditional_Mass_Function(massHalo,mass)
    implicit none
    double precision, intent(in) :: massHalo,mass
    .
    .
    .
    return
   end function My_Cumulative_Conditional_Mass_Function_Var

   double precision My_Cumulative_Conditional_Mass_Function_Var(massHalo,massLow,massHigh)
    implicit none
    double precision, intent(in) :: massHalo,massLow,massHigh
    .
    .
    .
    return
   end function My_Cumulative_Conditional_Mass_Function_Var 
\end{verbatim}
The first function must return the number of galaxies of mass greater than {\normalfont \ttfamily mass} in halos of mass {\normalfont \ttfamily massHalo}. The second function should return the variance in the number of galaxies in the mass range {\normalfont \ttfamily massLow} to {\normalfont \ttfamily massHigh} in halos of mass {\normalfont \ttfamily massHalo}

Currently defined tree timing methods are:
\begin{description}
 \item [{\normalfont \ttfamily Behroozi2010}] This method uses the fitting function of \cite{behroozi_comprehensive_2010} to compute the conditional mass function. To compute the variance in the mass function, this method assumes that the number of satellite galaxies follows a Poisson distribution, while central galaxies follow a \gls{Bernoulli distribution}.
\end{description}

\subsubsection{Cosmological Mass Root Variance}

Additional methods for computing the cosmological mass root variance, $\sigma(M)$, can be added using the {\normalfont \ttfamily cosmologicalMassVarianceMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily filteredPowerSpectrum} method is described by a directive:
\begin{verbatim}
  !# <cosmologicalMassVarianceMethod>
  !#  <unitName>Cosmological_Mass_Variance_Filtered_Power_Spectrum_Initialize</unitName>
  !# </cosmologicalMassVarianceMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Cosmological\_Mass\_Variance\_Filtered\_Power\_Spectrum\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(cosmologicalMassVarianceMethod,Cosmological_Mass_Variance_Tabulate)
    implicit none
    type     (varying_string),          intent(in   ) :: cosmologicalMassVarianceMethod
    procedure(               , pointer, intent(inout) :: Cosmological_Mass_Variance_Tabulate
    
    if (cosmologicalMassVarianceMethod == 'myMethod') then
       Cosmological_Mass_Variance_Tabulate => My_Method_Tabulate
       .
       .
       .
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily cosmologicalMassVarianceMethod} input parameter. The procedure pointer {\normalfont \ttfamily Cosmological\_Mass\_Variance\_Tabulate} must be set to point to a function which populates a {\normalfont \ttfamily table1D} object with a tabulation of $\sigma(M)$. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The tabulation function must have the form:
\begin{verbatim}
   subroutine Cosmological_Mass_Variance_Filtered_Power_Spectrum(mass,massNormalization,sigmaNormalization,sigmaTable)
    implicit none
    double precision         , intent(in   )              :: mass,massNormalization
    double precision         , intent(inout)              :: sigmaNormalization
    class           (table1D), intent(inout), allocatable :: sigmaTable
    .
    .
    return
   end subroutine Cosmological_Mass_Variance_Filtered_Power_Spectrum
\end{verbatim}
The function should allocate {\normalfont \ttfamily sigmaTable} to a suitable type of {\normalfont \ttfamily table1D} object and populate it with a tabulation of $\sigma(M)$ which includes the given {\normalfont \ttfamily mass}. On input, the required normalization of $\sigma(M)$ at mass {\normalfont \ttfamily massNormalization} is given by {\normalfont \ttfamily sigmaNormalization}. The function should divide this value by the unnormalized value of $\sigma(M)$---this is used to normalize the cosmological power spectrum.

Currently defined cosmological mass root variance methods are:
\begin{description}
 \item [{\normalfont \ttfamily filteredPowerSpectrum}] The mass root variance is found by integrating over the transferred linear power spectrum multiplied by the selected window function (see \S\ref{sec:methodsPowerSpectrumWindowFunction}).
\end{description}

\subsubsection{Excursion Set Barrier}\label{sec:excursionSetBarrierMethod}

Additional methods for the excursion set barrier can be added using the {\normalfont \ttfamily excursionSetBarrierMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily linear} method is described by a directive:
\begin{verbatim}
 !# <excursionSetBarrierMethod>
 !#  <unitName>Excursion_Sets_Barriers_Linear_Initialize</unitName>
 !# </excursionSetBarrierMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Excursion\_Sets\_Barriers\_Linear\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(excursionSetBarrierMethodExcursion_Sets_Barrier_Get,Excursion
_Sets_Barrier_Gradient_Get,barrierName)
    implicit none
    type     (varying_string  ),         intent(in   ) :: excursionSetBarrierMethod
    procedure(double precision),pointer, intent(inout) :: Excursion_Sets_Barrier_Get,Excursion_Sets_Barrier_Gradient
_Get
    type(varying_string),                intent(inout) :: barrierName

    if (excursionSetBarrierMethod == 'myMethod') then
      Excursion_Sets_Barrier_Get          => My_Barrier
      Excursion_Sets_Barrier_Gradient_Get => My_Barrier_Gradient
      barrierName=barrierName//":myLabel"
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily excursionSetBarrierMethod} input parameter. The procedure pointers {\normalfont \ttfamily Excursion\_Sets\_Barrier\_Get}, and {\normalfont \ttfamily Excursion\_Sets\_Barrier\_Gradient\_Get} must be set to point functions which return the barrier and its gradient respectively, as described below. The initialization subroutine should also append a descriptive label to the {\normalfont \ttfamily barrierName} argument. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The barrier and barrier gradient functions must have the form:
\begin{verbatim}
 double precision function Excursion_Sets_Barrier(variance,time)
    implicit none
    double precision, intent(in) :: variance,time
    .
    .
    .
    return
 end function Excursion_Sets_Barrier
\end{verbatim}
The barrier function must return the barrier at the specified {\normalfont \ttfamily variance} and {\normalfont \ttfamily time}, while the barrier gradient function should return the derivative with respect to variance of the same barrier.

Currently defined excursion set barrier methods are:
\begin{description}
 \item [{\normalfont \ttfamily linear}] A linear ($1^\mathrm{st}$-order polynomial) barrier;
  \item [{\normalfont \ttfamily quadratic}] A quadratic ($2^\mathrm{nd}$-order polynomial);
  \item [{\normalfont \ttfamily criticalOverdensity}] A barrier equal to the critical overdensity for halo collapse.
\end{description}

\subsubsection{Excursion Set Barrier First Crossing Distribution}\label{sec:excursionSetFirstCrossingMethod}

Additional methods for the excursion set barrier first crossing distribution can be added using the {\normalfont \ttfamily excursionSetFirstCrossingMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily linearBarrier} method is described by a directive:
\begin{verbatim}
 !# <excursionSetFirstCrossingMethod>
 !#  <unitName>Excursion_Sets_First_Crossing_Linear_Barrier_Initialize</unitName>
 !# </excursionSetFirstCrossingMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Excursion\_Sets\_First\_Crossing\_Linear\_Barrier\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(excursionSetFirstCrossingMethod,Excursion_Sets_First_Crossing_Probability_Get&
         &,Excursion_Sets_First_Crossing_Rate_Get,Excursion_Sets_Non_Crossing_Rate_Get)
    implicit none
    type     (varying_string  ),         intent(in   ) :: excursionSetFirstCrossingMethod
    procedure(double precision),pointer, intent(inout) :: Excursion_Sets_First_Crossing_Probability_Get&
         &,Excursion_Sets_First_Crossing_Rate_Get,Excursion_Sets_Non_Crossing_Rate_Get
    
    if (excursionSetFirstCrossingMethod == 'myMethod') then
       Excursion_Sets_First_Crossing_Probability_Get => My_First_Crossing_Probability
       Excursion_Sets_First_Crossing_Rate_Get        => My_First_Crossing_Rate
       Excursion_Sets_Non_Crossing_Rate_Get          => My_Non_Crossing_Rate
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily excursionSetFirstCrossingMethod} input parameter. The procedure pointers {\normalfont \ttfamily Excursion\_Sets\_First\_Crossing\_Probability\_Get}, {\normalfont \ttfamily Excursion\_Sets\_First\_Crossing\_Rate\_Get}, and {\normalfont \ttfamily Excursion\_Sets\_Non\_Crossing\_Rate\_Get} must be set to point functions which return the first crossing probability, first crossing probability rate and noncrossing rate as described below. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The first crossing probability function must have the form:
\begin{verbatim}
 double precision function Excursion_Sets_First_Crossing_Probability(variance,time)
    implicit none
    double precision, intent(in) :: variance,time
    .
    .
    .
    return
 end function Excursion_Sets_First_Crossing_Probability
\end{verbatim}
The function must return the first crossing probability per unit variance at the specified {\normalfont \ttfamily variance} and {\normalfont \ttfamily time}.

The first crossing probability rate function must have the form:
\begin{verbatim}
 double precision function Excursion_Sets_First_Crossing_Rate(variance,varianceProgenitor,time)
    implicit none
    double precision, intent(in) :: variance,varianceProgenitor,time
    .
    .
    .
    return
 end function Excursion_Sets_First_Crossing_Rate
\end{verbatim}
The function must return the rate of first crossing per unit variance at the specified {\normalfont \ttfamily variance} and {\normalfont \ttfamily time} for a progenitor of the specified {\normalfont \ttfamily varianceProgenitor}.

The non-crossing probability rate function must have the form:
\begin{verbatim}
 double precision function Excursion_Sets_First_Non_Crossing_Rate(variance,time)
    implicit none
    double precision, intent(in) :: variance,time
    .
    .
    .
    return
 end function Excursion_Sets_First_Non_Crossing_Rate
\end{verbatim}
The function must return the rate of trajectories which never cross the barrier at the specified {\normalfont \ttfamily variance} and {\normalfont \ttfamily time}..

Currently defined excursion set barrier first crossing methods are:
\begin{description}
 \item [{\normalfont \ttfamily linearBarrier}] Assumes the solution for a linear barrier;
 \item [{\normalfont \ttfamily Farahi}] Solves the first crossing problem using the methodology of \cite{benson_dark_2012};
 \item [{\normalfont \ttfamily ZhangHui2006}] Solves the first crossing problem using the methodology of \cite{zhang_random_2006};
 \item [{\normalfont \ttfamily ZhangHui2006HighOrder}] Solves the first crossing problem using a higher order extension of the methodology of \cite{zhang_random_2006}.
\end{description}

\subsubsection{Excursion Set Barrier Remapping}\label{sec:excursionSetBarrierRemapInitialize}

Additional methods for the excursion set barrier can be added using the {\normalfont \ttfamily excursionSetBarrierRemapInitialize} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily scale} method is described by a directive:
\begin{verbatim}
 !# <excursionSetBarrierRemapInitialize>
 !#  <unitName>Excursion_Sets_Barriers_Remap_Scale_Initialize</unitName>
 !# </excursionSetBarrierRemapInitialize>
\end{verbatim}
Here, {\normalfont \ttfamily Excursion\_Sets\_Barriers\_Remap\_Scale\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(excursionSetBarrierRemapMethods,barrierName, &
  & ratesCalculation,matchedCount)
    implicit none
    type(varying_string), intent(in   ), dimension(:) :: excursionSetBarrierRemapMethods
    type(varying_string), intent(inout)               :: barrierName
    logical             , intent(in   )               :: ratesCalculation
    integer             , intent(inout)               :: matchedCount

    if (any(excursionSetBarrierRemapMethods == 'myMethod')) then
       position=-1
       do i=1,size(excursionSetBarrierRemapMethods)
          if (excursionSetBarrierRemapMethods(i) == 'myMethod') then
             position=i
             exit
          end if
       end do
       if (ratesCalculation) then
          methodRatesPosition=position
       else
          methodPosition     =position
       end if
       matchedCount=matchedCount+1
       barrierName=barrierName//":myLabel"
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily excursionSetBarrierRemapMethods} input parameter. The initialization subroutine should identify the position of the matched method in the {\normalfont \ttfamily excursionSetBarrierRemapMethods()} array and record that it is active for standard barrier calculations ({\normalfont \ttfamily ratesCalculation}$=${\normalfont \ttfamily false}) or for barriers used in crossing rate calculations ({\normalfont \ttfamily ratesCalculation}$=${\normalfont \ttfamily true}). It should also increment the {\normalfont \ttfamily matchedCount} argument (to allow checking that all specified barriers were matched) and append a descriptive label to the{\normalfont \ttfamily barrierName} argument. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The method must provide a subroutine to compute remapping of the barrier as follows:
\begin{verbatim}
  !# <excursionSetBarrierRemap>
  !#  <unitName>Method_Barrier_Remap</unitName>
  !# </excursionSetBarrierRemap>
  subroutine Method_Barrier_Remap(barrier,variance,time,ratesCalculation,iRemap)
    implicit none
    double precision, intent(inout) :: barrier
    double precision, intent(in   ) :: variance,time
    logical         , intent(in   ) :: ratesCalculation
    integer         , intent(in   ) :: iRemap

    if ((ratesCalculation.and.iRemap == methodRatesPosition).or.(.not.ratesCalculation.and.iRemap == methodPosition)) then
     ! Do remapping.
     .
     .
     .
    end if
    return
  end subroutine Method_Barrier_Remap
\end{verbatim}
and a subroutine to compute remapping of the barrier gradient as follows:
\begin{verbatim}
  !# <excursionSetBarrierRemapGradient>
  !#  <unitName>Method_Barrier_Gradient_Remap</unitName>
  !# </excursionSetBarrierRemapGradient>
  subroutine Method_Barrier_Gradient_Remap(barrier,barrierGradient,variance,time,ratesCalculation,iRemap)
    implicit none
    double precision, intent(inout) :: barrier,barrierGradient
    double precision, intent(in   ) :: variance,time
    logical         , intent(in   ) :: ratesCalculation
    integer         , intent(in   ) :: iRemap

    if ((ratesCalculation.and.iRemap == methodRatesPosition).or.(.not.ratesCalculation.and.iRemap == methodPosition)) then
     ! Do remapping.
     .
     .
     .
    end if
    return
  end subroutine Method_Barrier_Gradient_Remap
\end{verbatim}

Currently defined excursion set barrier remapping methods are:
\begin{description}
 \item [{\normalfont \ttfamily null}] A null method which leaves the barrier unchanged;
 \item [{\normalfont \ttfamily scale}] Scales the barrier by a multiplicative factor;
 \item [{\normalfont \ttfamily Sheth-Mo-Tormen}] Remaps the barrier according to the algorithm of \cite{sheth_ellipsoidal_2001}.
\end{description}

\subsubsection{Galactic Component Radii Solver}\label{sec:galactic_radii_solvers}

Additional methods for solving for radii of galactic components can be added using the {\normalfont \ttfamily galacticStructureRadiusSolverMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily simple} method is described by a directive:
\begin{verbatim}
 !# <galacticStructureRadiusSolverMethod>
 !#  <unitName>Galactic_Structure_Radii_Simple_Initialize</unitName>
 !# </galacticStructureRadiusSolverMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Galactic\_Structure\_Radii\_Simple\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(galacticStructureRadiusSolverMethod,Galactic_Structure_Radii_Solve_Do)
    implicit none
    type(varying_string),          intent(in)    :: galacticStructureRadiusSolverMethod
    procedure(),          pointer, intent(inout) :: Galactic_Structure_Radii_Solve_Do
    
    if (galacticStructureRadiusSolverMethod == 'myMethod') Galactic_Structure_Radii_Solve_Do => My_Method_Do_Procedure
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily galacticStructureRadiusSolverMethod} input parameter. The procedure pointer {\normalfont \ttfamily Galactic\_Structure\_Radii\_Solve\_Do} must be set to point to a subroutine which solves for the radii of components in a node as described below. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The radii solving subroutine must have the form:
\begin{verbatim}
 subroutine Radii_Solver_Do(thisNode)
    implicit none
    type(treeNode), intent(in), pointer :: thisNode
    .
    .
    .
    return
 end subroutine Radii_Solver_Do
\end{verbatim}
The function must set the radii (and corresponding circular velocities) of all components that have a radius property in {\normalfont \ttfamily thisNode}.

Currently defined radius solver methods are:
\begin{description}
 \item [\hyperlink{galactic_structure.radius_solver.simple.F90:galactic_structure_radii_simple:galactic_structure_radii_solve_simple}{{\normalfont \ttfamily simple}}] This solver computes radii assuming that the gravitational potential is dominated by dark matter (i.e. no baryonic self-gravity is included) and that dark matter does not respond to the presence of baryons (i.e. no adiabatic contraction). It uses the ``radius solver'' (see \S\ref{sec:radius_solver}) task to interact with the node.
 \item [\hyperlink{galactic_structure.radius_solver.adiabatic.F90:galactic_structure_radii_adiabatic:galactic_structure_radii_solve_adiabatic}{{\normalfont \ttfamily adiabatic}}] This solver computes radii including the effects of self-gravity of the baryonic component and adiabatic contraction of the dark matter halo using the method of \cite{gnedin_response_2004}. It uses the ``radius solver'' (see \S\ref{sec:radius_solver}) task to interact with the node.
 \item [\hyperlink{galactic_structure.radius_solver.linear.F90:galactic_structure_radii_linear:galactic_structure_radii_solve_linear}{{\normalfont \ttfamily linear}}] This solver assumes that radii scale linearly with specific angular momentum, equalling the virial radius when the specific angular momentum equals the product of virial radii and velocities. It uses the ``radius solver'' (see \S\ref{sec:radius_solver}) task to interact with the node.
 \item [\hyperlink{galactic_structure.radius_solver.fixed.F90:galactic_structure_radii_fixed:galactic_structure_radii_solve_fixed}{{\normalfont \ttfamily fixed}}] This solver assumes that radii equal the product of virial radius of the halo and its spin parameter (with an adjustable coefficient). It uses the ``radius solver'' (see \S\ref{sec:radius_solver}) task to interact with the node.
\end{description}

\subsubsection{Galactic Component Radius Solver Initial Radius}

Additional methods for computing the initial radius in the dark matter profile when solving for adiabatic contraction of the halo can be added using the {\normalfont \ttfamily galacticStructureRadiusSolverInitialRadiusMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily adiabatic} method is described by a directive:
\begin{verbatim}
 !# <galacticStructureRadiusSolverInitialRadiusMethod>
 !#  <unitName>Galactic_Structure_Initial_Radii_Adiabatic_Initialize</unitName>
 !# </galacticStructureRadiusSolverInitialRadiusMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Galactic\_Structure\_Initial\_Radii\_Adiabatic\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(galacticStructureRadiusSolverInitialRadiusMethod,Galactic_Structure_Radius_Initial_Get,Galactic_Structure_Radius_Initial_Derivative_Get)
    implicit none
    type(varying_string),          intent(in)    :: galacticStructureRadiusSolverInitialRadiusMethod
    procedure(),          pointer, intent(inout) :: Galactic_Structure_Radius_Initial_Get,Galactic_Structure_Radius_Initial_Derivative_Get
    
    if (galacticStructureRadiusSolverInitialRadiusMethod == 'myMethod') then
       Galactic_Structure_Radius_Initial_Get            => My_Method_Get
       Galactic_Structure_Radius_Initial_Derivative_Get => My_Method_Derivative_Get
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily galacticStructureRadiusSolverInitialRadiusMethod} input parameter. The procedure pointers {\normalfont \ttfamily Galactic\_Structure\_Radius\_Initial\_Get} and {\normalfont \ttfamily Galactic\_Structure\_Radius\_Initial\_Derivative\_Get} must be set to point to functions which compute the initial radius in the dark matter halo given the final radius, and the deriative of this quantity with respect to the final radius as described below. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The initial radius function must have the form:
\begin{verbatim}
 double precision function Radius_Initial_Get(thisNode,radius)
    implicit none
    type            (treeNode), intent(in   ), pointer :: thisNode
    double precision          , intent(in   )          :: radius
    .
    .
    .
    return
 end function Radius_Initial_Get
\end{verbatim}
The function must return the initial radius in the dark matter halo of {\normalfont \ttfamily thisNode} corresponding to the final {\normalfont \ttfamily radius} after accounting for the effects of adiabatic contraction.

The initial radius derivative function must have the form:
\begin{verbatim}
 double precision function Radius_Initial_Derivative_Get(thisNode,radius)
    implicit none
    type            (treeNode), intent(in   ), pointer :: thisNode
    double precision          , intent(in   )          :: radius
    .
    .
    .
    return
 end function Radius_Initial_Derivative_Get
\end{verbatim}
The function must return the derivative with respect to the final {\normalfont \ttfamily radius} of initial radius in the dark matter halo of {\normalfont \ttfamily thisNode} corresponding to the final {\normalfont \ttfamily radius} after accounting for the effects of adiabatic contraction.

Currently defined initial radius methods are:
\begin{description}
 \item [\hyperlink{galactic_structure.radius_solver.initial_radii.static.F90:galactic_structure_initial_radii_static:galactic_structure_radius_initial_static}{{\normalfont \ttfamily static}}] This method assumes a static dark matter halo, and so the initial radius always equals the final radius.
 \item [\hyperlink{galactic_structure.radius_solver.initial_radii.adiabatic.F90:galactic_structure_initial_radii_adiabatic:galactic_structure_radius_initial_adiabatic}{{\normalfont \ttfamily adiabatic}}] This method assumes adiabatic contraction follows the model of \cite{gnedin_response_2004}.
\end{description}

\subsubsection{Halo Mass Sampling Density Functions}

Additional methods for halo mass sampling density functions can be added using the {\normalfont \ttfamily haloMassFunctionSamplingMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily powerLaw} method is described by a directive:
\begin{verbatim}
 !# <haloMassFunctionSamplingMethod>
 !#  <unitName>Merger_Trees_Mass_Function_Sampling_Power_Law_Initialize</unitName>
 !# </haloMassFunctionSamplingMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Merger\_Trees\_Mass\_Function\_Sampling\_Power\_Law\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(haloMassFunctionSamplingMethod,Merger_Tree_Construct_Mass_Function_Sampling_Get)
    implicit none
    type(varying_string),          intent(in)    :: haloMassFunctionSamplingMethod
    procedure(),          pointer, intent(inout) :: Merger_Tree_Construct_Mass_Function_Sampling_Get
    
    if (haloMassFunctionSamplingMethod == 'myMethod') Merger_Tree_Construct_Mass_Function_Sampling_Get => My_Mass_Function_Sampling
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily haloMassFunctionSamplingMethod} input parameter. The procedure pointer {\normalfont \ttfamily Merger\_Tree\_Construct\_Mass\_Function\_Sampling\_Get} must be set to point to a function which returns the sampling rate per unit decade of halo mass.

The halo mass sampling density function must have the form:
\begin{verbatim}
 double precision function My_Mass_Function_Sampling(mass,time,massMinimum,massMaximum)
    implicit none
    double precision, intent(in) :: mass,time,massMinimum,massMaximum
    .
    .
    .
    return
 end function My_Mass_Function_Sampling
\end{verbatim}
The function should return the halo mass sampling density function (the relative number of halos per decade of halo mass to sample) for halos of the given {\normalfont \ttfamily mass}. Halos are defined at the given {\normalfont \ttfamily time} and will be sampled in the mass range {\normalfont \ttfamily massMinimum} to {\normalfont \ttfamily massMaximum}.

Currently defined halo mass sampling density function methods are:
\begin{description}
 \item [{\normalfont \ttfamily powerLaw}] The distribution of halo masses is such that the mass of the $i^\mathrm{th}$ halo is
\begin{equation}
 M_\mathrm{halo,i} = \exp\left[ \ln(M_\mathrm{halo,min}) + \ln\left({M_\mathrm{halo,max}/M_\mathrm{halo,min}}\right) x_i^{1+\alpha} \right].
\end{equation}
Here, $x_i$ is a number between 0 and 1 and $\alpha=${\normalfont \ttfamily mergerTreeBuildTreesHaloMassExponent} is an input parameter that controls the relative number of low and high mass tree produced. 
\item [{\normalfont \ttfamily haloMassFunction}] The sampling density is set equal to the dark matter halo mass function, defined per decade of halo mass.
\item [{\normalfont \ttfamily stellarMassFunction}] The sampling density is chosen to give optimally minimal errors on the model stellar mass function (see \S\ref{sec:OptimalSamplingStellarMassFunction} for full details).
\end{description}

\subsubsection{Initial Mass Function Functions}\label{sec:IMF_functions}

Each registered \gls{imf} must provide multiple functions, specified by the following directives:
\begin{verbatim}
 !# <imfRecycledInstantaneous>
 !#  <unitName>Star_Formation_IMF_Recycled_Instantaneous_My_IMF</unitName>
 !# </imfRecycledInstantaneous>

 !# <imfYieldInstantaneous>
 !#  <unitName>Star_Formation_IMF_Yield_Instantaneous_My_IMF</unitName>
 !# </imfYieldInstantaneous>

 !# <imfTabulate>
 !#  <unitName>Star_Formation_IMF_Tabulate_My_IMF</unitName>
 !# </imfTabulate>

 !# <imfMinimumMass>
 !#  <unitName>Star_Formation_IMF_Minimum_Mass_My_IMF</unitName>
 !# </imfMinimumMass>

 !# <imfMaximumMass>
 !#  <unitName>Star_Formation_IMF_Maximum_Mass_My_IMF</unitName>
 !# </imfMaximumMass>

 !# <imfPhi>
 !#  <unitName>Star_Formation_IMF_Phi_My_IMF</unitName>
 !# </imfPhi>
\end{verbatim}

These functions/subroutines should have the following forms:
\begin{verbatim}
  subroutine Star_Formation_IMF_Recycled_Instantaneous_My_IMF(imfSelected,imfMatched,recycledFraction)
    integer,          intent(in)    :: imfSelected
    logical,          intent(inout) :: imfMatched
    double precision, intent(out)   :: recycledFraction

    if (imfSelected == imfIndex) then
       .
       .
       .
       imfMatched=.true.
    end if
    return
  end subroutine Star_Formation_IMF_Recycled_Instantaneous_My_IMF

  subroutine Star_Formation_IMF_Yield_Instantaneous_My_IMF(imfSelected,imfMatched,yield)
    integer,          intent(in)    :: imfSelected
    logical,          intent(inout) :: imfMatched
    double precision, intent(out)   :: yield

    if (imfSelected == imfIndex) then
       .
       .
       .
       imfMatched=.true.
    end if
    return
  end subroutine Star_Formation_IMF_Yield_Instantaneous_My_IMF

  subroutine Star_Formation_IMF_Tabulate_My_IMF(imfSelected,imfMatched,imfMass,imfPhi)
    integer,          intent(in)                               :: imfSelected
    logical,          intent(inout)                            :: imfMatched
    double precision, intent(inout), allocatable, dimension(:) :: imfMass,imfPhi

    if (imfSelected == imfIndex) then
       .
       .
       .
       imfMatched=.true.
    end if
    return
  end subroutine Star_Formation_IMF_Tabulate_My_IMF

  subroutine Star_Formation_IMF_Minimum_Mass_My_IMF(imfSelected,imfMatched,minimumMass)
    implicit none
    integer,          intent(in)    :: imfSelected
    logical,          intent(inout) :: imfMatched
    double precision, intent(out)   :: minimumMass
    
    if (imfSelected == imfIndex) then
       .
       .
       .
       imfMatched=.true.
    end if
    return
  end subroutine Star_Formation_IMF_Minimum_Mass_My_IMF

  subroutine Star_Formation_IMF_Maximum_Mass_My_IMF(imfSelected,imfMatched,minimumMass)
    implicit none
    integer,          intent(in)    :: imfSelected
    logical,          intent(inout) :: imfMatched
    double precision, intent(out)   :: maximumMass
    
    if (imfSelected == imfIndex) then
       .
       .
       .
       imfMatched=.true.
    end if
    return
  end subroutine Star_Formation_IMF_Maximum_Mass_My_IMF

  subroutine Star_Formation_IMF_Phi_My_IMF(imfSelected,imfMatched,imfMass,imfPhi)
    integer,          intent(in)                               :: imfSelected
    logical,          intent(inout)                            :: imfMatched
    double precision, intent(in)                               :: imfMass
    double precision, intent(out)                              :: imfPhi

    if (imfSelected == imfIndex) then
       .
       .
       .
       imfMatched=.true.
    end if
    return
  end subroutine Star_Formation_IMF_Phi_My_IMF
\end{verbatim}
In each case the procedure should check if the supplied {\normalfont \ttfamily imfSelected} index matches the index which this \gls{imf} was given when it was registered. If it is, then {\normalfont \ttfamily imfMatched} should be set to true. The procedures should then perform as follows:
\begin{description}
 \item [{\normalfont \ttfamily Star\_Formation\_IMF\_Yield\_Instantaneous\_My\_IMF}] Return a suitable metal yield in {\normalfont \ttfamily yield} for this \gls{imf} in the instantaneous recyclying approximation.
 \item [{\normalfont \ttfamily Star\_Formation\_IMF\_Recycled\_Instantaneous\_My\_IMF}] Return a suitable recycled fraction in {\normalfont \ttfamily recycledFraction} for this \gls{imf} in the instantaneous recyclying approximation.
 \item [{\normalfont \ttfamily Star\_Formation\_IMF\_Tabulate\_My\_IMF}] Allocate the {\normalfont \ttfamily imfMass()} and {\normalfont \ttfamily imfPhi()} arrays and fill them with a tabulation of the \gls{imf}. The routine can choose the size of the tabulation and should ensure that it is suffient to resolve any features in the \gls{imf}.
 \item [{\normalfont \ttfamily Star\_Formation\_IMF\_Minimum\_Mass\_My\_IMF}] Return the lowest mass for which the \gls{imf} is non-zero.
 \item [{\normalfont \ttfamily Star\_Formation\_IMF\_Maximum\_Mass\_My\_IMF}] Return the largest mass for which the \gls{imf} is non-zero.
 \item [{\normalfont \ttfamily Star\_Formation\_IMF\_Phi\_My\_IMF}] Return the \gls{imf} for the specified {\normalfont \ttfamily imfMass} initial stellar mass.
\end{description}
Currently defined IMFs are described in \S\ref{sec:physicsIMF}.

\subsubsection{Initial Mass Function Selection}

Additional methods for selection of initial mass functions can be added using the {\normalfont \ttfamily imfSelectionMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily fixed} method is described by a directive:
\begin{verbatim}
 !# <imfSelectionMethod>
 !#  <unitName>IMF_Select_Fixed_Initialize</unitName>
 !# </imfSelectionMethod>
\end{verbatim}
Here, {\normalfont \ttfamily IMF\_Select\_Fixed\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(imfSelectionMethod,IMF_Select,imfNames)
    implicit none
    type(varying_string),          intent(in)    :: imfSelectionMethod,imfNames(:)
    procedure(),          pointer, intent(inout) :: IMF_Select

    if (imfSelectionMethod == 'myMethod') then
       IMF_Select_Fixed => My_Selection_Procedure
       .
       .
       .
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily imfSelectionMethod} input parameter. The procedure pointer {\normalfont \ttfamily IMF\_Select} must be set to point to a function which returns the index of the selected \gls{imf} as described below. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.). The input array {\normalfont \ttfamily imfNames()} contains a list of all available \gls{imf} names and can be used for \hyperlink{star_formation.IMF.utilities.F90:star_formation_imf_utilities:imf_index_lookup}{index determination}.

The selection function must have the form:
\begin{verbatim}
 integer function IMF_Select(starFormationRate,fuelAbundances,component)
    double precision,          intent(in) :: starFormationRate
    type(abundancesStructure), intent(in) :: fuelAbundances
    integer,                   intent(in) :: component
    .
    .
    .
    return
 end function IMF_Select
\end{verbatim}
The function must return the index of the \gls{imf} appropriate for the given {\normalfont \ttfamily starFormationRate} (in $M_\odot$ Gyr$^{-1}$), {\normalfont \ttfamily fuelAbundances} and {\normalfont \ttfamily component} (using the component labels provided by the \hyperlink{galactic_structure.options.F90:galactic_structure_options}{{\normalfont \ttfamily Galactic\_Structure\_Options}} module).

Currently defined \gls{imf} selection methods are:
\begin{description}
 \item [{\normalfont \ttfamily fixed}] A fixed \gls{imf} is used irrespective of physical conditions. The \gls{imf} is specified by the input parameter {\normalfont \ttfamily imfSelectionFixed}.
 \item [{\normalfont \ttfamily diskSpheroid}] Uses different {\gls{imf}}s for star formation in disks and in spheroids irrespective of other physical conditions. The {\gls{imf}}s are specified by the input parameters {\normalfont \ttfamily imfSelectionDisk} and {\normalfont \ttfamily imfSelectionSpheroid}.
\end{description}

\subsubsection{Linear Growth Function}

Additional methods for the linear growth factor can be added using the {\normalfont \ttfamily linearGrowthMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily simple} method is described by a directive:
\begin{verbatim}
  !# <linearGrowthMethod>
  !#  <unitName>Growth_Factor_Simple_Initialize</unitName>
  !# </linearGrowthMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Growth\_Factor\_Simple\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(linearGrowthMethod,Linear_Growth_Tabulate)
    implicit none
    type(varying_string),          intent(in)    :: linearGrowthMethod
    procedure(),          pointer, intent(inout) :: Linear_Growth_Tabulate
    
    if (linearGrowthMethod.eq.'myMethod') then
       Linear_Growth_Tabulate => My_Do_Tabulate
       .
       .
       .
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily linearGrowthMethod} input parameter. The procedure pointer {\normalfont \ttfamily Linear\_Growth\_Tabulate} must be set to point to a subroutine which tabulates the linear growth factor as described below. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The tabulation subroutine must have the form:
\begin{verbatim}
   subroutine Linear_Growth_Tabulate(time,growthTableNumberPoints,growthTableTime,growthTableWavenumber &
   & ,growthTableGrowthFactor,normalizationMatterDominated)
    implicit none
    double precision, intent(in)                                   :: time
    integer,          intent(out)                                  :: growthTableNumberPoints
    double precision, intent(inout), allocatable, dimension(:)     :: growthTableTime,growthTableWavenumber
    double precision, intent(inout), allocatable, dimension(:,:,:) :: growthTableGrowthFactor
    double precision, intent(out),                dimension(3)     :: normalizationMatterDominated
    .
    .
    return
   end subroutine Linear_Growth_Tabulate
\end{verbatim}
The subroutine must tabulate the linear growth factor in array {\normalfont \ttfamily growthTableGrowthFactor()} for dark matter, baryons and radiation (entries 1, 2 and 3 of the first dimension respectively) as a function of time {\normalfont \ttfamily growthTableTime()} (second dimension) and wavenumber {\normalfont \ttfamily growthTableWavenumber()} (third dimension). These arrays must be allocated to the correct size, and may be prevously allocated, therefore requiring a deallocation. The number of tabulated points in the time dimension should be returned in {\normalfont \ttfamily growthTableNumberPoints}. It is permissible to tabulate for just a single wavenumber if the growth function is independent of wavenumber. The subroutine should ensure that the currently requested {\normalfont \ttfamily time} is within the range of the tabulated function (preferably with some buffer). The linear growth factors must be normalized to unity at $a=1$. Additionally, {\normalfont \ttfamily normalizationMatterDominated} should be set to the factor by which the tabulated growth factor (for the smallest wavenumber tabulated) 
must be multiplied such that it scales as $(9 \Omega_\mathrm{M} / 4.0d0)^{1/3} (H_0 t)^{2/3}$ during the matter dominated regime.

Currently defined linear growth factor methods are:
\begin{description}
 \item [{\normalfont \ttfamily simple}] The linear growth factor is computed for a Universe containing collisionless matter and a cosmological constant.
\end{description}

\subsubsection{Merger Tree Branching}

Additional methods for merger tree branching can be added using the {\normalfont \ttfamily treeBranchingMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily modifiedPress-Schechter} method is described by a directive:
\begin{verbatim}
 !# <treeBranchingMethod>
 !#  <unitName>Modified_Press_Schechter_Branching_Initialize</unitName>
 !# </treeBranchingMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Modified\_Press\_Schechter\_Branching\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
 subroutine Method_Initialize(treeBranchingMethod,Tree_Branching_Probability_Bound,Tree_Branching_Probability,Tree_Subresolution_Fraction,Tree_Branch_Mass,Tree_Maximum_Step)
    type(varying_string),          intent(in)    :: treeBranchingMethod
    procedure(),          pointer, intent(inout) :: Tree_Branching_Probability_Bound,Tree_Branching_Probability,Tree_Subresolution_Fraction,Tree_Branch_Mass,Tree_Maximum_Step
    
    if (treeBranchingMethod == 'myMethod') then
       Tree_Branching_Probability_Bound => My_Branching_Probability_Bound
       Tree_Branching_Probability       => My_Branching_Probability
       Tree_Subresolution_Fraction      => My_Subresolution_Fraction
       Tree_Maximum_Step                => My_Maximum_Step
       Tree_Branch_Mass                 => My_Branch_Mass
       .
       .
       .
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily treeBranchingMethod} input parameter. The procedure pointers must be set to point to routines which perform various functions as described below. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The procedure pointers must point to functions with the following templates:
\begin{verbatim}
  double precision function My_Branch_Mass(haloMass,deltaCritical,massResolution,probability)
    double precision, intent(in) :: haloMass,deltaCritical,massResolution,probability
    .
    .
    .
    return
 end function My_Branch_Mass

 double precision function My_Branching_Maximum_Step(haloMass,deltaCritical,massResolution)
    double precision, intent(in) :: haloMass,deltaCritical,massResolution
    .
    .
    .
    return
 end function My_Branching_Maximum_Step

  double precision function My_Branching_Probability(haloMass,deltaCritical,massResolution)
    double precision, intent(in) :: haloMass,deltaCritical,massResolution
    .
    .
    .
    return
 end function My_Branching_Probability

  double precision function My_Branching_Probability_Bound(haloMass,deltaCritical,massResolution,bound)
    double precision, intent(in) :: haloMass,deltaCritical,massResolution
    integer         , intent(in) :: bound
    .
    .
    .
    return
 end function My_Branching_Probability_Bound

  double precision function My_Subresolution_Fraction(haloMass,deltaCritical,massResolution)
    double precision, intent(in) :: haloMass,deltaCritical,massResolution
    .
    .
    .
    return
 end function My_Subresolution_Fraction
\end{verbatim}
{\normalfont \ttfamily Tree\_Branching\_Probability} must point to a function which returns the probability per unit change in $\delta_\mathrm{crit}$ that a halo of mass {\normalfont \ttfamily haloMass} at time {\normalfont \ttfamily deltaCritical} will undergo a branching to progenitors with mass greater than {\normalfont \ttfamily massResolution}. {\normalfont \ttfamily Tree\_Branching\_Probability\_Bound} must point to a function which returns either an upper or lower bound (as requested by the {\normalfont \ttfamily bound} arugment, which must be either {\normalfont \ttfamily boundLower} or {\normalfont \ttfamily boundUpper} as defined in the {\normalfont \ttfamily Merger\_Tree\_Branching\_Options} module) on the probability per unit change in $\delta_\mathrm{crit}$ that a halo of mass {\normalfont \ttfamily haloMass} at time {\normalfont \ttfamily deltaCritical} will undergo a branching to progenitors with mass greater than {\normalfont \ttfamily massResolution}. This is intended for cases where useful bounds can be computed rapidly (more rapidly than the full calculation performed by {\normalfont \ttfamily Tree\_Branching\_Probability}). It is acceptable to simply return the value given by {\normalfont \ttfamily Tree\_Branching\_Probability} is no bounds are available (in which case an implementation may want to intelligently store previously computed values and re-use them if possible). {\normalfont \ttfamily Tree\_Subresolution\_Fraction} must point to a function which returns the fraction of mass accreted in subresolution halos, i.e. those below {\normalfont \ttfamily massResolution}, per unit change in $\delta_\mathrm{crit}$ for a halo of mass {\normalfont \ttfamily haloMass} at time {\normalfont \ttfamily deltaCritical}, or a negative value if the halo is so close to the resolution limit that this number cannot be determined accurately. {\normalfont \ttfamily Tree\_Maximum\_Step} must point to a function which returns the maximum allowed step in $\delta_\mathrm{crit}$ that a halo of mass {\normalfont \ttfamily haloMass} at time {\normalfont \ttfamily deltaCritical} should be allowed to take. {\normalfont \ttfamily Tree\_Branch\_Mass} must point to a function which returns the mass of one of the halos to which the given halo branches, given the branching 
probability, {\normalfont \ttfamily probability}.

Currently defined merger tree branching methods are:
\begin{description}
 \item [{\normalfont \ttfamily modifiedPress-Schechter}] Branching probabilities are computed using the method of \cite{parkinson_generating_2008}. Progenitor mass functions generated using \glc's implementation of this algorithm (and the \cite{cole_hierarchical_2000} merger tree building algorithm) are shown in Fig.~\ref{fig:PCH_Progenitor_MFs}.
 \item [{\normalfont \ttfamily generalizedPress-Schechter}] Branching probabilities are computed using excursion set barrier first crossing rates (computed using the selected {\normalfont \ttfamily excursionSetFirstCrossingMethod}; see \S\ref{sec:excursionSetFirstCrossingMethod}), modified by the selected {\normalfont \ttfamily treeBranchingModifierMethod} (see \S\ref{sec:treeBranchingModifierMethod}).
\end{description}

\begin{figure}
 \begin{center}
 \includegraphics[height=160mm,angle=90]{../plots/progenitorMassFunction.pdf}
 \end{center}
 \caption{Progenitor mass functions at redshifts $z=0.5$, 1, 2 and 4 (bottom to top) for halos of mass $10^{12\pm0.151}$, $10^{13.5\pm0.151}$ and $10^{15\pm0.151}h^{-1}M_\odot$ (left to right) are shown. Green lines are measured from the Millennium Simulation, while red lines are computed using \glc's merger tree building routines (with the \cite{parkinson_generating_2008} branching algorithm and the \cite{cole_hierarchical_2000} tree building algorithm).}
 \label{fig:PCH_Progenitor_MFs}
\end{figure}

\subsubsection{Merger Tree Branching Modifiers}\label{sec:treeBranchingModifierMethod}

Additional methods for merger tree branching probability modifiers can be added using the {\normalfont \ttfamily treeBranchingModifierMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily null} method is described by a directive:
\begin{verbatim}
 !# <treeBranchingModifierMethod>
 !#  <unitName>Merger_Tree_Branching_Modifiers_Null_Initialize</unitName>
 !# </treeBranchingModifierMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Merger\_Tree\_Branching\_Modifiers\_Null\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
 subroutine Method_Initialize(treeBranchingModifierMethod,Merger_Tree_Branching_Modifier_Get)
    type     (varying_string  ),          intent(in   ) :: treeBranchingModifierMethod
    procedure(double precision), pointer, intent(inout) :: Merger_Tree_Branching_Modifier_Get
    
    if (treeBranchingModifierMethod == 'myMethod') then
       Merger_Tree_Branching_Modifier_Get => My_Get
       .
       .
       .
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily treeBranchingModifierMethod} input parameter. The procedure pointer {\normalfont \ttfamily Merger\_Tree\_Branching\_Modifier\_Get} must build and return the modifier to the branching probability as described below. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The branching probability modifier function should have the interface:
\begin{verbatim}
  subroutine Merger_Tree_Branching_Modifier_Get(parentDelta,childSigma,parentSigma)
    double precision, intent(in) :: parentDelta,childSigma,parentSigma
    .
    .
    .
    return
  end subroutine Merger_Tree_Branching_Modifier_Get
\end{verbatim}
and should return the multiplicative modifier to the branching probability for the given {\normalfont \ttfamily parentDelta}, {\normalfont \ttfamily childSigma} and {\normalfont \ttfamily parentSigma}.

Currently defined merger tree branching probability modifier methods are:
\begin{description}
 \item [{\normalfont \ttfamily null}] Makes no modification;
 \item [{\normalfont \ttfamily Parkinson-Cole-Helly2008}] Modifies branching rates according to the algorithm of \cite{parkinson_generating_2008}.
\end{description}

\subsubsection{Merger Tree Construction}\label{sec:MergerTreeConstruction}

Additional methods for merger tree construction can be added using the {\normalfont \ttfamily mergerTreeConstructMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily build} method is described by a directive:
\begin{verbatim}
 !# <mergerTreeConstructMethod>
 !#  <unitName>Merger_Tree_Build_Initialize</unitName>
 !# </mergerTreeConstructMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Merger\_Tree\_Build\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
   subroutine Method_Initialize(mergerTreeConstructMethod,Merger_Tree_Construct)
    type(varying_string),          intent(in)    :: mergerTreeConstructMethod
    procedure(),          pointer, intent(inout) :: Merger_Tree_Construct
    
    if (mergerTreeConstructMethod == 'myMethod') then
       Merger_Tree_Construct => My_Do_Tabulate
       .
       .
       .
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily mergerTreeConstructMethod} input parameter. The procedure pointer {\normalfont \ttfamily Merger\_Tree\_Construct} must be set to point to a function which returns a fully constructed merger tree as described below. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The construction subroutine should have the following form:
\begin{verbatim}
  subroutine Merger_Tree_Construct_Do(thisTree,skipTree)
    type(mergerTree), intent(inout) :: thisTree
    logical,          intent(in)    :: skipTree
    .
    .
    .
    return
  end subroutine Merger_Tree_Construct_Do
\end{verbatim}
and should return a full merger tree in {\normalfont \ttfamily thisTree}, unless {\normalfont \ttfamily skipTree} is true, in which case this tree will be skipped (i.e. not evolved or output) and so it suffices to merely allocate the base node---there is no need to create the entire tree (although it is permissible to do so)---and update any internal data (e.g. a count of trees constructed) as required. The tree must have at least masses, times and parent/child/sibling links created. Other properties (e.g. spins) can be optionally included also. Optionally, a linked forest of merger trees can be returned by simply setting the {\normalfont \ttfamily nextTree} pointer of each tree to point to the subsequent tree in the forest (leaving the pointer {\normalfont \ttfamily null} for the final tree). By default, the tree is assumed to be ``uninitialized'', such that the merger tree initialization function will be called prior to the tree being evolve. If the tree construction method returns a fully initialized tree it should set {\normalfont \ttfamily thisTree\%initialized=.true.}.

Currently defined merger tree construction methods are:
\begin{description}
 \item [{\normalfont \ttfamily build}] Generates a set of halo masses distributed between {\normalfont \ttfamily mergerTreeBuildHaloMassMinimum} and {\normalfont \ttfamily mergerTreeBuildHaloMassMaximum} (with {\normalfont \ttfamily mergerTreeBuildTreesPerDecade} halos per decade of mass) at redshift {\normalfont \ttfamily mergerTreeBuildTreesBaseRedshift}, or with masses read from a file, and then uses the selected merger tree build method (see \S\ref{sec:methodsMergerTreeBuilder}) to build trees from these base nodes;
 \item [{\normalfont \ttfamily read}] Reads merger tree data from an HDF5 file (see \S\ref{sec:MergerTreeFiles}). The file to read is specified by the {\normalfont \ttfamily [mergerTreeReadFileName]} parameter.
 \item [{\normalfont \ttfamily smoothAccretion}] Constructs a branchless merger tree with a smooth accretion history using the selected mass accretion history method (see \S\ref{sec:methodsDarkMatterHaloMassAccretionHistory}). See \S\ref{sec:SmoothAccretion} for details.
 \item [{\normalfont \ttfamily stateRestore}] Intended primarily for debugging purposes, this method will restore a tree whose complete internal state was written to file. See \S\ref{sec:TreeConstructStateRestore} for details of how to use this method.
 \item [{\normalfont \ttfamily fullySpecified}] Intended primarily for constructing test cases, this method allows the full state of the merger tree (and all components of nodes) to be specified via an XML document. See \S\ref{sec:TreeConstructFullySpecified} for details of how to use this method.
\end{description}

\subsubsection{Chemical Reaction Rates}

Additional methods for chemical species reaction rates can be added using the {\normalfont \ttfamily chemicalReactionRatesMethods} directive. Note that more than one method can be specified in which cases rates are cumulative over all selected methods. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily hydrogenNetwork} method is described by a directive:
\begin{verbatim}
  !# <chemicalReactionRatesMethods>
  !#  <unitName>Chemical_Hydrogen_Rates_Initialize</unitName>
  !# </chemicalReactionRatesMethods>
\end{verbatim}
Here, {\normalfont \ttfamily Chemical\_Hydrogen\_Rates\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(chemicalReactionRatesMethods)
    implicit none
    type(varying_string), intent(in) :: chemicalReactionRatesMethods
    
    if (chemicalReactionRatesMethods == 'myMethod') then
       ratesSelected = .true.
       .
       .
       .
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily chemicalReactionRatesMethods} input parameter. The {\normalfont \ttfamily ratesSelected} variable is set to true if the method is active and will be checked on all subsequent calls to the module such that rates are computed only if {\normalfont \ttfamily ratesSelected} is true. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The method must provide a subroutine to compute the chemical reaction rates. This subroutine is specified by the {\normalfont \ttfamily chemicalRatesCompute} directive. The directive should contain a single argument, giving the name of a subroutine to be called to compute rates. For example, the {\normalfont \ttfamily hydrogenNetwork} method uses:
\begin{verbatim}
  !# <chemicalRatesCompute>
  !#  <unitName>Chemical_Hydrogen_Rates_Compute</unitName>
  !# </chemicalRatesCompute> 
\end{verbatim}
Here, {\normalfont \ttfamily Chemical\_Hydrogen\_Rates\_Compute} is the name of a subroutine which will be called to compute the rates. The rates subroutine must have the following form:
\begin{verbatim}
  subroutine Compute_Rates(temperature,chemicalDensity,radiation,chemicalRates)
    implicit none
    type(chemicalAbundancesStructure), intent(in)    :: chemicalDensity
    double precision,                  intent(in)    :: temperature
    type(radiationStructure),          intent(in)    :: radiation
    type(chemicalAbundancesStructure), intent(inout) :: chemicalRates

    ! Exit immediately if this method is not active.
    if (.not.ratesSelected) return

    ! Compute rates for all species present.
    .
    .
    .
    return
  end subroutine Compute_Rates
\end{verbatim}
Here, {\normalfont \ttfamily temperature} is the temperature of the gas, {\normalfont \ttfamily chemicalDensity} provides the densities (in cm$^{-3}$) of all chemicals, the radiation field is described by the {\normalfont \ttfamily radiation} object and any reaction rates should be \emph{added to} the {\normalfont \ttfamily chemicalRates} object in units of cm$^{-3}$ s$^{-1}$.

Currently defined chemical reaction rate methods are:
\begin{description}
 \item [{\normalfont \ttfamily null}] A null method which does not affect any rates.
 \item [{\normalfont \ttfamily hydrogenNetwork}] Computes rates using the network of reactions and fitting functions from \cite{abel_modeling_1997} and \cite{tegmark_small_1997}.
\end{description}

\subsubsection{Population III Supernovae}

Additional methods for Population III supernovae can be added using the {\normalfont \ttfamily supernovaePopIIIMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily Heger-Woosley2002} method is described by a directive:
\begin{verbatim}
  !# <supernovaePopIIIMethod>
  !#  <unitName>Supernovae_Population_III_HegerWoosley_Initialize</unitName>
  !# </supernovaePopIIIMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Supernovae\_Population\_III\_HegerWoosley\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(supernovaePopIIIMethod,SNePopIII_Cumulative_Energy_Get)
    implicit none
    type(varying_string),          intent(in)    :: supernovaePopIIIMethod
    procedure(),          pointer, intent(inout) :: SNePopIII_Cumulative_Energy_Get
    
    if (supernovaePopIIIMethod == 'myMethod') then
       SNePopIII_Cumulative_Energy_Get => My_SNePopIII_Cumulative_Energy_Get
       .
       .
       .
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily supernovaePopIIIMethod} input parameter. The procedure pointer {\normalfont \ttfamily SNePopIII\_Cumulative\_Energy\_Get} must be set to point to a function which returns the cumulative energy input from Population III supernovae as described below. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The functions must have the form:
\begin{verbatim}
   double precision function PopIII_Cumulative_Energy(initialMass,age,metallicity)
    implicit none
    double precision, intent(in) :: initialMass,age,metallicity
    .
    .
    .
    return
   end function PopIII_Cumulative_Energy 
\end{verbatim}
This function must return the cumulative energy (in $M_\odot$ (km/s)$^2$) from Population III supernovae resulting from a star with given {\normalfont \ttfamily initialMass} and {\normalfont \ttfamily metallicity} after a time {\normalfont \ttfamily age}.

Currently defined population III supernovae methods are:
\begin{description}
 \item [{\normalfont \ttfamily Heger-Woosley2002}] Computes the energy input from the pair-instability results of \cite{heger_nucleosynthetic_2002}.
\end{description}

\subsubsection{Radiation Components}\index{radiation}\label{sec:radiationComponents}

Radiation components (i.e. types of radiation field that may be added to any radiation object; see \S\ref{sec:RadiationSubsystem}) are defined using a combination of several directives: {\normalfont \ttfamily radiationLabel}, {\normalfont \ttfamily radiationSet}, {\normalfont \ttfamily radiationTemperature} and {\normalfont \ttfamily radiationFlux}. For example, the cosmic microwave background radiation component is defined by the following set of directives:
\begin{verbatim}
  !# <radiationLabel>
  !#  <label>CMB</label>
  !# </radiationLabel>

  !# <radiationSet>
  !#  <unitName>Radiation_Set_CMB</unitName>
  !#  <label>CMB</label>
  !# </radiationSet>

  !# <radiationTemperature>
  !#  <unitName>Radiation_Temperature_CMB</unitName>
  !#  <label>CMB</label>
  !# </radiationTemperature>

  !# <radiationFlux>
  !#  <unitName>Radiation_Flux_CMB</unitName>
  !#  <label>CMB</label>
  !# </radiationFlux>
\end{verbatim}
The first of these, {\normalfont \ttfamily radiationLabel}, should contain a single element, {\normalfont \ttfamily label}, which gives a label that will be used to identify this component, both in other directives and also in the internal parameters used to select this radiation component (e.g. in this case, a parameter {\normalfont \ttfamily radiationTypeCMB} will be available within \glc\ to select the cosmic microwave background component). The other directives must all specify the same {\normalfont \ttfamily label} element and additional give, in a {\normalfont \ttfamily unitName} element, the name of a function/subroutine to be called to perform the relevant calculation.

The {\normalfont \ttfamily radiationSet} directive must specify a subroutine with the following template:
\begin{verbatim}
  subroutine Radiation_Set(componentMatched,thisNode,radiationProperties)
   implicit none
   logical,          intent(in)                               :: componentMatched
   type(treeNode),   intent(inout), pointer                   :: thisNode
   double precision, intent(inout), allocatable, dimension(:) :: radiationProperties

   if (.not.componentMatched) return
   .
   .
   .
   return
  end subroutine Radiation_Set
\end{verbatim}
If {\normalfont \ttfamily componentMatched} is true, then the subroutine should set the radiation component, otherwise it should exit immediately. If the radiation component is to be set, then the routine can allocate the {\normalfont \ttfamily radiationProperties} array as necessary to store any data needed to specify the radiation field. These data should then be set using, if necessary, any relevant information from {\normalfont \ttfamily thisNode}.

The {\normalfont \ttfamily radiationTemperature} directive should specify a subroutine with the following template:
\begin{verbatim}
  subroutine Radiation_Temperature(requestedType,ourType,radiationProperties,radiationTemperature,radiationType)
   implicit none
   integer,          intent(in)                            :: requestedType,ourType
   double precision, intent(in),              dimension(:) :: radiationProperties
   double precision, intent(inout)                         :: radiationTemperature
   integer,          intent(in),    optional, dimension(:) :: radiationType

   if (requestedType /= ourType) return
   if (present(radiationType)) then
      if (all(radiationType /= ourType)) return
   end if
   .
   .
   .
   return
  end subroutine Radiation_Temperature
\end{verbatim}
The tests in the above should always be included so that the subroutine exits immediately if the component type is not active or not requested. Once these tests have been made, the subroutine should set the temperature (in units of Kelvin) of the radiation field (if applicable).

The {\normalfont \ttfamily radiationFlux} directive should specify a subroutine with the following template:
\begin{verbatim}
  subroutine Radiation_Flux(requestedType,ourType,radiationProperties,wavelength,radiationFlux,radiationType)
    implicit none
    integer,          intent(in)                           :: requestedType,ourType
    double precision, intent(in)                           :: wavelength
    double precision, intent(in),             dimension(:) :: radiationProperties
    double precision, intent(inout)                        :: radiationFlux
    integer,          intent(in),   optional, dimension(:) :: radiationType

    if (requestedType /= ourType) return
    if (present(radiationType)) then
       if (all(radiationType /= ourType)) return
    end if
    .
    .
    .
    return
  end subroutine Radiation_Flux
\end{verbatim}
The tests in the above should always be included so that the subroutine exits immediately if the component type is not active or not requested. Once these tests have been made, the subroutine should add the flux (in units of ergs cm$^2$ s$^{-1}$ Hz$^{-1}$ ster$^{-1}$) at the specified {\normalfont \ttfamily wavelength} (in units of \AA) of the radiation field to that in {\normalfont \ttfamily radiationFlux}.

Currently defined radiation component types are:
\begin{description}
 \item [{\normalfont \ttfamily null}] A null component with no radiation.
 \item [{\normalfont \ttfamily CMB}] The cosmic microwave background, assumed to be a perfect blackbody spectrum with a temperature equal to {\normalfont \ttfamily [T\_CMB]}$(1+z)$.
 \item [{\normalfont \ttfamily IGB}] The intergalactic background light, set using the method selected by {\normalfont \ttfamily [radiationIntergalacticBackgroundMethod]; see \S\ref{sec:radiationIGB}}.
\end{description}

\subsubsection{Radiation Components: Intergalactic Background}\label{sec:radiationIGB}

Additional methods for the intergalactic background radiation component can be added using the {\normalfont \ttfamily radiationIntergalacticBackgroundMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily file} method is described by a directive:
\begin{verbatim}
 !# <radiationIntergalacticBackgroundMethod>
 !#  <unitName>Radiation_IGB_File_Initialize</unitName>
 !# </radiationIntergalacticBackgroundMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Radiation\_IGB\_File\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(radiationIntergalacticBackgroundMethod,Radiation_Set_Intergalactic_Background_Do,Radiation_Flux_Intergalactic_Background_Do)
    implicit none
    type(varying_string),          intent(in)    :: radiationIntergalacticBackgroundMethod
    procedure(),          pointer, intent(inout) :: Radiation_Set_Intergalactic_Background_Do,Radiation_Flux_Intergalactic_Background_Do
    
    if (radiationIntergalacticBackgroundMethod == 'myMethod') then
      Radiation_Set_Intergalactic_Background_Do  => My_Method_Set
      Radiation_Flux_Intergalactic_Background_Do => My_Method_Flux
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily radiationIntergalacticBackgroundMethod} input parameter. The procedure pointers {\normalfont \ttfamily Radiation\_Set\_Intergalactic\_Background\_Do} and {\normalfont \ttfamily Radiation\_Flux\_Intergalactic\_Background\_Do} must be set to point to subroutines which set the radiation field and return its flux as described below. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The set subroutine must have the form:
\begin{verbatim}
  subroutine My_Method_Set(thisNode,radiationProperties)
    implicit none
    type(treeNode),   intent(inout), pointer                   :: thisNode
    double precision, intent(inout), allocatable, dimension(:) :: radiationProperties

    return
  end subroutine My_Method_Set
\end{verbatim}
and should set the radiation component as described in \S\ref{sec:radiationComponents}. The flux subroutine must have the form:
\begin{verbatim}
   subroutine My_Method_Flux(radiationProperties,wavelength,radiationFlux)
    implicit none
    double precision, intent(in)                 :: wavelength
    double precision, intent(in),   dimension(:) :: radiationProperties
    double precision, intent(inout)              :: radiationFlux

    return
   end subroutine My_Method_Flux
\end{verbatim}
and should increment {\normalfont \ttfamily radiationFlux} as described in \S\ref{sec:radiationComponents}.

Currently defined intergalactic background radiation methods are:
\begin{description}
 \item [{\normalfont \ttfamily file}] The intergalatic background radiation field, specified as a function of cosmic time, is read from a file. The flux is determined by linearly interpolating to the required time and wavelength. The XML file to read is specified by {\normalfont \ttfamily [radiationIGBFileName]}. An example of the required file structure is:
 \begin{verbatim}
<spectrum>
  <URL>http://adsabs.harvard.edu/abs/1996ApJ...461...20H</URL>
  <description>Cosmic background radiation spectrum from quasars alone.</description>
  <reference>Haardt, F. &amp; Madau, P. 1996, ApJ, 461, 20</reference>
  <source>Francesco Haardt on Aug 6 2005, via Cloudy 08.00</source>
  <wavelengths>
    <datum>0.0002481</datum>
    <datum>0.001489</datum>
    .
    .
    .
    <units>Angstroms</units>
  </wavelengths>
  <spectra>
    <datum>7.039E-49</datum>
    <datum>8.379E-48</datum>
    <datum>1.875E-39</datum>
    <datum>7.583E-38</datum>
    .
    .
    .
    <redshift>0</redshift>
    <units>erg cm^-2 s^-1 Hz^-1 sr^-1</units>
  </spectra>
</spectrum>
 \end{verbatim}
\end{description}
The optional {\normalfont \ttfamily URL}, {\normalfont \ttfamily description}, {\normalfont \ttfamily reference} and {\normalfont \ttfamily source} elements can be used to give the provenance of the data. The {\normalfont \ttfamily wavelengths} element should contain a set of {\normalfont \ttfamily datum} elements each containing a wavelength (in increasing order) at which the spectrum will be tabulated. Wavelengths must be given in Angstroms. Multiple {\normalfont \ttfamily spectra} elements can be given, each specifying the spectrum at a redshift as given in the {\normalfont \ttfamily redshift} element. Each {\normalfont \ttfamily spectra} element must contain an array of {\normalfont \ttfamily datum} elements that gives the spectrum at each wavelength listed in the {\normalfont \ttfamily wavelength} element. Spectra must be in units of erg cm$^{-2}$ s$^{-1}$ Hz$^{-1}$ sr$^{-1}$.

\subsubsection{Satellite Merging Mass Movements}

Additional methods for the satellite merging mass movements can be added using the {\normalfont \ttfamily satelliteMergingMassMovementsMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily simple} method is described by a directive:
\begin{verbatim}
 !# <satelliteMergingMassMovementsMethod>
 !#  <unitName>Satellite_Merging_Mass_Movements_Simple_Initialize</unitName>
 !# </satelliteMergingMassMovementsMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Satellite\_Merging\_Mass\_Movements\_Simple\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(satelliteMergingMassMovementsMethod,Satellite_Merging_Mass_Movement_Get)
    implicit none
    type(varying_string),          intent(in)    :: satelliteMergingMassMovementsMethod
    procedure(),          pointer, intent(inout) :: Satellite_Merging_Mass_Movement_Get
    
    if (satelliteMergingMassMovementsMethod == 'simple') Satellite_Merging_Mass_Movement_Get => My_Method_Get
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily satelliteMergingMassMovementsMethod} input parameter. The procedure pointer {\normalfont \ttfamily Satellite\_Merging\_Mass\_Movement\_Get} must be set to point to a function which sets the mass movement descriptors as described below. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The mass movement subroutine must have the form:
\begin{verbatim}
  subroutine My_Method_Get(thisNode,gasMovesTo,starsMoveTo,hostGasMovesTo,hostStarsMoveTo,mergerIsMajor)
    implicit none
    type(treeNode), intent(inout), pointer  :: thisNode
    integer,        intent(out)             :: gasMovesTo,starsMoveTo,hostGasMovesTo,hostStarsMoveTo
    logical,        intent(out)             :: mergerIsMajor
    .
    .
    .
    return
  end subroutine My_Method_Get
\end{verbatim}
The subroutine must return values for each of the ``{\normalfont \ttfamily MoveTo}'' descriptors to specify where stars and gas from {\normalfont \ttfamily thisNode} and {\normalfont \ttfamily thisNode}'s host node should move to in the host. Allowed values are:
\begin{description}
 \item [{\normalfont \ttfamily movesToDisk}] The material in question moves to the disk of the host node;
 \item [{\normalfont \ttfamily movesToSpheroid}] The material in question moves to the spheroid of the host node;
 \item [{\normalfont \ttfamily doesNotMove}] The material in question does not move (allowed only for host node descriptors).
\end{description}
Additionally, the {\normalfont \ttfamily mergerIsMajor} flag should be set to indicate whether this merger is deemed to be ``major'' (typically defined as one which redistributes mass from a disk into a spheroidal component).

Currently defined satellite merger mass movement methods are:
\begin{description}
 \item [{\normalfont \ttfamily verySimple}] In this case, the satellite is always added to the disk of the host, while material in the host does not move.
 \item [{\normalfont \ttfamily simple}] If the baryonic mass of the satellite exceeds a fraction {\normalfont \ttfamily majorMergerMassRatio} of the baryonic mass of the host then all material is moved to the spheroid of the host. Otherwise, satellite gas moves to the component given by {\normalfont \ttfamily minorMergerGasMovesTo}, satellite stars move to the host spheroid and host material does not move.
 \item [{\normalfont \ttfamily Baugh2005}] If the baryonic mass of the satellite exceeds a fraction {\normalfont \ttfamily majorMergerMassRatio} of the baryonic mass of the host then all material is moved to the spheroid of the host. Otherwise, if the baryonic mass of the satellite exceeds a fraction {\normalfont \ttfamily burstMassRatio} of the baryonic mass of the host and the gas fraction in the host exceeds {\normalfont \ttfamily burstCriticalGasFraction} then all gas is moved to the host spheroid, while the host stellar disk remains in place. For mergers failing both criteria, satellite gas moves to the component given by {\normalfont \ttfamily minorMergerGasMovesTo}, satellite stars move to the host spheroid and host material does not move. 
\end{description}

\subsubsection{Satellite Merging Remnant Sizes}\label{sec:satelliteMergerMassMovementMethod}

Additional methods for the satellite merging remnant sizes can be added using the {\normalfont \ttfamily satelliteMergingRemnantSizeMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily Cole2000} method is described by a directive:
\begin{verbatim}
 !# <satelliteMergingRemnantSizeMethod>
 !#  <unitName>Satellite_Merging_Remnant_Sizes_Cole2000_Initialize</unitName>
 !# </satelliteMergingRemnantSizeMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Satellite\_Merging\_Remnant\_Sizes\_Cole2000\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(satelliteMergingRemnantSizeMethod,Satellite_Merging_Remnant_Size_Do)
    implicit none
    type(varying_string),          intent(in)    :: satelliteMergingRemnantSizeMethod
    procedure(),          pointer, intent(inout) :: Satellite_Merging_Remnant_Size_Do
    
    if (satelliteMergingRemnantSizeMethod == 'myMethod') Satellite_Merging_Remnant_Size_Do => My_Method_Do
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily satelliteMergingRemnantSizeMethod} input parameter. The procedure pointer {\normalfont \ttfamily Satellite\_Merging\_Remnant\_Size\_Do} must be set to point to a function which computes the size of the merger remnant and stores the properties (e.g. radius, circular velocity and specific angular momentum at the half-mass radius) of the \emph{host} node. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The remnant size subroutine must have the form:
\begin{verbatim}
  subroutine My_Method_Do(thisNode)
    implicit none
    type(treeNode), intent(inout), pointer  :: thisNode
    .
    .
    .
    return
  end subroutine My_Method_Do
\end{verbatim}
The subroutine must compute the properties of the merger remnant. Typically these are stored in the {\normalfont \ttfamily Satellite\_Merging\_Remnant\_Sizes\_Properties} module for later retrieval by the appropriate component.

Currently defined satellite merger remnant size methods are:
\begin{description}
 \item [{\normalfont \ttfamily null}] This is a null method which does nothing. It is useful for runs where no baryonic components are included (e.g. for studying dark matter only).
 \item [{\normalfont \ttfamily Cole2000}] Implements the algorithm of \cite{cole_hierarchical_2000} to compute the remnant size. The orbital energy assumed can be adjusted using the {\normalfont \ttfamily mergerRemnantSizeOrbitalEnergy} parameter, which is equivalent to the $f_\mathrm{orbit}$ parameter of \cite{cole_hierarchical_2000}.
 \item [{\normalfont \ttfamily Covington2008}] Implements the algorithm of \cite{covington_predicting_2008} to compute the remnant size. The orbital energy assumed can be adjusted using the {\normalfont \ttfamily mergerRemnantSizeOrbitalEnergy} parameter, which is equivalent to the $f_\mathrm{orbit}$ parameter of \cite{cole_hierarchical_2000}.
\end{description}

\subsubsection{Satellite Merging Remnants: Progenitor Properties}

Additional methods for satellite merging remnant progenitor properties can be added using the {\normalfont \ttfamily satelliteMergingRemnantProgenitorPropertiesMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily standard} method is described by a directive:
\begin{verbatim}
 !# <satelliteMergingRemnantProgenitorPropertiesMethod>
 !#  <unitName>Satellite_Merging_Remnant_Progenitor_Properties_Standard_Init</unitName>
 !# </satelliteMergingRemnantProgenitorPropertiesMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Satellite\_Merging\_Remnant\_Progenitor\_Properties\_Standard\_Init} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(satelliteMergingRemnantProgenitorPropertiesMethod,Satellite_Merging_Remnant_Progenitor_Properties_Get)
    implicit none
    type(varying_string),          intent(in)    :: satelliteMergingRemnantProgenitorPropertiesMethod
    procedure(),          pointer, intent(inout) :: Satellite_Merging_Remnant_Progenitor_Properties_Get
    
    if (satelliteMergingRemnantProgenitorPropertiesMethod == 'myMethod') Satellite_Merging_Remnant_Progenitor_Properties_Get => My_Method_Get
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily satelliteMergingRemnantProgenitorPropertiesMethod} input parameter. The procedure pointer {\normalfont \ttfamily Satellite\_Merging\_Remnant\_Progenitor\_Properties\_Get} must be set to point to a subroutine which computes various properties of the progenitor galaxies involved in the merger, as described below. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The progenitor properties subroutine must have the form:
\begin{verbatim}
  subroutine My_Method_Get(satelliteNode,hostNode,satelliteMass,hostMass,satelliteSpheroidMass &
       & ,hostSpheroidMass,hostSpheroidMassPreMerger,satelliteRadius,hostRadius &
       & ,angularMomentumFactor,remnantSpheroidMass,remnantSpheroidGasMass)
    implicit none
    type(treeNode),   intent(inout), pointer :: satelliteNode,hostNode
    double precision, intent(out)            :: satelliteMass,hostMass,satelliteSpheroidMass, &
       & hostSpheroidMass,hostSpheroidMassPreMerger,satelliteRadius,hostRadius, &
       & angularMomentumFactor,remnantSpheroidMass,remnantSpheroidGasMass
    .
    .
    .
    return
  end subroutine My_Method_Do
\end{verbatim}
The subroutine must compute properties of the merger progenitor galaxies in {\normalfont \ttfamily satelliteNode} and {\normalfont \ttfamily hostNode}: {\normalfont \ttfamily satelliteMass} and {\normalfont \ttfamily hostMass} are the total masses of the two galaxies; {\normalfont \ttfamily satelliteSpheroidMass} and {\normalfont \ttfamily hostSpheroidMass} are the masses of each galaxy that will end up in the spheroid of the merger remnant; {\normalfont \ttfamily hostSpheroidMassPreMerger} is the mass of the host spheroid prior to the merger; {\normalfont \ttfamily satelliteRadius} and {\normalfont \ttfamily hostRadius} are radii of the two galaxies for use in merger remnant size calculations (and so should typically refer to the radius of material that will end up in the merger remnant spheroid); {\normalfont \ttfamily remnantSpheroidMass} is the mass of the spheroid in the remnant; {\normalfont \ttfamily remnantSpheroidGasMass} is the mass of gas in the spheroid of the remnant; and {\normalfont \ttfamily angularMomentumFactor} gives the pseudo-specific angular momentum of the remnant in units of $(\mathrm{G} M_\mathrm{remnant,spheroid} r_\mathrm{remnant,spheroid})^{1/2}$ where $M_\mathrm{remnant,spheroid}$ is the mass of the 
remnant spheroid and $r_\mathrm{remnant,spheroid}$ is the radius of the remnant spheroid.

Currently defined satellite merger progenitor properties methods are:
\begin{description}
 \item [{\normalfont \ttfamily Cole2000}] Implements the algorithm of \cite{cole_hierarchical_2000} to compute the remnant properties. Masses of host and spheroid are set equal to their stellar plus cold gas masses utilizing, while radii are the half-mass radii of each galaxy, including only those components which end up in the remnant spheroid. The angular momentum factor is set to a mass-weighted average of the corresponding factor for each component which will end up in the merger remnant spheroid.
 \item [{\normalfont \ttfamily standard}] Masses of host and spheroid are set equal to their stellar plus cold gas masses utilizing, while radii are a mass-weighted average of the half-mass radii of the components which end up in the merger remnant spheroid. The angular momentum factor is similarly set to a mass-weighted average of the corresponding factor for each component which will end up in the merger remnant spheroid.
\end{description}

\subsubsection{Stellar Astrophysics}

Additional methods for stellar astrophysical properties can be added using the {\normalfont \ttfamily stellarAstrophysicsMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily file} method is described by a directive:
\begin{verbatim}
  !# <stellarAstrophysicsMethod>
  !#  <unitName>Stellar_Astrophysics_File_Initialize</unitName>
  !# </stellarAstrophysicsMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Stellar\_Astrophysics\_File\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(stellarAstrophysicsMethod,Star_Ejected_Mass_Get,Star_Initial_Mass_Get,Star_Metal_Yield_Mass_Get,Star_Lifetime_Get)
    implicit none
    type(varying_string),          intent(in)    :: stellarAstrophysicsMethod
    procedure(),          pointer, intent(inout) :: Star_Ejected_Mass_Get,Star_Initial_Mass_Get,Star_Metal_Yield_Mass_Get,Star_Lifetime_Get
    
    if (stellarAstrophysicsMethod == 'myMethod') then
      Star_Ejected_Mass_Get     => My_Star_Ejected_Mass
      Star_Initial_Mass_Get     => My_Star_Initial_Mass
      Star_Metal_Yield_Mass_Get => My_Star_Metal_Yield_Mass
      Star_Lifetime_Get         => My_Star_Lifetime
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily stellarAstrophysicsMethod} input parameter. The procedure pointers must be set to point to functions which return stellar properties as described below. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The ejected mass and lifetime functions must have the form:
\begin{verbatim}
 double precision function Star_Property(initialMass,metallicity)
    implicit none
    double precision, intent(in) :: initialMass,metallicity
    .
    .
    .
    return
 end function Star_Property
\end{verbatim}
These functions must return the total ejected mass (in $M_\odot$), total metal yield (in $M_\odot$) and lifetime (in Gyr) for a star of the specified {\normalfont \ttfamily initialMass} and {\normalfont \ttfamily metallicity}.

The metal yield function must have the form:
\begin{verbatim}
 double precision function Star_Metal_Yield(initialMass,metallicity,atomIndex)
    implicit none
    double precision, intent(in)           :: initialMass,metallicity
    integer,          intent(in), optional :: atomIndex
    .
    .
    .
    return
 end function Star_Property
\end{verbatim}
This function must return the yield (in $M_\odot$) of the element identified by {\normalfont \ttfamily atomIndex} (as returned by the \hyperlink{atomic.data.F90:atomic_data:atom_lookup}{{\normalfont \ttfamily Atom\_Lookup()}} function from the \hyperlink{atomic.data.F90:atomic_data}{{\normalfont \ttfamily Atomic\_Data}} module) if present, or total metal yield otherwise for a star of the specified {\normalfont \ttfamily initialMass} and {\normalfont \ttfamily metallicity}.

The initial mass function must have the form:
\begin{verbatim}
 double precision function Star_Initial_Mass(lifetime,metallicity)
    implicit none
    double precision, intent(in) :: lifetime,metallicity
    .
    .
    .
    return
 end function Star_Initial_Mass
\end{verbatim}
and should return the initial mass (in $M_\odot$) of a star of given {\normalfont \ttfamily lifetime} (specified in Gyr) and {\normalfont \ttfamily metallicity}.

Currently defined stellar astrophysics methods are:
\begin{description}
 \item [{\normalfont \ttfamily file}] Stellar properties are read from an XML file and interpolated. The structure of the XML file is described in \S\ref{sec:StellarAstrophysicsFile}.
\end{description}

\subsubsection{Stellar Population Properties}

Additional methods for computing properties of stellar populations can be added using the {\normalfont \ttfamily stellarPopulationPropertiesMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily instantaneous} method is described by a directive:
\begin{verbatim}
 !# <stellarPopulationPropertiesMethod>
 !#  <unitName>Stellar_Population_Properties_Instantaneous_Initialize</unitName>
 !# </stellarPopulationPropertiesMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Stellar\_Population\_Properties\_Instantaneous\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(stellarPopulationPropertiesMethod,Stellar_Population_Properties_Rates_Get &
 & ,Stellar_Population_Properties_Scales_Get,Stellar_Population_Properties_History_Count_Get             &
 & ,Stellar_Population_Properties_History_Create_Do)
    implicit none
    type(varying_string),          intent(in)    :: stellarPopulationPropertiesMethod
    procedure(),          pointer, intent(inout) :: Stellar_Population_Properties_Rates_Get  &
 & ,Stellar_Population_Properties_Scales_Get,Stellar_Population_Properties_History_Count_Get &
 & ,Stellar_Population_Properties_History_Create_Do
    
    if (stellarPopulationPropertiesMethod == 'myMethod') then
       Stellar_Population_Properties_Rates_Get         => My_Method_Rates_Get_Procedure
       Stellar_Population_Properties_Scales_Get        => My_Method_Scales_Procedure
       Stellar_Population_Properties_History_Count_Get => My_Method_History_Count_Get_Procedure
       Stellar_Population_Properties_History_Create_Do => My_Method_History_Create_Procedure
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily stellarPopulationPropertiesMethod} input parameter. The procedure pointers {\normalfont \ttfamily Stellar\_Population\_Properties\_Rates\_Get} and {\normalfont \ttfamily Stellar\_Population\_Properties\_Scales\_Get} must be set to point to subroutines which return properties of a stellar population and set scaling factors for ODE error control as described below, while the {\normalfont \ttfamily Stellar\_Population\_Properties\_History\_Count\_Get} and {\normalfont \ttfamily Stellar\_Population\_Properties\_History\_Create\_Do} procedure pointers must be set to point to functions which return the number of histories that will be required by this method and create a suitable history object respectively. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The stellar populations properties subroutine must have the form:
\begin{verbatim}
 subroutine Stellar_Population_Properties_Rates(starFormationRate,fuelAbundances,component,thisNode,thisHistory,stellarMassRate&
       &,stellarAbundancesRates,stellarLuminositiesRates,fuelMassRate,fuelAbundancesRates,energyInputRate)
    implicit none
    implicit none
    double precision,          intent(out)                 :: stellarMassRate,fuelMassRate,energyInputRate
    type(abundancesStructure), intent(out)                 :: stellarAbundancesRates,fuelAbundancesRates
    integer,                   intent(in)                  :: component
    double precision,          intent(out),   dimension(:) :: stellarLuminositiesRates
    double precision,          intent(in)                  :: starFormationRate
    type(abundancesStructure), intent(in)                  :: fuelAbundances
    type(treeNode),            intent(inout), pointer      :: thisNode
    type(history),             intent(inout)               :: thisHistory
    .
    .
    .
    return
 end subroutine Stellar_Population_Properties_Rates
\end{verbatim}
The subroutine is given the {\normalfont \ttfamily starFormationRate} (in $M_\odot$ Gyr$^{-1}$) in {\normalfont \ttfamily thisNode}. Any history information required by this method must be passed in via the {\normalfont \ttfamily history} argument. Stars are forming from fuel material with composition specified by {\normalfont \ttfamily fuelAbundances} and occurring in the specified galactic {\normalfont \ttfamily component} (using the labels provided by the \hyperlink{galactic_structure.options.F90:galactic_structure_options}{{\normalfont \ttfamily Galactic\_Structure\_Options}} module). The subroutine must return the rates of change of stellar and fuel mass (in $M_\odot$ Gyr$^{-1}$) in {\normalfont \ttfamily stellarMassRate} and {\normalfont \ttfamily fuelMassRate} respectively, and the corresponding rates (also in $M_\odot$ Gyr$^{-1}$) of abundance change in {\normalfont \ttfamily stellarAbundancesRates} and {\normalfont \ttfamily fuelAbundancesRates} respectively. Finally, it should return rates of change (in $L_\mathrm{AB}$ Gyr$^{-1}$) of stellar luminosities for all requested output bands in {\normalfont \ttfamily stellarLuminositiesRates}. Additionally, the rate of energy input from stellar 
populations must be returned in {\normalfont \ttfamily energyInputRate}.

The scales procedure should have the form:
\begin{verbatim}
  subroutine Stellar_Population_Properties_Scales_Noninstantaneous(thisHistory,stellarMass,stellarAbundances)
   implicit none
   double precision,          intent(in)    :: stellarMass
   type(abundancesStructure), intent(in)    :: stellarAbundances
   type(history),             intent(inout) :: thisHistory
   .
   .
   .
   return
 end subroutine Stellar_Population_Properties_Scales_Noninstantaneous
\end{verbatim}
and should set scale factors for ODE error control (see \S\ref{sec:ComponentEvolution}) in the stellar population properties history {\normalfont \ttfamily thisHistory}. The {\normalfont \ttfamily stellarMass} and {\normalfont \ttfamily stellarAbundances} (both in $M_\odot$) are provided as input as they are often useful in choosing appropriate scale factors.

The history count function must have the form
\begin{verbatim}
 integer function Stellar_Population_Properties_History_Count()
    implicit none
    .
    .
    return
 end function Stellar_Population_Properties_History_Count
\end{verbatim}
and should return the number of histories that will be required by this method. The history create function must have the form
\begin{verbatim}
  subroutine Stellar_Population_Properties_History_Create(thisNode,thisHistory)
   type(treeNode),  intent(inout), pointer :: thisNode
   type(history),   intent(inout)          :: thisHistory
   .
   .
   .
   return
 end subroutine Stellar_Population_Properties_History_Create
\end{verbatim}
and should create {\normalfont \ttfamily thisHistory} with a suitable set of time steps for {\normalfont \ttfamily thisNode}.

Currently defined stellar population properties methods are:
\begin{description}
 \item [\hyperlink{stellar_populations.properties.instantaneous.F90:stellar_population_properties_instantaneous:stellar_population_properties_rates_instantaneous}{{\normalfont \ttfamily instantaneous}}] Computes stellar population properties using an instantaneous recyclying approximation.
\end{description}

\subsubsection{Stellar Feedback}

Additional methods for stellar feedback can be added using the {\normalfont \ttfamily stellarFeedbackMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily standard} method is described by a directive:
\begin{verbatim}
  !# <stellarFeedbackMethod>
  !#  <unitName>Stellar_Feedback_Standard_Initialize</unitName>
  !# </stellarFeedbackMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Stellar\_Feedback\_Standard\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(stellarFeedbackMethod,Stellar_Feedback_Cumulative_Energy_Input_Get)
    implicit none
    type(varying_string),          intent(in)    :: stellarFeedbackMethod
    procedure(),          pointer, intent(inout) :: Stellar_Feedback_Cumulative_Energy_Input_Get
    
    if (stellarFeedbackMethod == 'myMethod') then
       Stellar_Feedback_Cumulative_Energy_Input_Get => My_Stellar_Feedback_Cumulative_Energy_Input_Get
       .
       .
       .
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily stellarFeedbackMethod} input parameter. The procedure pointer {\normalfont \ttfamily Stellar\_Feedback\_Cumulative\_Energy\_Input\_Get} must be set to point to a function which returns the cumulative energy input from stars as described below. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The function must have the form:
\begin{verbatim}
   double precision function Stellar_Feedback_Cumulative_Energy_Input(initialMass,age,metallicity)
    implicit none
    double precision, intent(in) :: initialMass,age,metallicity
    .
    .
    .
    return
   end function Stellar_Feedback_Cumulative_Energy_Input 
\end{verbatim}
The function must return the cumulative energy input (in $M_\odot$ (km/s)$^2$ from stars of given {\normalfont \ttfamily initialMass} and {\normalfont \ttfamily metallicity} after a time {\normalfont \ttfamily age}.

Currently defined stellar feedback methods are:
\begin{description}
 \item [{\normalfont \ttfamily standard}] This method assumes that the energy input has contributions from stellar winds, Type Ia, Type II and Population III supernovae. The minimum mass required for a star to produce a Type II supernova is specified via {\normalfont \ttfamily initialMassForSupernovaeTypeII} (in $M_\odot$), while the energy per Type II or Ia supernova is specified via {\normalfont \ttfamily supernovaEnergy} (in ergs).
\end{description}

\subsubsection{Stellar Tracks}

Additional methods for stellar tracks can be added using the {\normalfont \ttfamily stellarTracksMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily file} method is described by a directive:
\begin{verbatim}
  !# <stellarTracksMethod>
  !#  <unitName>Stellar_Tracks_Initialize_File</unitName>
  !# </stellarTracksMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Stellar\_Tracks\_Initialize\_File} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(stellarTracksMethod,Stellar_Luminosity_Get,Stellar_Effective_Temperature_Get)
    implicit none
    type(varying_string),          intent(in)    :: stellarTracksMethod
    procedure(),          pointer, intent(inout) :: Stellar_Luminosity_Get,Stellar_Effective_Temperature_Get
    
    if (stellarTracksMethod == 'myMethod') then
       Stellar_Luminosity_Get            => My_Stellar_Luminosity_Get
       Stellar_Effective_Temperature_Get => My_Stellar_Effective_Temperature_Get
       .
       .
       .
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily stellarTracksMethod} input parameter. The procedure pointers {\normalfont \ttfamily Stellar\_Luminosity\_Get} and {\normalfont \ttfamily Stellar\_Effective\_Temperature\_Get} must be set to point to functions which return the luminosity and effective temperatures of stars as described below. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The functions must have the form:
\begin{verbatim}
   double precision function Stellar_Tracks_Function(initialMass,age,metallicity)
    implicit none
    double precision, intent(in) :: initialMass,age,metallicity
    .
    .
    .
    return
   end function Stellar_Tracks_Function 
\end{verbatim}
The luminosity function must return the bolometric luminosity (in $L_\odot$) of a star of given {\normalfont \ttfamily initialMass} and {\normalfont \ttfamily metallicity} after a time {\normalfont \ttfamily age}. The effective temperature function should give the effective temperature (in Kelvin) for the same star.

Currently defined stellar tracks methods are:
\begin{description}
 \item [{\normalfont \ttfamily file}] Stellar tracks are read from an HDF5 file and interpolated in. The structure of the HDF5 is described in \S\ref{sec:StellarTracksFile}.
\end{description}

\subsubsection{Stellar Winds}

Additional methods for stellar winds can be added using the {\normalfont \ttfamily stellarWindsMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily Leitherer1992} method is described by a directive:
\begin{verbatim}
  !# <stellarWindsMethod>
  !#  <unitName>Stellar_Winds_Leitherer1992_Initialize</unitName>
  !# </stellarWindsMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Stellar\_Winds\_Leitherer1992\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(stellarWindsMethod,Stellar_Winds_Mass_Loss_Rate_Get,Stellar_Winds_Terminal_Velocity_Get)
    implicit none
    type(varying_string),          intent(in)    :: stellarWindsMethod
    procedure(),          pointer, intent(inout) :: Stellar_Winds_Mass_Loss_Rate_Get,Stellar_Winds_Terminal_Velocity_Get
    
    if (stellarWindsMethod == 'myMethod') then
       Stellar_Winds_Mass_Loss_Rate_Get    => My_Stellar_Winds_Mass_Loss_Rate_Get
       Stellar_Winds_Terminal_Velocity_Get => My_Stellar_Winds_Terminal_Velocity_Get
       .
       .
       .
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily stellarWindsMethod} input parameter. The procedure pointers {\normalfont \ttfamily Stellar\_Winds\_Mass\_Loss\_Rate\_Get} and {\normalfont \ttfamily Stellar\_Winds\_Terminal\_Velocity\_Get} must be set to point to functions which return the mass loss rate and terminal velocity of winds as described below. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The functions must have the form:
\begin{verbatim}
   double precision function Stellar_Wind_Function(initialMass,age,metallicity)
    implicit none
    double precision, intent(in) :: initialMass,age,metallicity
    .
    .
    .
    return
   end function Stellar_Wind_Function 
\end{verbatim}
The mass loss function must return the rate of mass loss (in $M_\odot$/Gyr) from stars of given {\normalfont \ttfamily initialMass} and {\normalfont \ttfamily metallicity} after a time {\normalfont \ttfamily age}. The terminal velocity function should give the velocity (in km/s) at infinity of the wind for the same stars.

Currently defined stellar winds methods are:
\begin{description}
 \item [{\normalfont \ttfamily Leitherer1992}] Computes wind properties using the fitting functions of \cite{leitherer_deposition_1992} and \glc\ stellar tracks.
\end{description}

\subsubsection{Supernovae Type Ia}

Additional methods for Type 1a supernovae can be added using the {\normalfont \ttfamily supernovaeIaMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily Nagashima} method is described by a directive:
\begin{verbatim}
  !# <supernovaeIaMethod>
  !#  <unitName>Supernovae_Type_Ia_Nagashima_Initialize</unitName>
  !# </supernovaeIaMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Supernovae\_Type\_Ia\_Nagashima\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(supernovaeIaMethod,SNeIa_Cumulative_Number_Get,SNeIa_Cumulative_Yield_Get)
    implicit none
    type(varying_string),          intent(in)    :: supernovaeIaMethod
    procedure(),          pointer, intent(inout) :: SNeIa_Cumulative_Number_Get,SNeIa_Cumulative_Yield_Get
    
    if (supernovaeIaMethod == 'myMethod') then
       SNeIa_Cumulative_Number_Get => My_SNeIa_Cumulative_Number_Get
       SNeIa_Cumulative_Yield_Get  => My_SNeIa_Cumulative_Yield_Get
       .
       .
       .
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily supernovaeIaMethod} input parameter. The procedure pointers {\normalfont \ttfamily SNeIa\_Cumulative\_Number\_Get} and {\normalfont \ttfamily SNeIa\_Cumulative\_Yield\_Get} must be set to point to functions which return the cumulative number of and cumulative yield from Type Ia supernovae as described below. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The cumulative number function must have the form:
\begin{verbatim}
   double precision function SNeIa_Cumulative_Number(initialMass,age,metallicity)
    implicit none
    double precision, intent(in) :: initialMass,age,metallicity
    .
    .
    .
    return
   end function SNeIa_Cumulative_Number 
\end{verbatim}
and must return the number of Type Ia supernovae resulting per $M_\odot$ of stars formed with given {\normalfont \ttfamily initialMass} and {\normalfont \ttfamily metallicity} after a time {\normalfont \ttfamily age}. (Since Type Ia's form in binary systems this function should specifically return the number such that when integrated over the \gls{imf} it gives the correct total number of Type Ia supernovae formed from a single stellar population.)

The cumulative yield function must have the form:
\begin{verbatim}
   double precision function SNeIa_Cumulative_Yield(initialMass,age,metallicity,atomIndex)
    implicit none
    double precision, intent(in)           :: initialMass,age,metallicity
    integer,          intent(in), optional :: atomIndex
    .
    .
    .
    return
   end function SNeIa_Cumulative_Yield 
\end{verbatim}
and should return the yield of the element identified by {\normalfont \ttfamily atomIndex} (as returned by the \hyperlink{atomic.data.F90:atomic_data:atom_lookup}{{\normalfont \ttfamily Atom\_Lookup()}} function from the \hyperlink{atomic.data.F90:atomic_data}{{\normalfont \ttfamily Atomic\_Data}} module) if present, or total metal yield otherwise from Type Ia's resulting from stars defined in the same way as for the cumulative number function.

Currently defined type Ia supernovae methods are:
\begin{description}
 \item [{\normalfont \ttfamily Nagashima}] Computes Type Ia properties using the methods described by \cite{nagashima_metal_2005}.
\end{description}

\subsubsection{Tree Timing}

Additional methods for tree timing (i.e. the time taken to process a given merger tree) can be added using the {\normalfont \ttfamily timePerTreeMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily file} method is described by a directive:
\begin{verbatim}
  !# <timePerTreeMethod>
  !#  <unitName>Galacticus_Time_Per_Tree_File_Initialize</unitName>
  !# </timePerTreeMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Galacticus\_Time\_Per\_Tree\_File\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(timePerTreeMethod,Galacticus_Time_Per_Tree_Get)
    implicit none
    type(varying_string),          intent(in)    :: timePerTreeMethod
    procedure(),          pointer, intent(inout) :: Galacticus_Time_Per_Tree_Get
    
    if (timePerTreeMethod == 'myMethod') then
       Galacticus_Time_Per_Tree_Get => My_Time_Per_Tree_Get
       .
       .
       .
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily timePerTreeMethod} input parameter. The procedure pointer {\normalfont \ttfamily Galacticus\_Time\_Per\_Tree\_Get} must be set to point to a function which returns an estimate of the time taken (in seconds) to process a merger tree. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The function must have the form:
\begin{verbatim}
   double precision function Time_Per_Tree(treeRootMass)
    implicit none
    double precision, intent(in) :: treeRootMass
    .
    .
    .
    return
   end function Time_Per_Tree 
\end{verbatim}
The function must return an estimate of the time taken (in seconds) to process a merger tree with the given {\normalfont \ttfamily treeRootMass}.

Currently defined tree timing methods are:
\begin{description}
 \item [{\normalfont \ttfamily file}] This method reads coefficients of a simple fitting formula for the processing time from a file, specified via the {\normalfont \ttfamily [timePerTreeFitFileName]} parameter (see \S\ref{sec:TreeTimingFile}).
\end{description}

\subsection{Events}

Events are triggered during merger tree evolution. Examples are when a node needs to be promoted to its parent node, or when a minor node merges with its parent.

\subsubsection{Node Merger Events}

Additional methods for the node merging (i.e. when a non-primary progenitor merges with its parent) can be added using the {\normalfont \ttfamily nodeMergersMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily singleLevelHierarchy} method is described by a directive:
\begin{verbatim}
  !# <nodeMergersMethod>
  !#  <unitName>Events_Node_Merger_Initialize_SLH</unitName>
  !# </nodeMergersMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Satellite\_Time\_Until\_Merging\_Lacey\_Cole\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
   subroutine Events_Node_Merger_Initialize(nodeMergersMethod,Events_Node_Merger_Do)
    implicit none
    type(varying_string),          intent(in)    :: nodeMergersMethod
    procedure(),          pointer, intent(inout) :: Events_Node_Merger_Do

    if (nodeMergersMethod.eq.'myMethod') Events_Node_Merger_Do => My_Method_Procedure

    return
  end subroutine Events_Node_Merger_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily nodeMergersMethod} input parameter. The procedure pointer {\normalfont \ttfamily Events\_Node\_Merger\_Do} must be set to point to a subroutine which handles the merging event as described below. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The node merging subroutine must have the form:
\begin{verbatim}
 subroutine Events_Node_Merger_Do(thisNode)
    implicit none
    type(treeNode), intent(inout), pointer :: thisNode
    .
    .
    .
    return
  end subroutine Events_Node_Merger_Do_SLH
\end{verbatim}
The function must perform any processing required for the merger, and move {\normalfont \ttfamily thisNode} to the linked list of satellite nodes in {\normalfont \ttfamily thisNode\%parentNode}.

Currently defined node merger event methods are:
\begin{description}
 \item [\hyperlink{events.node_merger.single_level_hierarchy.F90:events_node_mergers_slh:events_node_merger_do_slh}{{\normalfont \ttfamily singleLevelHierarchy}}] The node merger is handled by placing the merging node into the linked list of satellites of the parent node. Any satellites in the merging node are also promoted to be satellites in the new node, thereby maintaining just a single hierarchy level of substructure.
\end{description}

\subsubsection{Node Promotion Events}

Additional methods for node promotion (i.e. when a primary progenitor reaches its parent halo) can be added using the {\normalfont \ttfamily nodePromotionTask} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily basic} tree node method uses this directive as follows:
\begin{verbatim}
  !# <nodePromotionTask>
  !#  <unitName>Tree_Node_Basic_Promote</unitName>
  !# </nodePromotionTask>
\end{verbatim}
Here, {\normalfont \ttfamily Tree\_Node\_Basic\_Promote} is the name of a subroutine which will be called to perform whatever tasks are required prior to the promotion. The subroutine must have the following form:
\begin{verbatim}
   subroutine Node_Promotion_Task(thisNode)
    implicit none
    type(treeNode), pointer, intent(inout) :: thisNode
    .
    .
    .
    return
  end subroutine Node_Promotion_Task
\end{verbatim}
where {\normalfont \ttfamily thisNode} is the node about to be promoted.

\subsection{Tasks}

Tasks are any processing which must be performed on a node as a result of some specific event (such as a merger).

\subsubsection{Calculation Reset Tasks}\label{sec:CalculationResetTask}

Additional methods for calculation reset tasks (i.e. flagging that the properties of a node may have changed so that any calculations must be performed anew) can be added using the {\normalfont \ttfamily calculationResetTask} directive. The directive should contain a single argument, giving the name of a subroutine to be called to perform the task. For example, the standard hot halo component adds a task as follows:
\begin{verbatim}
  !# <calculationResetTask>
  !#  <unitName>Tree_Node_Hot_Halo_Reset_Standard</unitName>
  !# </calculationResetTask>
\end{verbatim}
Here, {\normalfont \ttfamily Tree\_Node\_Hot\_Halo\_Reset\_Standard} is the name of a subroutine which will be called to perform whatever tasks are required. The subroutine must have the following form:
\begin{verbatim}
   subroutine Reset_Task(thisNode)
    implicit none
    type(treeNode), pointer, intent(inout) :: thisNode
    .
    .
    .
    return
  end subroutine Prederivative_Task
\end{verbatim}
where {\normalfont \ttfamily thisNode} is the node for which derivatives will be computed. Tasks typically involve precomputing quantities that will be used in finding the derivatives or resetting the state so that stored quantities will be recomputed as needed.

\subsubsection{Decode Property Identifier Tasks}\label{sec:DecodePropertyIndentifierTask}

Additional property identifier decoding tasks (i.e. determining the name of a property from a set of integer identifiers) can be added using the {\normalfont \ttfamily decodePropertyIdentifiersTask} directive. The directive should contain a single argument, giving the name of a subroutine to be called to perform the task. For example, the Hernquist spheroid component adds a task as follows:
\begin{verbatim}
  !# <decodePropertyIdentifiersTask>
  !#  <unitName>Hernquist_Spheroid_Property_Identifiers_Decode</unitName>
  !# </decodePropertyIdentifiersTask>
\end{verbatim}
Here, {\normalfont \ttfamily Hernquist\_Spheroid\_Property\_Identifiers\_Decode} is the name of a subroutine which will be called to perform the decoding task. The subroutine must have the following form:
\begin{verbatim}
   subroutine Property_Identifier_Decode_Task(propertyComponent,propertyObject,propertyIndex,matchedProperty,propertyName)
    implicit none
    integer,              intent(in)    :: propertyComponent,propertyObject,propertyIndex
    logical,              intent(inout) :: matchedProperty
    type(varying_string), intent(inout) :: propertyName
    .
    .
    .
    return
  end subroutine Property_Identifier_Decode_Task
\end{verbatim}
The task should check whether {\normalfont \ttfamily propertyComponent} matches its stored {\normalfont \ttfamily componentIndex} value. If it does, it should set {\normalfont \ttfamily propertyName} to a suitable name (e.g. {\normalfont \ttfamily hernquistSpheroid::stellarMass}) and set {\normalfont \ttfamily matchedProperty}$=${\normalfont \ttfamily true}. The value of {\normalfont \ttfamily propertyObject} will be either {\normalfont \ttfamily objectTypeProperty} indicating that the object in question is a standard property, or {\normalfont \ttfamily objectTypeHistory} indicating that it is a history. The value of {\normalfont \ttfamily propertyIndex} then gives the position of the object in question in the array of properties or histories.

\subsubsection{Evolution Timestep Tasks}

Merger tree nodes are evolved over some fixed timestep before evolution is stopped and other processing is allowed. The timestep is always sufficiently small such that the node does not evolve past the time of its parent node, nor does it evolve past the time of any of its satellite nodes. An arbitrary number of other criteria can be used to adjust the timestep. Such a criterion can be added using the {\normalfont \ttfamily timeStepsTask} directive. For example, the {\normalfont \ttfamily simple} timestep task adds itself using
\begin{verbatim}
 !# <timeStepsTask>
 !#  <unitName>Merger_Tree_Timestep_Simple</unitName>
 !# </timeStepsTask>
\end{verbatim}
Here, {\normalfont \ttfamily unitName} gives the name of the subroutine to be called to (possibly) adjust the timestep. It should have the following form:
\begin{verbatim}
  subroutine My_Timestep(thisNode,timeStep,End_Of_Timestep_Task,report,lockNode,lockType)
    implicit none
    type     (treeNode      ), intent(inout), pointer           :: thisNode
    procedure(              ), intent(inout), pointer           :: End_Of_Timestep_Task
    double precision         , intent(inout)                    :: timeStep
    logical                  , intent(in   )                    :: report
    type     (treeNode      ), intent(inout), pointer, optional :: lockNode
    type     (varying_string), intent(inout),          optional :: lockType
    .
    .
    .
    return
  end subroutine My_Timestep
\end{verbatim}
This subroutine should compute a suitable timestep for {\normalfont \ttfamily thisNode} and, if it is less than the currently defined value of {\normalfont \ttfamily timeStep} should set {\normalfont \ttfamily timeStep} to that value. Optionally, the procedure pointer {\normalfont \ttfamily End\_Of\_Timestep\_Task} can be set to point to a subroutine which will be called after the node is evolved to the end of the timestep. It is acceptable for this pointer to be null. Note that the {\normalfont \ttfamily End\_Of\_Timestep\_Task} will only be called for the task which provided the shortest timestep---other tasks can always request to be called again when the next timestep is determined. The subroutine to be called at the end of the timestep must have the form:
\begin{verbatim}
  subroutine My_End_Of_Timestep_Task(thisTree,thisNode,deadlockStatus)
    implicit none
    type(mergerTree), intent(in)             :: thisTree
    type(treeNode),   intent(inout), pointer :: thisNode
    integer,          intent(inout)          :: deadlockStatus
    .
    .
    .
    return
  end subroutine My_End_Of_Timestep_Task
\end{verbatim}
The {\normalfont \ttfamily deadlockStatus} argument should be set to {\normalfont \ttfamily isNotDeadlocked} (provided by the \hyperlink{merger_trees.evolve.deadlock_options.F90:merger_trees_evolve_deadlock_status}{\normalfont \ttfamily Merger\_Trees\_Evolve\_Deadlock\_Status} module) if, and only if, the end of timestep task makes some change to the state of the tree (e.g. merging a node), to indicate that the tree was not deadlocked in this pass (i.e. something actually changed in the tree).

If the {\normalfont \ttfamily report} argument is {\normalfont \ttfamily true} then the function should report the value of {\normalfont \ttfamily timestep} prior to exiting. (This is used in reporting on timestepping criteri in deadlocked trees.) It is recommended that the report be made using the \hyperlink{merger_trees.evolve.timesteps.report.F90:evolve_to_time_reports:evolve_to_time_report}{\normalfont \ttfamily Evolve\_To\_Time\_Report()} function. Additionally, if the optional {\normalfont \ttfamily lockNode} and {\normalfont \ttfamily lockType} arguments are present then additional information can be supplied to aid in diagnosing deadlock conditions. If the current task is limiting the timestep then the {\normalfont \ttfamily lockNode} pointer should be set to point to whichever node is causing the limit (which may be {\normalfont \ttfamily thisNode} or some other node, e.g. a satellite of {\normalfont \ttfamily thisNode}, etc.), and {\normalfont \ttfamily lockType} should be set to a short description label identifying the type of limit.

\subsubsection{Galactic Component Density}\label{sec:GalacticComponentDensity}

The function {\normalfont \ttfamily Galactic\_Structure\_Density()} computes the density of material at a given position within a node. To have their density counted, each component must register a task using:
\begin{verbatim}
 !# <densityTask>
 !#  <unitName>Density_Procedure</unitName>
 !# </densityTask>
\end{verbatim}
where {\normalfont \ttfamily Density\_Procedure} is the name of a function with the following template
\begin{verbatim}
 double precision function Density_Procedure(thisNode,position,coordinateSystem,componentType,massType,weightBy,weightIndex,haloLoaded)
    type(treeNode),   intent(inout), pointer  :: thisNode
    integer,          intent(in)              :: massType,coordinateSystem,componentType,weightBy,weightIndex
    double precision, intent(in)              :: radius
    logical         , intent(in),    optional :: haloLoaded
    .
    .
    .
    return
 end function Density_Procedure
\end{verbatim}
If {\normalfont \ttfamily componentType} is a match to the component then the function should return the density of the component matching type {\normalfont \ttfamily massType} at {\normalfont \ttfamily position} for {\normalfont \ttfamily thisNode}. {\normalfont \ttfamily componentType} and {\normalfont \ttfamily massType} can take one of the values described in \S\ref{sec:ComponentMassTypes}. In the above ``density'' can actually refer to different quantities depending on the values of {\normalfont \ttfamily weightBy} (and {\normalfont \ttfamily weightIndex}):
\begin{description}
\item [{\normalfont \ttfamily weightByMass}] The actual mass should be returned (the value of {\normalfont \ttfamily weightIndex} is irrelevant);
\item [{\normalfont \ttfamily weightByLuminosity}] The {\normalfont \ttfamily weightIndex}$^\mathrm{th}$ luminosity should be returned.
\end{description}
If {\normalfont \ttfamily haloLoaded}$=${\normalfont \ttfamily true} (which should be the default if this option is not present), then the effects of baryonic loading on the halo profile should be taken into account where necessary. Otherwise, the effects of baryonic loading should be ignored.

\subsubsection{Galactic Component Enclosed Mass}

The function {\normalfont \ttfamily Galactic\_Structure\_Enclosed\_Mass()} computes the mass within a specified radius in a node. To have their mass counted, each component must register a task using:
\begin{verbatim}
 !# <enclosedMassTask>
 !#  <unitName>Enclosed_Mass_Procedure</unitName>
 !# </enclosedMassTask>
\end{verbatim}
where {\normalfont \ttfamily Enclosed\_Mass\_Procedure} is the name of a function with the following template
\begin{verbatim}
 double precision function Enclosed_Mass_Procedure(thisNode,radius,componentType,massType,weightBy,weightIndex,haloLoaded)
    type(treeNode),   intent(inout), pointer  :: thisNode
    integer,          intent(in)              :: massType,componentType,weightBy,weightIndex
    double precision, intent(in)              :: radius
    logical         , intent(in),    optional :: haloLoaded
    .
    .
    .
    return
 end function Enclosed_Mass_Procedure
\end{verbatim}
If {\normalfont \ttfamily componentType} is a match to the component then the function should return the ``mass'' of the component matching type {\normalfont \ttfamily massType} within {\normalfont \ttfamily radius} for {\normalfont \ttfamily thisNode}.  {\normalfont \ttfamily componentType} and {\normalfont \ttfamily massType} can take one of the values described in \S\ref{sec:ComponentMassTypes}.
If {\normalfont \ttfamily radius} is equal to or greater than {\normalfont \ttfamily radiusLarge} the routine should the total ``mass'' (i.e. ``mass'' within infinite radius). In the above ``mass'' can actually refer to different quantities depending on the values of {\normalfont \ttfamily weightBy} (and {\normalfont \ttfamily weightIndex}):
\begin{description}
\item [{\normalfont \ttfamily weightByMass}] The actual mass should be returned (the value of {\normalfont \ttfamily weightIndex} is irrelevant);
\item [{\normalfont \ttfamily weightByLuminosity}] The {\normalfont \ttfamily weightIndex}$^\mathrm{th}$ luminosity should be returned.
\end{description}
If {\normalfont \ttfamily haloLoaded}$=${\normalfont \ttfamily true} (which should be the default if this option is not present), then the effects of baryonic loading on the halo profile should be taken into account where necessary. Otherwise, the effects of baryonic loading should be ignored.

\subsubsection{Galactic Component Rotation Curve}

The function {\normalfont \ttfamily Galactic\_Structure\_Rotation\_Curve()} computes the rotation curve at a specified radius in a node. To have their contribution counted, each component must register a task using:
\begin{verbatim}
 !# <rotationCurveTask>
 !#  <unitName>Rotation_Curve_Procedure</unitName>
 !# </rotationCurveTask>
\end{verbatim}
where {\normalfont \ttfamily Rotation\_Curve\_Procedure} is the name of a function with the following template
\begin{verbatim}
 double precision function Rotation_Curve_Procedure(thisNode,radius,componentType,massType,haloLoaded)
    type(treeNode),   intent(inout), pointer  :: thisNode
    integer,          intent(in)              :: massType,componentType
    double precision, intent(in)              :: radius
    logical         , intent(in),    optional :: haloLoaded
    .
    .
    .
    return
 end function Rotation_Curve_Procedure
\end{verbatim}
If {\normalfont \ttfamily componentType} is a match to the component then the procedure should return the contribution to the rotation curve due to the component matching type {\normalfont \ttfamily massType} within {\normalfont \ttfamily radius} for {\normalfont \ttfamily thisNode}. {\normalfont \ttfamily componentType} and {\normalfont \ttfamily massType} can take one of the values described in \S\ref{sec:ComponentMassTypes}. If {\normalfont \ttfamily haloLoaded}$=${\normalfont \ttfamily true} (which should be the default if this option is not present), then the effects of baryonic loading on the halo profile should be taken into account where necessary. Otherwise, the effects of baryonic loading should be ignored.

\subsubsection{Galactic Component Rotation Curve Gradient}

The function {\normalfont \ttfamily Galactic\_Structure\_Rotation\_Curve\_Gradient()} computes the gradient of the rotation curve at a specified radius in a node. To have their contribution counted, each component must register a task using:
\begin{verbatim}
 !# <rotationCurveGradientTask>
 !#  <unitName>Rotation_Curve_Gradient_Procedure</unitName>
 !# </rotationCurveGradientTask>
\end{verbatim}
where {\normalfont \ttfamily Rotation\_Curve\_Gradient\_Procedure} is the name of a function with the following template
\begin{verbatim}
 double precision function Rotation_Curve_Gradient_Procedure(thisNode,radius,componentType,massType,haloLoaded)
    type(treeNode),   intent(inout), pointer  :: thisNode
    integer,          intent(in)              :: massType,componentType
    double precision, intent(in)              :: radius
    logical         , intent(in),    optional :: haloLoaded
    .
    .
    .
    return
 end function Rotation_Curve_Gradient_Procedure
\end{verbatim}
If {\normalfont \ttfamily componentType} is a match to the component then the function should return the contribution to the gradient of $V_\mathrm{c}^2(r)$ due to the component matching type {\normalfont \ttfamily massType} within {\normalfont \ttfamily radius} for {\normalfont \ttfamily thisNode}. \emph{Note that this is the gradient of the square of the rotation curve to permit gradients to be directly summed.} {\normalfont \ttfamily componentType} and {\normalfont \ttfamily massType} can take one of the values described in \S\ref{sec:ComponentMassTypes}. If {\normalfont \ttfamily haloLoaded}$=${\normalfont \ttfamily true} (which should be the default if this option is not present), then the effects of baryonic loading on the halo profile should be taken into account where necessary. Otherwise, the effects of baryonic loading should be ignored.

\subsubsection{Galactic Component Potential}

The function {\normalfont \ttfamily Galactic\_Structure\_Potential()} computes the potential at a specified radius in a node. To have their contribution counted, each component must register a task using:
\begin{verbatim}
  !# <potentialTask>
  !#  <unitName>Potential_Task</unitName>
  !# </potentialTask>
\end{verbatim}
where {\normalfont \ttfamily Potential\_Task} is the name of a function with the following template
\begin{verbatim}
 double precision function Potential_Procedure(thisNode,radius,componentType,massType,haloLoaded)
    type(treeNode),   intent(inout), pointer   :: thisNode
    integer,          intent(in),    optional  :: componentType  
    double precision, intent(in)               :: radius
    logical         , intent(in),    optional :: haloLoaded
    .
    .
    return
 end function Potential_Procedure
\end{verbatim}
If {\normalfont \ttfamily componentType} is a match to the component then the procedure should return the contribution to the rotation curve due to the component matching type {\normalfont \ttfamily massType} within {\normalfont \ttfamily radius} for {\normalfont \ttfamily thisNode}. {\normalfont \ttfamily componentType} and {\normalfont \ttfamily massType} can take one of the values described in \S\ref{sec:ComponentMassTypes}. If {\normalfont \ttfamily haloLoaded}$=${\normalfont \ttfamily true} (which should be the default if this option is not present), then the effects of baryonic loading on the halo profile should be taken into account where necessary. Otherwise, the effects of baryonic loading should be ignored.

\subsubsection{Galactic Component Surface Density}

The function {\normalfont \ttfamily Galactic\_Structure\_Surface\_Density()} computes the surface density of material at a given position within a node. Note that while a 3-D position is specified the routine should return the surface density corresponding to integrating the component density through the minor axis (typically the $z$-axis). To have their surface density counted, each component must register a task using:
\begin{verbatim}
 !# <surfaceDensityTask>
 !#  <unitName>Surface_Density_Procedure</unitName>
 !# </surfaceDensityTask>
\end{verbatim}
where {\normalfont \ttfamily Surface\_Density\_Procedure} is the name of a function with the following template
\begin{verbatim}
 double precision function Surface_Density_Procedure(thisNode,position,coordinateSystem,componentType,massType,haloLoaded)
    type(treeNode),   intent(inout), pointer     :: thisNode
    integer,          intent(in)                 :: massType,coordinateSystem,componentType
    double precision, intent(in),    dimension(3):: position
    logical         , intent(in),    optional    :: haloLoaded
    .
    .
    .
    return
 end function Surface_Density_Procedure
\end{verbatim}
If {\normalfont \ttfamily componentType} is a match to the component then the function should return the surface density of the component matching type {\normalfont \ttfamily massType} at {\normalfont \ttfamily position} for {\normalfont \ttfamily thisNode}. {\normalfont \ttfamily componentType} and {\normalfont \ttfamily massType} can take one of the values described in \S\ref{sec:ComponentMassTypes}.
The coordinate system in which {\normalfont \ttfamily position} is specified is given by {\normalfont \ttfamily coordinateSystem} which can take on the following values:
\begin{description}
 \item [{\normalfont \ttfamily coordinateSystemCartesian}] Cartesian $(x,y,z)$;
 \item [{\normalfont \ttfamily coordinateSystemSpherical}] Spherical $(r,\theta,\phi)$;
 \item [{\normalfont \ttfamily coordinateSystemCylindrical}] Cylindrical $(R,\phi,z)$.
\end{description}
If {\normalfont \ttfamily haloLoaded}$=${\normalfont \ttfamily true} (which should be the default if this option is not present), then the effects of baryonic loading on the halo profile should be taken into account where necessary. Otherwise, the effects of baryonic loading should be ignored.

\subsubsection{Halo Formation Events}\label{sec:HaloFormationEvents}

Tasks to be performed when a halo is deemed to have ``formed'' (or reformed) can be registered using the {\normalfont \ttfamily haloFormationTask} directive. For example, the {\normalfont \ttfamily Tree\_Node\_Methods\_Hot\_Halo} module registers a task using
\begin{verbatim}
 !# <haloFormationTask>
 !#  <unitName>Hot_Halo_Formation_Task</unitName>
 !# </haloFormationTask>
\end{verbatim}
The contents of {\normalfont \ttfamily <unitName>} should give the name of the subroutine to be called on halo formation. The subroutine should have a single argument, {\normalfont \ttfamily thisNode}, which is the node that has (re)formed.

\subsubsection{HDF5 File Close}\label{sec:HDFFileClose}

Tasks to be performed just prior to closing the \glc\ output HDF5 file (typically involving writing accumulated data to that file) can be registered using the {\normalfont \ttfamily hdfPreCloseTask} directive. For example, the {\normalfont \ttfamily Merger\_Tree\_Timesteps\_History} module registers a task using
\begin{verbatim}
 !# <hdfPreCloseTask>
 !#  <unitName>Merger_Tree_History_Write</unitName>
 !# </hdfPreCloseTask>
\end{verbatim}
The contents of {\normalfont \ttfamily <unitName>} should give the name of the subroutine to be called prior to HDF5 file closure. The subroutine should have no arguments.

\subsubsection{Initial Mass Functions}\label{sec:imfTasks}

New \gls{imf} s can be added using the {\normalfont \ttfamily imfRegister} and {\normalfont \ttfamily imfRegisterName} task directives. For example, the {\normalfont \ttfamily Salpeter} \gls{imf} is registered using the directives:
\begin{verbatim}
 !# <imfRegister>
 !#  <unitName>Star_Formation_IMF_Register_Salpeter</unitName>
 !# </imfRegister>
\end{verbatim}
and
\begin{verbatim}
 !# <imfRegisterName>
 !#  <unitName>Star_Formation_IMF_Register_Name_Salpeter</unitName>
 !# </imfRegisterName>
\end{verbatim}
The {\normalfont \ttfamily unitName} tags specify subroutines that are called to register the \gls{imf}. These subroutines should have the following forms:
\begin{verbatim}
 subroutine Star_Formation_IMF_Register_My_IMF(imfAvailableCount)
   integer, intent(inout) :: imfAvailableCount

   imfAvailableCount=imfAvailableCount+1
   myImfIndex       =imfAvailableCount
   return
 end subroutine Star_Formation_IMF_Register_My_IMF

 subroutine Star_Formation_IMF_Register_Name_My_IMF(imfNames,imfDescriptors)
   type(varying_string), intent(inout), dimension(:) :: imfNames,imfDescriptors

   imfNames      (myImfIndex)="Salpeter"
   imfDescriptors(myImfIndex)="Salpeter"
   return
 end subroutine Star_Formation_IMF_Register_Name_My_IMF
\end{verbatim}
The first routine should increment the {\normalfont \ttfamily imfAvailableCount} counter by 1 and keep a record of the resulting index---this will be the index by which the \gls{imf} is referred to. The second routine should store the name and descriptor of the \gls{imf} in the appropriate position in the supplied {\normalfont \ttfamily imfNames()} and {\normalfont \ttfamily imfDescriptors()} arrays. The ``name'' is the label used to identify the \gls{imf} in input parameters for example. The ``descriptor'' should be a label sufficient to uniquely identify the \gls{imf}, and is used, for example, in constructing file names when storing \gls{imf} related data. Often, the name and descriptor are identical. However, if the \gls{imf} has user-specififable parameters then those parameters should be encoded into the descriptor.

Each registered \gls{imf} should supply a set of functions as described in \S\ref{sec:IMF_functions}.

\subsubsection{Merger Tree Extra Output Tasks}

Extra outputs for merger trees (i.e. those which do not involve output of a fixed number of properties for every node---examples might be star formation histories for a subset of galaxies) can be added using the directive: {\normalfont \ttfamily mergerTreeExtraOutputTask}. The directive should give the name of the subroutine to be called to perform the task. A template for this task is:
\begin{verbatim}
  !# <mergerTreeExtraOutputTask>
  !#  <unitName>Galacticus_Extra_Output_Example</unitName>
  !# </mergerTreeExtraOutputTask>
  subroutine Galacticus_Extra_Output_Example(thisNode,iOutput,treeIndex,nodePassesFilter)
    implicit none
    type(treeNode),          intent(inout), pointer :: thisNode
    integer,                 intent(in)             :: iOutput
    integer(kind=kind_int8), intent(in)             :: treeIndex
    logical,                 intent(in)             :: nodePassesFilter
    .
    .
    .
    return
  end subroutine Galacticus_Extra_Output_Example
\end{verbatim}
The subroutine will be called for each node in each merger tree at each output, and should perform whatever extra output related to {\normalfont \ttfamily thisNode}. The index of the output and tree are provided as {\normalfont \ttfamily iOutput} and {\normalfont \ttfamily treeIndex} for reference, and may be used in organizing output. The {\normalfont \ttfamily nodePassesFilter} flag will be set to {\normalfont \ttfamily true} if {\normalfont \ttfamily thisNode} passed all active output filters (see \S\ref{sec:methodsGalacticFilter}). If it is {\normalfont \ttfamily false} then typically no output should occur (although other tasks may still be undertaken).

\subsubsection{Merger Tree Output Tasks}

Additional outputs for merger trees can be added using three directives: {\normalfont \ttfamily mergerTreeOutputPropertyCount}, {\normalfont \ttfamily mergerTreeOutputNames} and {\normalfont \ttfamily mergerTreeOutputTask}. Each directive should give the name of the subroutine to be called to perform the task and, additionally, a name for sorting (this should be the same for all three directives and ensures that output tasks are always called in the correct order). Templates for these tasks are:
\begin{verbatim}
  !# <mergerTreeOutputNames>
  !#  <unitName>Galacticus_Output_Tree_Example_Names</unitName>
  !#  <sortName>Galacticus_Output_Tree_Example</sortName>
  !# </mergerTreeOutputNames>
  subroutine Galacticus_Output_Tree_Example_Names(integerProperty,integerPropertyNames,integerPropertyComments,integerPropertyUnitsSI &
       &,doubleProperty,doublePropertyNames,doublePropertyComments,doublePropertyUnitsSI,time)
    implicit none
    double precision, intent(in)                  :: time
    integer,          intent(inout)               :: integerProperty,doubleProperty
    character(len=*), intent(inout), dimension(:) :: integerPropertyNames,integerPropertyComments,doublePropertyNames &
         &,doublePropertyComments
    double precision, intent(inout), dimension(:) :: integerPropertyUnitsSI,doublePropertyUnitsSI
    .
    .
    .
    return
  end subroutine Galacticus_Output_Tree_Example_Names

  !# <mergerTreeOutputPropertyCount>
  !#  <unitName>Galacticus_Output_Tree_Example_Property_Count</unitName>
  !#  <sortName>Galacticus_Output_Tree_Example</sortName>
  !# </mergerTreeOutputPropertyCount>
  subroutine Galacticus_Output_Tree_Example_Property_Count(integerPropertyCount,doublePropertyCount)
    implicit none
    integer, intent(inout) :: integerPropertyCount,doublePropertyCount
    .
    .
    .
    return
  end subroutine Galacticus_Output_Tree_Example_Property_Count

  !# <mergerTreeOutputTask>
  !#  <unitName>Galacticus_Output_Tree_Example</unitName>
  !#  <sortName>Galacticus_Output_Tree_Example</sortName>
  !# </mergerTreeOutputTask>
  subroutine Galacticus_Output_Tree_Example(thisNode,integerProperty,integerBufferCount,integerBuffer,doubleProperty&
       &,doubleBufferCount,doubleBuffer)
    implicit none
    type(treeNode),          intent(inout), pointer :: thisNode
    integer,                 intent(inout)          :: integerProperty,integerBufferCount,doubleProperty,doubleBufferCount
    integer(kind=kind_int8), intent(inout)          :: integerBuffer(:,:)
    double precision,        intent(inout)          :: doubleBuffer(:,:)
    .
    .
    .
    return
  end subroutine Galacticus_Output_Tree_Example
\end{verbatim}
The {\normalfont \ttfamily mergerTreeOutputPropertyCount} subroutine must simply increment {\normalfont \ttfamily integerPropertyCount} and {\normalfont \ttfamily doublePropertyCount} by the number of integer and double precision properties that will be output respectively. The {\normalfont \ttfamily mergerTreeOutputNames} subroutine must store the dataset names, comments and units in the SI system\footnote{For dimensionless quantities, the units may be set to zero. In such cases, the {\normalfont \ttfamily unitsInSI} attribute for the dataset will not be written to the \protect\glc\ output file.} for each integer and double precision property in the supplied arrays. The value of {\normalfont \ttfamily integerProperty} and {\normalfont \ttfamily doubleProperty} should be incremented by 1 before each property name/comment is set---these then supply the position within the input arrays in which to store the name. The {\normalfont \ttfamily mergerTreeOutputTask} subroutine must similarly place the desired property values for {\normalfont \ttfamily thisNode} into the supplied arrays. The value of {\normalfont \ttfamily integerProperty} and {\normalfont \ttfamily doubleProperty} should be incremented by 1 
before each property value is set. The value can then be stored in, for example, {\normalfont \ttfamily integerBuffer(integerBufferCount,integerProperty)}.

\subsubsection{Merger Tree Pre-Construction Tasks}\label{sec:MergerTreePreConstructionTask}

Additional tasks to be performed prior to the construction of each merger tree can be added using the {\normalfont \ttfamily mergerTreePreTreeConstructionTask} directive. For example, the tree timing task uses this directive as follows:
\begin{verbatim}
  !# <mergerTreePreTreeConstructionTask>
  !#   <unitName>Meta_Tree_Timing_Pre_Construction</unitName>
  !# </mergerTreePreTreeConstructionTask>
\end{verbatim}
Here, {\normalfont \ttfamily Meta\_Tree\_Timing\_Pre\_Construction} is the name of a subroutine which will be called to perform whatever tasks are required. The subroutine must have the following form:
\begin{verbatim}
   subroutine Merger_Tree_PreConstruction_Task()
    implicit none
    .
    .
    .
    return
  end subroutine Merger_Tree_PreConstruction_Task
\end{verbatim}
The subroutine will be called once for each tree, before the tree has been constructed.

\subsubsection{Merger Tree Post-Evolution Tasks}\label{sec:MergerTreePostEvolveTask}

Additional tasks to be performed after the evolution (and subsequent destruction) of each merger tree can be added using the {\normalfont \ttfamily mergerTreePostEvolveTasker} directive. For example, the tree timing task uses this directive as follows:
\begin{verbatim}
  !# <mergerTreePostEvolveTask>
  !#   <unitName>Meta_Tree_Timing_Post_Evolve</unitName>
  !# </mergerTreePostEvolveTask>
\end{verbatim}
Here, {\normalfont \ttfamily Meta\_Tree\_Timing\_Post\_Evolve} is the name of a subroutine which will be called to perform whatever tasks are required. The subroutine must have the following form:
\begin{verbatim}
   subroutine Merger_Tree_PostEvolution_Task()
    implicit none
    .
    .
    .
    return
  end subroutine Merger_Tree_PostEvolution_Task
\end{verbatim}
The subroutine will be called once for each tree, after the tree has been evolved and destroyed.

\subsubsection{Merger Tree Pre-Evolution Tasks}\label{sec:MergerTreePreEvolveTask}

Additional tasks to be performed on merger trees prior to their evolution can be added using the {\normalfont \ttfamily mergerTreePreEvolveTask} directive. For example, the mass accretion history task uses this directive as follows:
\begin{verbatim}
  !# <mergerTreePreEvolveTask>
  !#   <unitName>Merger_Tree_Mass_Accretion_History_Output</unitName>
  !# </mergerTreePreEvolveTask>
\end{verbatim}
Here, {\normalfont \ttfamily Merger\_Tree\_Mass\_Accretion\_History\_Output} is the name of a subroutine which will be called to perform whatever tasks are required. The subroutine must have the following form:
\begin{verbatim}
   subroutine Merger_Tree_PreEvolution_Task(thisTree)
    implicit none
    type(mergerTree), intent(in) :: thisTree
    .
    .
    .
    return
  end subroutine Merger_Tree_PreEvolution_Task
\end{verbatim}
where {\normalfont \ttfamily thisTree} is the tree to be processed. The function will be called once for each tree, prior to the tree being evolved. Note that {\normalfont \ttfamily thisTree} may link to other trees via its {\normalfont \ttfamily nextTree} pointer. The function may want to process each tree in this linked list.

\subsubsection{Merger Tree Initialization Tasks}

Additional tasks to be performed during merger tree initialization can be added using the {\normalfont \ttfamily mergerTreeInitializeTask} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily standard} basic component method uses this directive as follows:
\begin{verbatim}
  !# <satelliteMergerTask>
  !#  <unitName>Halo_Mass_Accretion_Rate</unitName>
  !# </satelliteMergerTask>
\end{verbatim}
Here, {\normalfont \ttfamily Halo\_Mass\_Accretion\_Rate} is the name of a subroutine which will be called to perform whatever tasks are required as a result of the merger. The subroutine must have the following form:
\begin{verbatim}
   subroutine Merger_Tree_Initialize_Task(thisNode)
    implicit none
    type(treeNode), pointer, intent(inout) :: thisNode
    .
    .
    .
    return
  end subroutine Merger_Tree_Initialize_Task
\end{verbatim}
where {\normalfont \ttfamily thisNode} is the node to be initialized. The subroutine will be called once for each node in the tree.

\subsubsection{Merger Tree Structure Output Tasks}

Additional outputs for merger tree structure output can be added using the {\normalfont \ttfamily mergerTreeStructureOutputTask}. The directive should give the name of the subroutine to be called to perform the task. The templates for this tasks is:
\begin{verbatim}
  !# <mergerTreeStructureOutputTask>
  !#  <unitName>Structure_Output_Task</unitName>
  !# </mergerTreeStructureOutputTask>
  subroutine Structure_Output_Task(baseNode,nodeProperty,treeGroup)
    implicit none
    type(treeNode),   intent(in),    pointer      :: baseNode
    double precision, intent(inout), dimension(:) :: nodeProperty
    type(hdf5Object), intent(inout)               :: treeGroup
    .
    .
    .
    return
  end subroutine Structure_Output_Task
\end{verbatim}
The subroutine must walk the merger tree beginning from the given {\normalfont \ttfamily baseNode} and store each property to output in the given {\normalfont \ttfamily nodeProperty} array. Once populated, this array can be written to the appropriate HDF5 group, given by {\normalfont \ttfamily treeGroup}, in the \glc\ output file.

\subsubsection{Node Dump}

The function {\normalfont \ttfamily Node\_Dump(thisNode)} writes out all properties of a node to the display. To have their properties listed, each component must register a task using:
\begin{verbatim}
 !# <nodeDumpTask>
 !#  <unitName>Node_Dump_Procedure</unitName>
 !# </nodeDumpTask>
\end{verbatim}
where {\normalfont \ttfamily Node\_Dump\_Procedure} is the name of a subroutine with the following template
\begin{verbatim}
 subroutine Node_Dump_Procedure(thisNode)
    type(treeNode),   intent(inout), pointer :: thisNode
    .
    .
    .
    return
 end subroutine Node_Dump_Procedure
\end{verbatim}
If the node contains an active component, this subroutine should display all relevant properties of the component. If not, it can display a short message indicating that fact.

\subsubsection{Output Group Output Tasks}\index{output groups}\index{tasks!output}

Extra outputs for output groups (i.e. the groups which hold all merger tree data for a given output time) can be added using the directive: {\normalfont \ttfamily outputGroupOutputTask}. The directive should give the name of the subroutine to be called to perform the task. A template for this task is:
\begin{verbatim}
  !# <outputGroupOutputTask>
  !#  <unitName>Galacticus_Output_Group_Output_Example</unitName>
  !# </outputGroupOutputTask>
  subroutine Galacticus_Output_Group_Output_Example(outputGroup,time)
    implicit none
    type(hdf5Object), intent(inout) :: outputGroup
    double precision, intent(in)    :: time
    .
    .
    .
    return
  end subroutine Galacticus_Output_Group_Output_Example
\end{verbatim}
The subroutine will be called for each output group created, and should perform whatever extra output it requires. The {\normalfont \ttfamily outputGroup} object and the corresponding output {\normalfont \ttfamily time} are provided as input parameters.


\subsubsection{Post-evolve Tasks}\index{post-evolve task}\index{task, post-evolve}

Additional methods for post-evolve tasks (i.e. things that should be done after each node is evolved differentially to the next output time, interrupt, or event) can be added using the {\normalfont \ttfamily postEvolveTask} directive. The directive should contain a single argument, giving the name of a subroutine to be called to perform the task. For example, the standard hot halo component adds a task as follows:
\begin{verbatim}
  !# <postEvolveTask>
  !#  <unitName>Tree_Node_Hot_Halo_Postevolve_Standard</unitName>
  !# </postEvolveTask>
\end{verbatim}
Here, {\normalfont \ttfamily Tree\_Node\_Hot\_Halo\_Postevolve\_Standard} is the name of a subroutine which will be called to perform whatever tasks are required. The subroutine must have the following form:
\begin{verbatim}
   subroutine Post_Evolve_Task(node)
    implicit none
    type(treeNode), intent(inout) :: node
    .
    .
    .
    return
  end subroutine Post_Evolve_Task
\end{verbatim}
where {\normalfont \ttfamily node} is the node for which tasks will be performed. Tasks typically involve cleaning up after differential evolution.

\subsubsection{Post-step Tasks}\index{post-step task}\index{task, post-step}

Additional methods for post-step tasks (i.e. things that should be done after each ODE solver step when evoling a node differentially) can be added using the {\normalfont \ttfamily postStepTask} directive. The directive should contain a single argument, giving the name of a subroutine to be called to perform the task. For example, the standard hot halo component adds a task as follows:
\begin{verbatim}
  !# <postStepTask>
  !#  <unitName>Tree_Node_Hot_Halo_Poststep_Standard</unitName>
  !# </postStepTask>
\end{verbatim}
Here, {\normalfont \ttfamily Tree\_Node\_Hot\_Halo\_Poststep\_Standard} is the name of a subroutine which will be called to perform whatever tasks are required. The subroutine must have the following form:
\begin{verbatim}
   subroutine Post_Step_Task(node,status)
    implicit none
    type   (treeNode), intent(inout) :: node
    integer          , intent(inout) :: status
    .
    .
    .
    return
  end subroutine Post_Step_Task
\end{verbatim}
where {\normalfont \ttfamily node} is the node for which tasks should be performed. If any change is made to the state of the node then {\normalfont \ttfamily status} should be set equal to {\normalfont \ttfamily FGSL\_Failure}. Tasks typically involve cleaning up after differential evolution.

\subsubsection{Pre-derivative Tasks}\index{pre-derivative task}\index{task, pre-derivative}

Additional methods for pre-derivative tasks (i.e. things that should be done just prior to the computation of derivatives or properties for a node) can be added using the {\normalfont \ttfamily preDerivativeTask} directive. The directive should contain a single argument, giving the name of a subroutine to be called to perform the task. For example, the standard hot halo component adds a task as follows:
\begin{verbatim}
  !# <preDerivativeTask>
  !#  <unitName>Tree_Node_Hot_Halo_Prederivative_Standard</unitName>
  !# </preDerivativeTask>
\end{verbatim}
Here, {\normalfont \ttfamily Tree\_Node\_Hot\_Halo\_Prederivative\_Standard} is the name of a subroutine which will be called to perform whatever tasks are required. The subroutine must have the following form:
\begin{verbatim}
   subroutine Prederivative_Task(thisNode)
    implicit none
    type(treeNode), pointer, intent(inout) :: thisNode
    .
    .
    .
    return
  end subroutine Prederivative_Task
\end{verbatim}
where {\normalfont \ttfamily thisNode} is the node for which derivatives will be computed. Tasks typically involve precomputing quantities that will be used in finding the derivatives.

\subsubsection{Radius Solver Tasks}\label{sec:radius_solver}

Galactic radii solver functions (see \S\ref{sec:galactic_radii_solvers}) need to be able to interact with the components of a tree node to
\begin{enumerate}
 \item Determine which components want a radius to be solved for;
 \item Get and set the properties of those components.
\end{enumerate}
The  {\normalfont \ttfamily radiusSolverPlausibility} and {\normalfont \ttfamily radiusSolverTask} directives facilitate this. A component which has a radius to be solved for should include directives of the form:
\begin{verbatim}
 !# <radiusSolverTask>
 !#  <unitName>Component_Radius_Solver_Plausibility</unitName>
 !# </radiusSolverTask>
\end{verbatim}
and
\begin{verbatim}
 !# <radiusSolverTask>
 !#  <unitName>Component_Radius_Solver</unitName>
 !# </radiusSolverTask>
\end{verbatim}
where {\normalfont \ttfamily Component\_Radius\_Solver\_Plausibility} is the name of a subroutine which will specify whether or not the component is physically plausible for radius solving (e.g. has non-negative mass) and should have the following form:
\begin{verbatim}
 subroutine Component_Radius_Solver_Plausibility(thisNode,galaxyIsPhysicallyPlausible)
    implicit none
    type(treeNode), pointer, intent(inout) :: thisNode
    logical,                 intent(inout) :: galaxyIsPhysicallyPlausible
    .
    .
    .
    return
 end subroutine Component_Radius_Solver_Plausibility
\end{verbatim}
which should set {\normalfont \ttfamily galaxyIsPhysicallyPlausible} to false if the component is not physically plausible, but should otherwise leave {\normalfont \ttfamily galaxyIsPhysicallyPlausible} unchanged. Additionally, {\normalfont \ttfamily Component\_Radius\_Solver} is the name of a subroutine which will supply the necessary information about the node, and which should have the following form:
\begin{verbatim}
 subroutine Component_Radius_Solver(thisNode,componentActive,specificAngularMomentum,Radius_Get,Radius_Set,Velocity_Get,Velocity_Set)
    implicit none
    type(treeNode),   pointer, intent(inout) :: thisNode
    logical,                   intent(out)   :: componentActive
    double precision,          intent(out)   :: specificAngularMomentum
    procedure(),      pointer, intent(out)   :: Radius_Get,Velocity_Get
    procedure(),      pointer, intent(out)   :: Radius_Set,Velocity_Set
    .
    .
    .
    return
 end subroutine Component_Radius_Solver
\end{verbatim}
When called, the subroutine should set {\normalfont \ttfamily componentActive} to indicate whether or not this nod contains an active component of the type. If it does, it should also set {\normalfont \ttfamily specificAngularMomentum} to reflect the specific angular momentum (in km s$^{-1}$ Mpc) of the component (at whatever point in its profile the radius is required) and should point the four procedure pointers to routines which get and set the radius and circular velocity properties of the component (which should have the standard form for component get and set methods). It is acceptable for the set procedures to point to dummy routines.

The galactic structure radii solver routines will use this information to determine (and set) the radius and circular velocity of the component. An advantage of this approach is that different radii solver methods can all use this same system, ensuring that just a single interface is needed in each component.

\subsubsection{Satellite Host Change Tasks}

Additional methods for satellite host change events (i.e. when a satellite node moves to a new host) can be added using the {\normalfont \ttfamily satelliteHostChangeTask} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily simple} satellite orbits components uses this directive as follows:
\begin{verbatim}
  !# <satelliteHostChangeTask>
  !#  <unitName>Satellite_Orbit_New_Host</unitName>
  !# </satelliteHostChangeTask>
\end{verbatim}
Here, {\normalfont \ttfamily Satellite\_Orbit\_New\_Host} is the name of a subroutine which will be called to perform whatever tasks are required as a result of the host change. The subroutine must have the following form:
\begin{verbatim}
   subroutine New_Host_Task(thisNode)
    implicit none
    type(treeNode), pointer, intent(inout) :: thisNode
    .
    .
    .
    return
  end subroutine New_Host_Task
\end{verbatim}
where {\normalfont \ttfamily thisNode} is the node which has changed host (the new host halo is {\normalfont \ttfamily thisNode\%parentNode}).

\subsubsection{Satellite Merger Tasks}

Additional methods for satellite merger tasks can be added using the {\normalfont \ttfamily satelliteMergerTask} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily simple} satellite orbits components uses this directive as follows:
\begin{verbatim}
  !# <satelliteMergerTask>
  !#  <unitName>Satellite_Merger_Task</unitName>
  !# </satelliteMergerTask>
\end{verbatim}
Here, {\normalfont \ttfamily Satellite\_Merger\_Task} is the name of a subroutine which will be called to perform whatever tasks are required as a result of the merger. The subroutine must have the following form:
\begin{verbatim}
   subroutine Satellite_Merger_Task(thisNode)
    implicit none
    type(treeNode), pointer, intent(inout) :: thisNode
    .
    .
    .
    return
  end subroutine Satellite_Merger_Task
\end{verbatim}
where {\normalfont \ttfamily thisNode} is the node about to merge with {\normalfont \ttfamily thisNode\%parentNode}.

\subsubsection{Star Formation History Tasks}\index{star formation history}\label{sec:StarFormationHistoryTasks}

Additional methods for star formation history tracking  can be added using the {\normalfont \ttfamily starFormationHistoriesMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily metallicitySplit} method uses this directive as follows:
\begin{verbatim}
  !# <starFormationHistoriesMethod>
  !#  <unitName>Star_Formation_Histories_Metallicity_Split_Initialize</unitName>
  !# </starFormationHistoriesMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Star\_Formation\_Histories\_Metallicity\_Split\_Initialize} is the name of a subroutine which will be called to initialize the method. The subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize( starFormationHistoriesMethod     &
       &                       ,Star_Formation_History_Create_Do &
       &                       ,Star_Formation_History_Scales_Do &
       &                       ,Star_Formation_History_Record_Do &
       &                       ,Star_Formation_History_Output_Do &
       &                      )
    implicit none
    type(varying_string),          intent(in)    ::  starFormationHistoriesMethod
    procedure(),          pointer, intent(inout) ::  Star_Formation_History_Create_Do &
       &                                            ,Star_Formation_History_Scales_Do &
       &                                            ,Star_Formation_History_Record_Do &
       &                                            ,Star_Formation_History_Output_Do
    
    if (starFormationHistoriesMethod == 'myMethod') then
       Star_Formation_History_Create_Do => My_Create
       Star_Formation_History_Scales_Do => My_Scales
       Star_Formation_History_Record_Do => My_Record
       Star_Formation_History_Output_Do => My_Output
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily starFormationHistoriesMethod} input parameter. The procedure pointers must be set to point to subroutines which perform the functions described below. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The {\normalfont \ttfamily Star\_Formation\_History\_Create\_Do} subroutine must have the form:
\begin{verbatim}
  subroutine My_Create(thisNode,thisHistory)
    implicit none
    type(treeNode), intent(inout), pointer :: thisNode
    type(history),   ntent(inout)          :: thisHistory
    return
  end subroutine My_Create
\end{verbatim}
and should return a history object in {\normalfont \ttfamily thisHistory} suitable for holding a star formation history for {\normalfont \ttfamily thisNode}.

The {\normalfont \ttfamily Star\_Formation\_History\_Scales\_Do} subroutine must have the form:
\begin{verbatim}
  subroutine My_Scales(thisHistory,stellarMass,stellarAbundances)
    implicit none
    double precision,          intent(in)    :: stellarMass
    type(abundancesStructure), intent(in)    :: stellarAbundances
    type(history),             intent(inout) :: thisHistory
    return
  end subroutine My_Scales
\end{verbatim}
and should set the ODE solver error tolerance scales in {\normalfont \ttfamily thisHistory}, using the provided information on {\normalfont \ttfamily stellarMass} and {\normalfont \ttfamily stellarAbundances} if required.

The {\normalfont \ttfamily Star\_Formation\_History\_Record\_Do}\index{star formation history!recording} subroutine must have the form:
\begin{verbatim}
  subroutine My_Record(thisNode,thisHistory,fuelAbundances,starFormationRate)
    implicit none
    type(treeNode),            intent(inout), pointer :: thisNode
    type(history),             intent(inout)          :: thisHistory
    type(abundancesStructure), intent(in)             :: fuelAbundances
    double precision,          intent(in)             :: starFormationRate
    return
  end subroutine My_Record
\end{verbatim}
and should record the contribution to the star formation history in {\normalfont \ttfamily thisHistory} for {\normalfont \ttfamily thisNode} given the current {\normalfont \ttfamily starFormationRate} and star formation {\normalfont \ttfamily fuelAbundances}. That is, the subroutine should adjust the rates in {\normalfont \ttfamily thisHistory} appropriately.

The {\normalfont \ttfamily Star\_Formation\_History\_Output\_Do}\index{star formation history!outputting} subroutine must have the form:
\begin{verbatim}
  subroutine My_Output(thisNode,thisHistory,iOutput,treeIndex,componentLabel)
    implicit none
    type(treeNode),          intent(inout), pointer :: thisNode
    type(history),           intent(inout)          :: thisHistory
    integer,                 intent(in)             :: iOutput
    integer(kind=kind_int8), intent(in)             :: treeIndex
    character(len=*),        intent(in)             :: componentLabel
    return
  end subroutine My_Output
\end{verbatim}
and should write the star formation history, {\normalfont \ttfamily thisHistory}, for {\normalfont \ttfamily thisNode} to the output file. The output number and tree index are provided as {\normalfont \ttfamily iOutput} and {\normalfont \ttfamily treeIndex} for reference, and {\normalfont \ttfamily componentLabel} provides a suitable label for the component to which the history belongs (and so should be used in the name of the datasets to which the history is written for example).

Conventionally, star formation histories are output as follows:
\begin{verbatim}
HDF5 "galacticus.hdf5" {
GROUP "starFormationHistories" {
   COMMENT "Star formation history data."
   GROUP "Output1" {
      COMMENT "Star formation histories for all trees at each out"
      GROUP "mergerTree1" {
         COMMENT "Star formation histories for each tree."
         DATASET "diskSFH<nodeID>" {
         COMMENT "Star formation history stellar masses of the disk "
            DATATYPE  H5T_IEEE_F64LE
            DATASPACE  SIMPLE { }
         }
         DATASET "diskTime<nodeID>" {
         COMMENT "Star formation history times of the disk component"
            DATATYPE  H5T_IEEE_F64LE
            DATASPACE  SIMPLE { }
         }
         DATASET "spheroidSFH<nodeID>" {
         COMMENT "Star formation history stellar masses of the spher"
            DATATYPE  H5T_IEEE_F64LE
            DATASPACE  SIMPLE { }
         }
         DATASET "spheroidTime<nodeID>" {
         COMMENT "Star formation history times of the spheroid compo"
            DATATYPE  H5T_IEEE_F64LE
            DATASPACE  SIMPLE { }
         }
      }
      GROUP "mergerTree2" {
      .
      .
      .
      }
   }
   GROUP "Output1" {
   .
   .
   .
   }
}
}
\end{verbatim}
where {\normalfont \ttfamily nodeID} is the index of the relevant node. The specifics of each dataset will depend on the selected star formation history method.

Currently defined star formation history methods are:
\begin{description}
 \item [\hyperlink{galacticus.output.merger_tree.star_formation.metallicity_split.F90:star_formation_histories_metallicity_split}{{\normalfont \ttfamily metallicitySplit}}] The star formation history is tabulated on a grid of time and metallicity. The binning in time is chosen such that bins are at most of size {\normalfont \ttfamily [starFormationHistoryTimeStep]} between the time at which each galaxy formed and the final output time, and at most of size {\normalfont \ttfamily [starFormationHistoryFineTimeStep]} in the period {\normalfont \ttfamily [starFormationHistoryFineTime]} prior to each output time (all times specified in Gyr). The allows fine binning of recent star formation just prior to each output. Usually, the metallicity binning is arranged logarithmically in metallicity with {\normalfont \ttfamily [starFormationHistoryMetallicityCount]} bins between {\normalfont \ttfamily [starFormationHistoryMetallicityMinimum]} and {\normalfont \ttfamily [starFormationHistoryMetallicityMaximum]} (specified in Solar units). Note that the metallicity associated with each bin is the minimum metallicity for that bin (the maximum being the metallicity value associated with the next bin, except for the final bin which extends to infinite metallicity). If {\normalfont \ttfamily [starFormationHistoryMetallicityCount]}$=0$ is set, then the star formation history is not split by metallicity (i.e. a single metallicity bin encompassing all metallicities from zero to infinity is used). Alternatively, specific metallicity bin boundaries can be set via the {\normalfont \ttfamily [starFormationHistoryMetallicityBoundaries]} parameter---a final boundary corresponding to infinity is always added automatically. Output follows the conventional format, with 2D star formation history datasets to represent the history as a function of time and metallicity. An additional {\normalfont \ttfamily metallicities} dataset is added to the {\normalfont \ttfamily starFormationHistories} output group to record the metallicity binning as follows:
\begin{verbatim}
DATASET "metallicities" {
 COMMENT "Metallicities at which star formation histories are tabulated"
   DATATYPE  H5T_IEEE_F64LE
   DATASPACE  SIMPLE { ( [starFormationHistoryMetallicityCount] ) / ( [starFormationHistoryMetallicityCount] ) }
}
\end{verbatim}
 \item [\hyperlink{galacticus.output.merger_tree.star_formation.in_situ.F90:star_formation_histories_in_situ}{{\normalfont \ttfamily inSitu}}] The star formation history is tabulated on a grid of time and is split between in-situ and accreted star formation. The time grid is the same as (and controlled by the same parameters) are for the {\normalfont \ttfamily metallicitySplit} method. Output follows the conventional format, with 2D star formation history datasets to represent the history as a function of time and origin. The first element in the origin dimension records in-situ star formation, while the second element records total star formation.
\end{description}

\section{Subsystems}

This section describes some of the subsystems within \glc\ that support various physical entities or processes.

\subsection{Kepler Orbits}\label{sec:KeplerOrbits}

The {\normalfont \ttfamily keplerOrbit} object (provided by the \href{objects.kepler_orbits.F90:kepler_orbits_structure}{{\normalfont \ttfamily Kepler\_Orbits\_Structure}} module) stores the parameters of a single Keplerian orbit. It internally handles computation of additional/alternate orbital parameters once an orbit has been fully defined. Currently, the orientation of orbits (i.e. the unit vector normal to the orbital plane and the argument of periapsis) is not tracked. As such, orbits are fully defined by three parameters (in addition to the masses of the orbitting bodies). The following limitations presently apply to the {\normalfont \ttfamily keplerOrbit} object:
\begin{itemize}
 \item If an orbit is overdefined (i.e. if more than three parameters are set manually) no checking is performed to ensure that the parameters are consistent with a Keplerian orbit;
 \item Not all interconversions between parameters are supported\footnote{The {\normalfont \ttfamily keplerOrbit} object works by trying to convert to the combination radius, radial and tengential velocities. Once these are defined, all other parameters can be computed. However, for orbits defined in terms of other parameters, the {\normalfont \ttfamily keplerOrbit} object does not know how to convert from every such combination of parameters.}. If a conversion cannot be performed, an error message will be given. 
\end{itemize}
A {\normalfont \ttfamily keplerOrbit} object can be reset by calling the {\normalfont \ttfamily reset()} method, and its defined/undefined status can be tested with the {\normalfont \ttfamily isDefined()} method or asserted with the {\normalfont \ttfamily assertIsDefined()} method. The following orbital parameters are supported, each method returning the value of the parameter and a corresponding method suffixed with {\normalfont \ttfamily Set} can be used to set the parameter: {\normalfont \ttfamily radius}, {\normalfont \ttfamily velocityRadial}, {\normalfont \ttfamily velocityTengentail}, {\normalfont \ttfamily energy}, {\normalfont \ttfamily angularMomentum}, {\normalfont \ttfamily eccentricity}, {\normalfont \ttfamily semiMajorAxis}, {\normalfont \ttfamily radiusPericenter}, {\normalfont \ttfamily radiusApocenter}. Additionally, the masses of the orbitting bodies are provided by the {\normalfont \ttfamily hostMass()} and {\normalfont \ttfamily reducedMassSpecific()}$=M_\mathrm{host}/(M_\mathrm{host}+M_\mathrm{satellite})$ methods. Finally, the {\normalfont \ttfamily velocityScale()} method returns $\mathrm{G}M_\mathrm{host}/r$ where $r$ is the radius of the orbit.

\subsection{Chemicals}\label{sec:ChemicalSubsystem}

The chemicals subsystem provides both a interface to a database of known chemicals (allowing their physical properties to be queried) and a structure to store abundances/masses/etc. of the set of chemicals being tracked in \glc. The name ``chemicals'' is used to denote any chemical species that might be involved in reactions, including molecules, atoms, atomic and molecular ions and electrons.

\subsubsection{Chemical Database}

The file {\normalfont \ttfamily data/Chemical\_Database.cml} contains a database of chemicals that can currently be used by \glc. It uses a simplified version of the \href{http://www.xml-cml.org}{Chemical Markup Language} to describe chemicals. An excerpt from the database is shown below:
\begin{verbatim}
 <list>
  <chemical>
   <id>MolecularHydrogenAnion</id>
   <formalCharge>-1</formalCharge>
   <atomArray>
     <atom>
      <id>1</id>
      <elementType>H</elementType>
     </atom>
     <atom>
      <id>2</id>
      <elementType>H</elementType>
     </atom>
   </atomArray>
   <bondArray>
     <bond>
      <atomRefs2>1 2</atomRefs2>
      <order>1</order>
     </bond>
   </bondArray>
  </chemical>
  .
  .
  .
 </list>
\end{verbatim}
The database contains a {\normalfont \ttfamily list} of chemicals, each contained within a {\normalfont \ttfamily chemical} element. The {\normalfont \ttfamily id} element provides a label for the chemical (usually a descriptive name with no white space). The {\normalfont \ttfamily formalCharge} element gives the charge of the chemical in units of the elementary charge. The chemical is then describe by a list of atoms and bonds inside {\normalfont \ttfamily atomArray} and {\normalfont \ttfamily bondArray} elements respectively. The {\normalfont \ttfamily atomArray} can contain any number of {\normalfont \ttfamily atom} elements, which should describe each atom in the chemical giving it a unique {\normalfont \ttfamily id} number and an {\normalfont \ttfamily elementType}, which is the short one or two letter label for the element (e.g. H, Ni, etc.). The {\normalfont \ttfamily bondArray} should contain a {\normalfont \ttfamily bond} entry for each atomic bond, which itself contains a {\normalfont \ttfamily atomRefs2} element giving the IDs of the two atoms participating in the bond and an {\normalfont \ttfamily order} element which gives the order of the bond (e.g. ``1'' for a single bond).

\subsubsection{Chemical Structure}

Within \glc\ a chemical is represeted using the {\normalfont \ttfamily chemicalStructure} type which is provided by the {\normalfont \ttfamily Chemical\_Structures} module. A {\normalfont \ttfamily chemicalStructure} object can be assigned a particular chemical by retrieving that chemical from the database using:
\begin{verbatim}
 call myChemical%retrieve("chemicalID")
\end{verbatim}
where {\normalfont \ttfamily chemicalID} is the ID of the chemical in the databse. Any chemical can be exported to a CML file using
\begin{verbatim}
 call myChemical%export(fileName)
\end{verbatim}
where {\normalfont \ttfamily fileName} gives the name of the file to which to export.

Once assigned a chemical, basic properties such as mass and charge (in atomic units) can be accessed using {\normalfont \ttfamily myChemical\%mass} and {\normalfont \ttfamily myChemical\%charge} respectively. The mass is computed from the known atomic masses of the constituent atoms of the chemical.

\subsubsection{Chemical Abundances}

Within \glc\ a set of abundances (or masses, or densities\ldots) for all chemicals being tracked, as specified by the {\normalfont \ttfamily [chemicalsToTrack]} input parameter, is stored within a {\normalfont \ttfamily chemicalAbundancesStructure} type, as provided by the {\normalfont \ttfamily Chemical\_Abundances\_Structure} module. The structure provides interfaces for setting and retrieving the abundance of a given chemical species, to pack/unpack all chemicals to/from an array, to convert from mass-weighted to number-weigted quantities and to multiplty and divide the chemicals abundances by a given amount. Additionally, the {\normalfont \ttfamily Chemical\_Abundances\_Structure} module provides functions which provide a count of the number of chemicals tracked, to look up the index of a chemical array represetation from its name, and to retrieve the name of a given chemical.

\subsection{Radiation}\label{sec:RadiationSubsystem}

This subsystem handles radiation fields, providing convenient means to communicate radiation fields from one part of the \glc\ code to another. A radiation object can hold multiple different types of radiation field (e.g. it could contain both the cosmic microwave background and an interstellar radiation field localized to a specific galaxy).

\subsubsection{Radiation Structure}

Within \glc\ radiation fields are represented by the {\normalfont \ttfamily radiationStructure} type which is provided by the {\normalfont \ttfamily Radiation\_Structures} module. A {\normalfont \ttfamily radiationStructure} object must first be defined using:
\begin{verbatim}
 call myRadiation%define([radiationType1,radiationType2])
\end{verbatim}
where the list of {\normalfont \ttfamily radiationType}s specifies what radiation components will be present in this radiation object. Currently defined radiation types are:
\begin{description}
 \item[{\normalfont \ttfamily CMB}] The cosmic microwave background;
 \item[{\normalfont \ttfamily Null}] A null (zero radiation) component.
\end{description}
For example,
\begin{verbatim}
 call myRadiation%define([radiationTypeCMB])
\end{verbatim}
will define the {\normalfont \ttfamily myRadiation} object to contain just the cosmic microwave background.

Once defined, the specific radiation field can be set using:
\begin{verbatim}
 call myRadiation%set(thisNode)
\end{verbatim}
This will cause all components to set their radiation fields using (if necessary) the properties of {\normalfont \ttfamily thisNode}. Radiation objects can be queried using the following methods:
\begin{description}
 \item[{\normalfont \ttfamily temperature(radiationTypes)}] Returns the temperature (in Kelvin) of the radiation object. The optional {\normalfont \ttfamily radiationTypes} array specifies which radiation types are to be queried.
 \item[{\normalfont \ttfamily flux(wavelength,radiationTypes)}] Returns the flux (in ergs cm$^2$ s$^{-1}$ Hz$^{-1}$ ster$^{-1}$) of the radiation object at the given {\normalfont \ttfamily wavelength} (specified in units of \AA). The optional {\normalfont \ttfamily radiationTypes} array specifies which radiation types are to be queried.
\end{description}

\subsection{Coordinates}\label{sec:Coordinates}

The {\normalfont \ttfamily coordinate} class, provided by the \hyperlink{objects.coordinates.F90:coordinates}{\normalfont \ttfamily Coordinates} module provides an object describing a position in three-dimensional space. Each extension of this class (currently, {\normalfont \ttfamily coordinateCartesian}, {\normalfont \ttfamily coordinateCylindrical}, and {\normalfont \ttfamily coordinateSpherical}) supply methods to convert to and from Cartesian coordinates. The assignment operator ({\normalfont \ttfamily =}) is overloaded such that coordinate objects of any class can be assigned to any other class and conversion to the appropriate coordinate system will happen automatically. A function accepting a {\normalfont \ttfamily class(coordinate)} object can therefore convert it to, for example, spherical coordinates simply using
\begin{verbatim}
 class(coordinate         ), intent(in) :: coordinates
 type (coordinateSpherical)             :: coordinatesSpherical
 coordinatesSpherical=coordinates
\end{verbatim}
and thereby allow a position to be passed to it in any coordinate system.

Each extension of the base class also provides methods to get and set the values of each component of the relevant coordinate system (see \S\ref{sec:AutoMethodsCoordinate} for complete details).
