\chapter{Adding New Methods}

\section{Code Directives}\label{sec:CodeDirectives}\index{directives}\index{code!directives}

\glc\ is designed to be flexible and extensible, allowing you to add new methods and functionality without having to hack the code extensively. To achieve this it makes much use of embedded code directives which, for example, explain to the build system how a particular subroutine or function connects into the \glc\ code. Such code directives are indicated by lines beginning with {\normalfont \ttfamily !\#}, and take the form of short blocks of XML. For example, a typical code directive might look like:
\begin{verbatim}
 !# <accretionDisksMethod>
 !#  <unitName>Accretion_Disks_Shakura_Sunyaev_Initialize</unitName>
 !# </accretionDisksMethod>
\end{verbatim}
This directive would typically appear just prior to a subroutine which initializes the Shakura-Sunyaev accretion disk module (it could appear anywhere throughout that module, but it makes sense to keep it close to the subroutine that it references). The {\normalfont \ttfamily accretionDisksMethod} tag explains to the \glc\ build system that this module contains an implementation of black hole accretion disks. The {\normalfont \ttfamily unitName} tag specifies the name of a program unit which (in this case) should be called to initialize this accretion disk implementation. The build system will then insert appropriate {\normalfont \ttfamily use} and {\normalfont \ttfamily call} statements into the \glc\ code such that this routine will be called if and when accretion disks are required by \glc.

\section{Identifying Components and Mass Types}\label{sec:ComponentMassTypes}

Many functions can be applied to different components or groups of components and to different types of mass within a node. In general, these functions make use of a set of label defined in the \hyperlink{galactic_structure.options.F90:galactic_structure_options}{{\normalfont \ttfamily Galactic\_Structure\_Options}} module. Components are identified by a {\normalfont \ttfamily componentType} label which can take on the following values:
\begin{description}
 \item [{\normalfont \ttfamily componentTypeAll}] All components are matched;
 \item [{\normalfont \ttfamily componentTypeDisk}] Only disk components are matched;
 \item [{\normalfont \ttfamily componentTypeSpheroid}] Only spheroid components are matched.
 \item [{\normalfont \ttfamily componentTypeBlackHole}] Only black hole components are matched.
 \item [{\normalfont \ttfamily componentTypeHotHalo}] Only hot halo components are matched.
 \item [{\normalfont \ttfamily componentTypeDarkHalo}] Only dark matter halo components are matched.
\end{description}
Types of mass are identified by a {\normalfont \ttfamily massType} which can take one of the following values:
\begin{description}
 \item [{\normalfont \ttfamily massTypeAll}] All mass is included;
 \item [{\normalfont \ttfamily massTypeDark}] Only dark matter is included;
 \item [{\normalfont \ttfamily massTypeBaryonic}] Only baryonic mass is included;
 \item [{\normalfont \ttfamily massTypeGalactic}] Only galactic mass is included.
 \item [{\normalfont \ttfamily massTypeGaseous}] Only gaseous mass is included.
 \item [{\normalfont \ttfamily massTypeStellar}] Only stellar mass is included.
 \item [{\normalfont \ttfamily massTypeBlackHole}] Only black hole mass is included.
\end{description}

\section{Components}\index{components}

This section describes the internal structure of node components, and how a component is implemented.

\subsection{Component Structure}\index{components!structure}

Each node in the merger tree consists of an arbitrary number of ``components'', each of which can actually be an array, allowing multiple components of a given class. Each component represents a specific class of object, which could be a dark matter halo, a galactic disk or a black hole etc. A component of each class may be of one or more differnt implementations of that component class. Component classes are extensions of the {\normalfont \ttfamily nodeComponent} base class, while each implementation is an extension of its component class (or, sometimes, of another implementation of that same class). Each component implementation type consists of a set of data\footnote{Data objects in components can be real, integer, boolean or of derived type. For derived types, currently {\normalfont \ttfamily history}, {\normalfont \ttfamily abundances}, {\normalfont \ttfamily chemicals}, and {\normalfont \ttfamily keplerOrbit} are supported. Adding additional derived types is possible, providing that the type supports the required methods for output, serialization, etc. Data objects can currently be scalar or rank-1 arrays.}, representing the properties (mass, size etc.) of the component, along with the rates of change (and ODE solver tolerances) for any properties which are evolvable. Additionally, each component contains a large number of methods (functions) which can be used to access its properties, query its interfaces and which are used internally to perform ODE evolution, output etc. The {\normalfont \ttfamily nodeComponent} base class and all classes derived from it are built automatically by {\normalfont \ttfamily Galacticus::Build::Components} at compile time (take a look in {\normalfont \ttfamily work/build/objects.nodes.components.Inc} if you want to see the generated code).

\subsection{Extending Components}

It is possible to create a component which extends an existing component (see the discussion of the {\normalfont \ttfamily extends} element in \S\ref{sec:ComponentDefinition}). This capability is intended to allow new properties to be added to a component without having to create a whole new copy of the component. It is \emph{not} intended to allow changes in the way in which the component is evolved through the halo hierarchy. (With the exception that rules to describe how the newly added properties will evolve through the halo hierarchy can be added of course.)

A simple example of this extension capability can be found in the {\normalfont \ttfamily scaleShape} dark matter profile component (\S\ref{sec:DarkMatterProfileScaleShape}), which extends the {\normalfont \ttfamily scale} dark matter profile component (\S\ref{sec:DarkMatterProfileScale}). In this case, the {\normalfont \ttfamily scaleShape} component adds a new property, {\normalfont \ttfamily shape}, and specifies how it is to be initialized, evolved, output, and change by node promotion events. It \emph{does not} affect how the {\normalfont \ttfamily scale} property, inherited from the {\normalfont \ttfamily scale} dark matter profile component, is evolved.

\subsection{Implementing a New Component}\label{sec:ComponentImplement}\index{components!implementing}

Implementing a new component involves writing some modules and functions which contain a definition of the component and, if necessary, handle initialization, creation, evolution, and responses to any events. Frequently, the easiest way to make a new component is to copy a previously existing one and modify it as needed. Details of the various functions that component modules must perform are given below.
By convention, a component's implementation is split into three or four files, although some components might not need all of these files. These files are named as follows (with {\normalfont \ttfamily \textless component\textgreater} acting as a placeholder for the name of the component in question):
\begin{description}
 \item [{\normalfont \ttfamily objects.nodes.components.\textless component\textgreater.F90}] The primary file which describes the component and its properties, and which contains functions that manipulate the component as it evolves through a merger tree (ODE rates, behavior during mergers, etc.);
 \item [{\normalfont \ttfamily objects.nodes.components.\textless component\textgreater.bound\_functions.F90}] Contains functions which will be bound to the component object (i.e. the {\normalfont \ttfamily nodeComponent\textless Class\textgreater\textless Implementation\textgreater} class), and so will be available as type bound procedures. Generally, these functions will include any which get or set values of properties in the component, those which return information about its internal state (such as the density at some position in the component; see \S\ref{sec:GalacticComponentDensity}), and any other functions which we may want to be overridden by extensions to the component.
 \item [{\normalfont \ttfamily objects.nodes.components.\textless component\textgreater.data.F90}] Contains any data which may need to be shared between the above two files. This might contain parameters which control some property of the component that is the same for all instances (e.g. if spheroids are modelled as S\'ersic profiles all with the same value of the S\'ersic index, that value might be placed into this file).
 \item [{\normalfont \ttfamily objects.nodes.components.\textless component\textgreater.structure.F90}] Contains any functions which implement the structure (e.g. density, rotation curve) of the component and which cannot be placed in {\normalfont \ttfamily objects.nodes.components.\textless component\textgreater.bound\_functions.Inc} due to dependencies on modules which in turn depend on the {\normalfont \ttfamily Galacticus\_Nodes} module.
\end{description}
In general, {\normalfont \ttfamily objects.nodes.components.\textless component\textgreater.F90} is the place for the component definition and functions which process the component during tree evolution (including output), while {\normalfont \ttfamily objects.nodes.components.\textless component\textgreater.bound\_functions.Inc} is intended for functions which record or report the internal state of the component.

\subsubsection{Component Definition}\label{sec:ComponentDefinition}

Component definition itself takes the form of an embedded XML document. The following example illustrates such a document:
\begin{verbatim}
  !# <component>
  !#  <class>disk</class>
  !#  <name>exponential</name>
  !#  <isDefault>yes</isDefault>
  !#  <properties>
  !#   <property>
  !#     <name>isInitialized</name>
  !#     <type>logical</type>
  !#     <rank>0</rank>
  !#     <attributes isSettable="true" isGettable="true" isEvolvable="false" />
  !#   </property>
  !#   <property>
  !#     <name>massStellar</name>
  !#     <type>real</type>
  !#     <rank>0</rank>
  !#     <attributes isSettable="true" isGettable="true" isEvolvable="true" />
  !#     <output unitsInSI="massSolar" comment="Mass of stars in the exponential disk."/>
  !#   </property>
  !#   <property>
  !#     <name>abundancesStellar</name>
  !#     <type>abundances</type>
  !#     <rank>0</rank>
  !#     <attributes isSettable="true" isGettable="true" isEvolvable="true" />
  !#     <output unitsInSI="massSolar" comment="Mass of metals in the stellar phase of the exponential disk."/>
  !#   </property>
  !#   <property>
  !#     <name>massGas</name>
  !#     <type>real</type>
  !#     <rank>0</rank>
  !#     <attributes isSettable="true" isGettable="true" isEvolvable="true" createIfNeeded="true" makeGeneric="true" />
  !#     <output unitsInSI="massSolar" comment="Mass of gas in the exponential disk."/>
  !#   </property>
  !#   <property>
  !#     <name>coolingMass</name>
  !#     <attributes isSettable="false" isGettable="false" isEvolvable="true" isDeferred="rate" bindsTo="top" />
  !#     <type>real</type>
  !#     <rank>0</rank>
  !#     <isVirtual>yes</isVirtual>
  !#   </property>
  !#   <property>
  !#     <name>halfMassRadius</name>
  !#     <attributes isSettable="false" isGettable="true" isEvolvable="false" />
  !#     <type>real</type>
  !#     <rank>0</rank>
  !#     <isVirtual>yes</isVirtual>
  !#     <getFunction>Node_Component_Disk_Exponential_Half_Mass_Radius</getFunction>
  !#   </property>
  !#   <property>
  !#     <name>luminositiesStellar</name>
  !#     <type>real</type>
  !#     <rank>1</rank>
  !#     <attributes isSettable="true" isGettable="true" isEvolvable="true" />
  !#     <classDefault modules="Stellar_Population_Properties_Luminosities" count="Stellar_Population_Luminosities_Count()">0.0d0</classDefault>
  !#     <output labels="':'//Stellar_Population_Luminosities_Name({i})" count="Stellar_Population_Luminosities_Count()" condition="Stellar_Population_Luminosities_Output({i},time)" modules="Stellar_Population_Properties_Luminosities" unitsInSI="luminosityZeroPointAB" comment="Luminosity of disk stars."/>
  !#   </property>
  !#  </properties>
  !#  <bindings>
  !#   <binding method="attachPipes" function="Node_Component_Disk_Exponential_Attach_Pipes" type="void" bindsTo="component" />
  !#  </bindings>
  !#  <functions>objects.nodes.components.disk.exponential.custom_methods.inc</functions>
  !# </component>
\end{verbatim}

The elements of this document have the following meaning:
\begin{description}
\item [{\normalfont \ttfamily class}] \emph{[Required]} Specifies the component class of which this is an implementation.
\item [{\normalfont \ttfamily name}] \emph{[Required]} Specifies the name of this specific implementation.
\item [{\normalfont \ttfamily extends}] \emph{[Optional]} If present, this element must contain {\normalfont \ttfamily class} and {\normalfont \ttfamily name} elements which specify the type of component which should be extended. The component then automatically inherits all properties and type-bound functions of the extended type.
\item [{\normalfont \ttfamily isDefault}] \emph{[Required]} Specifies whether or not this should be the default implementation of this class. Note that only one implementation of each class can be declared to be the default. If no implementation of a given class is declared to be the default then the (automatically generated) {\normalfont \ttfamily null} implementation will be made the default.
\item [{\normalfont \ttfamily properties}] \emph{[Optional]} Contains an array of {\normalfont \ttfamily property} elements which specify the properties of this implementation. Each member {\normalfont \ttfamily property} has the following structure:
\begin{description}
\item [{\normalfont \ttfamily name}] \emph{[Required]} The name of the property. 
\item [{\normalfont \ttfamily type}] \emph{[Required]} The type (one of {\normalfont \ttfamily real}, {\normalfont \ttfamily integer}, {\normalfont \ttfamily logical}, {\normalfont \ttfamily history}, {\normalfont \ttfamily abundances}, {\normalfont \ttfamily chemicals}, or {\normalfont \ttfamily keplerOrbit} at present) of the property.
\item [{\normalfont \ttfamily rank}] \emph{[Required]} The rank of this property (currently {\normalfont \ttfamily 0} for a scalar or {\normalfont \ttfamily 1} for a 1-D array).
\item [{\normalfont \ttfamily attributes}] \emph{[Required]} Attributes of this property:
\begin{description}
\item [{\normalfont \ttfamily isSettable}] If {\normalfont \ttfamily true} then the value of this property can be set directory.
\item [{\normalfont \ttfamily isGettable}] If {\normalfont \ttfamily true} then the value of this property can be got directory.
\item [{\normalfont \ttfamily isEvolvable}] If {\normalfont \ttfamily true} this property evolves as part of the \glc\ \gls{ode} system.
\item [{\normalfont \ttfamily createIfNeeded}] If {\normalfont \ttfamily true} then any attempt to get, set, or adjust the rate of this property will cause the component to be created if it does not already exist. This is useful if the component should be created in response to mass transfer from some other component for example.
\item [{\normalfont \ttfamily makeGeneric}] If {\normalfont \ttfamily true} then any {\normalfont \ttfamily rate} method for this property will have a version created which binds to the base {\normalfont \ttfamily nodeComponent} class. This version is suitable for attaching to deferred rate functions of components of another class. For example, the disk gas mass rate function is made generic, and then attached to the deferred cooling rate of the hot halo using:
\begin{verbatim}
  call hotHalo%hotHaloCoolingMassRateFunction(DiskExponentialMassGasRateGeneric)
\end{verbatim}
\item [{\normalfont \ttfamily isDeferred}] Contains a ``{\normalfont \ttfamily :}'' separated list which can contain {\normalfont \ttfamily get}, {\normalfont \ttfamily set}, and {\normalfont \ttfamily rate}. The methods present in this list will not have functions bound to them at compile time. Instead a function will be created which allows a function to be bound to these methods at run time. For example:
\begin{verbatim}
  call myComponent%massFunction    (My_Component_Mass_Get_Function)
  call myComponent%massSetFunction (My_Component_Mass_Set_Function)
  call myComponent%massRateFunction(My_Component_Mass_Rate_Function)
\end{verbatim}
Additionally, a method is created which returns true or false depending on whether the method has been attached to a function yet, e.g.
\begin{verbatim}
 myComponent%massIsAttached    ()
 myComponent%massSetIsAttached ()
 myComponent%massRateIsAttached()
\end{verbatim}
\item [{\normalfont \ttfamily bindsTo}] Specifies to which level in the class hierarchy set, get and rate methods should be bound. Normally, these are bound to the component implementation itself. However, it can be useful to specify a binding of ``{\normalfont \ttfamily top}'' to bind to the base {\normalfont \ttfamily nodeComponent} class to make these methods interoperable with properties of other classes (see the discussion of the {\normalfont \ttfamily makeGeneric} element above).
\end{description}
\item [{\normalfont \ttfamily output}] \emph{[Optional]} If present, the property will be included in the \glc\ output file. The following attributes control the details of that output:
\begin{description}
\item [{\normalfont \ttfamily unitsInSI}] The units of the output quantity in the SI system.
\item [{\normalfont \ttfamily comment}] A comment to be included with the HDF5 dataset for this property.
\item [{\normalfont \ttfamily condition}] A statement which must evaluate to {\normalfont \ttfamily true} or {\normalfont \ttfamily false} and which will be used to determine if the property will be output. The present output time for is available as {\normalfont \ttfamily time}. In the case of an array property the construct ``{\normalfont \ttfamily \{i\}}'' can be used to pass the index of the element for which the condition should be evaluated.
\item [{\normalfont \ttfamily modules}] A comma-separated list of any modules required to perform the output (e.g. modules which contain functions or values that are used).
\end{description}
Additional attributes are required for array properties:
\begin{description}
\item [{\normalfont \ttfamily labels}] This can be an array, declared as ``{\normalfont \ttfamily [$L_1$,\ldots,$L_N$]}'', specifying the suffix to be added to the property name for each component of the array in the output, or a function which returns the suffix. In the case of a function the construct ``{\normalfont \ttfamily \{i\}}'' can be used to pass the index of the element for which the suffix is required.
\item [{\normalfont \ttfamily count}] A statement which evaluates the the number of elements to be output (i.e. the length of the array).
\end{description}
\item [{\normalfont \ttfamily isVirtual}] \emph{[Optional]} If present and set to ``{\normalfont \ttfamily yes}'', this property is a virtual property. A virtual property has no data associated with it and must supply its own functions for getting, setting and adjusting its rate of change (if allowed by the property's attributes). Virtual properties are used for quantities which are derived from actual properties of the component implementation (for example, a star formation rate could be a virtual property if it is derived from an actual gas mass property) or for adjusting the rates of several actual properties simultaneously.
\item [{\normalfont \ttfamily getFunction}] \emph{[Optional]} Specifies the function to be used for getting the value of the property, overriding the default get function. The function must be included in the \hyperlink{objects.nodes.F90:galacticus_nodes}{\normalfont \ttfamily Galacticus\_Nodes} module by use of the {\normalfont \ttfamily functions} element described below. Note that this function, by virtue of its priveleged access to the itnernal structure of node components, can access the value of the data associated with the propery using:
\begin{verbatim}
myComponent%<property>Data%value
\end{verbatim}
\item [{\normalfont \ttfamily setFunction}] \emph{[Optional]} The same as {\normalfont \ttfamily getFunction} but defines a function to set the value of the property.
\item [{\normalfont \ttfamily classDefault}] \emph{[Optional]} Specifies the default value for this property if the component class has not been created (i.e. has no specific implementation yet). The content of this element gives the default value (which can be a scalar, an array, a function, etc.). Additional, optional attributes control the use of this element:
\begin{description}
 \item [{\normalfont \ttfamily modules}] Specifies a comma-separated list of modules which are required to set the default values (e.g. modules which contain the value or function to be used).
 \item [{\normalfont \ttfamily count}] For array properties whose size is not known at compile-time, it is possible to specify a function which will return the appropriate size of the array at run-time. The scalar default value given in the {\normalfont \ttfamily classDefault} element will then be replicated the appropriate number of times.
\end{description}
\end{description}
\item [{\normalfont \ttfamily bindings}] \emph{[Optional]} Contains an array of {\normalfont \ttfamily binding} elements which specify functions to bind to this implementation. Each member {\normalfont \ttfamily binding} has the following structure:
\begin{description}
\item [{\normalfont \ttfamily method}] The name of the bound method, such that the function can be accessed using
\begin{verbatim}
 myComponent%<method>(...)
\end{verbatim}
\item [{\normalfont \ttfamily function}] The function to which the method should be bound. (This function must be included in the \hyperlink{objects.nodes.F90:galacticus_nodes}{\normalfont \ttfamily Galacticus\_Nodes} module by use of the {\normalfont \ttfamily functions} element described below.
\item [{\normalfont \ttfamily type}] The type of function.
\item [{\normalfont \ttfamily bindsTo}] Specifies where this method should be bound. ``{\normalfont \ttfamily component}'' specifies binding to the specific implementation of this component class, ``{\normalfont \ttfamily componentClass}'' specifies binding to the component class, while ``{\normalfont \ttfamily top}'' specifies binding to the base {\normalfont \ttfamily nodeComponent} class.
\end{description}
\item [{\normalfont \ttfamily functions}] \emph{[Optional]} Contains the name of a file which will be included into the \hyperlink{objects.nodes.F90:galacticus_nodes}{\normalfont \ttfamily Galacticus\_Nodes} module. This file can contain functions which will be bound to this implementation. By virtue of being included in the \hyperlink{objects.nodes.F90:galacticus_nodes}{\normalfont \ttfamily Galacticus\_Nodes} module these functions have privelged access to the internal structure of all node component objects.
\end{description}

\subsubsection{Component Initialization}\index{components!initialization}

Initialization of a component module (if necessary, for example, to read parameters or allocate workspace) can occur at a number of different points in the execution of \glc. Providing initialization occurs in advance of any calculations then any point is acceptable. One possibility is simply to call an initialization function at the head of all functions defined in the component module. This initialization function should return immediately if it has already been called (to avoid duplicate initialization). Another option is to use the {\normalfont \ttfamily mergerTreePreTreeConstructionTask} event (see \S\ref{sec:MergerTreePreConstructionTask}) to perform initialization just before merger trees are constructed (the initialization function must again return immediately if it has been previously called).

Optionally, a component may include a {\normalfont \ttfamily mergerTreeEvolveThreadInitialize} directive, which gives the name of a subroutine in its {\normalfont \ttfamily unitName} element. The routine specified by {\normalfont \ttfamily mergerTreeEvolveThreadInitialize} is called by all threads prior to merger tree evolution, and can therefore be used to perform any ``per thread'' initialization. Note that this routine will be called many times during a given \glc\ run---it is the responsibility of the routine to ensure that it performs any initialization only once.

\subsubsection{Component Access, Creation and Destruction}\index{components!creation}\index{components!destruction}

When a node is created, it initially contains no components. A component must therefore create itself on the fly as needed. Typically, a component is first created when an attempt is made to set a property value, or to adjust the rate of change of a property value or in response to some event (e.g. a satellite component may be created in response to a node merging with a larger node). Requests for property values frequently \emph{do not} require that the component exist, as a zero value can often be returned instead\footnote{Or some other value if a {\normalfont \ttfamily classDefault} has been specified (see \S\ref{sec:ComponentImplement}).}.

To access a component from a node, use:
\begin{verbatim}
 myComponent => thisNode%<class>([instance=<N>,autoCreate=<create>])
\end{verbatim}
where {\normalfont \ttfamily class} is the component class required, the optional {\normalfont \ttfamily instance} argument requests a specific instance of the component (relevant if the node contains more than one of a particular component, e.g. if it contains two supermassive black holes for example; if no {\normalfont \ttfamily instance} is specified the first instance will be returned), and the {\normalfont \ttfamily autoCreate} option specifies whether or not the component should be automatically created (assuming it does not already exist). {\normalfont \ttfamily autoCreate}$=${\normalfont \ttfamily true} should be used to create components initially.

A component of a node can be destroyed using:
\begin{verbatim}
call thisNode%<class>Destroy()
\end{verbatim}

\subsubsection{Component Methods}\label{sec:ComponentMethods}\index{components!methods}

Component implementations optionally provide functions to get and set their properties (and to set the rate of change of evolvable properties) so that other components and functions within \glc\ to can interact with them in a way that is independent of the specific component implementation chosen. To permit this, \glc\ creates functions for each property to access it in all permitted ways. For example, the {\normalfont \ttfamily exponential} implementation of the {\normalfont \ttfamily disk} component class has a ``{\normalfont \ttfamily massStellar}'' property defined by:
\begin{verbatim}
 <method>
   <name>massStellar</name>
   <type>real</type>
   <rank>0</rank>
   <attributes isSettable="true" isGettable="true" isEvolvable="true" />
 </method>
\end{verbatim}
This causes \glc\ to define several functions bound to the {\normalfont \ttfamily nodeComponentDisk} class:
\begin{description}
\item [{\normalfont \ttfamily massStellarIsSettable}] Returns {\normalfont \ttfamily true} if this property is settable;
\item [{\normalfont \ttfamily massStellarIsGettable}] Returns {\normalfont \ttfamily true} if this property is gettable;
\item [{\normalfont \ttfamily massStellarSet}] Sets the value of this property to the supplied argument;
\item [{\normalfont \ttfamily massStellarGet}] Gets the value of this property;
\item [{\normalfont \ttfamily massStellarRate}] Cumulates its argument to the rate of change of this property;
\item [{\normalfont \ttfamily massStellarScale}] Sets the absolute scale for this property used in ODE error control;
\end{description}
along with several others used internally for output, serialization etc.

\subsubsection{Component Evolution}\label{sec:ComponentEvolution}\index{evolution}\index{components!evolution}

All component properties which have an {\normalfont \ttfamily isEvolvable} attribute set to {\normalfont \ttfamily true} are included in \glc's ODE solver as the node is evolved forward in time. As described in \S\ref{sec:ComponentMethods}, \glc\ will create two functions that permit the rate of change of a property adjusted and for the absolute scale used in ODE error control to be set.

A ``rate compute'' function should be defined to perform any calculations necessary to determine the rate of change of the property and adjust the rate appropriately. Below is an example of the rate compute subroutine for the stellar mass property of the exponential disk component, with only the basic structure shown:
\begin{lstlisting}[escapechar=@,breaklines,prebreak=\&,postbreak=\&]
  !# <rateComputeTask>
  !#  <unitName>Node_Component_Disk_Exponential_Rate_Compute</unitName>
  !# </rateComputeTask>
  subroutine Node_Component_Disk_Exponential_Rate_Compute(node,odeConverged,interrupt,interruptProcedure,propertyType)
    implicit none
    type     (treeNode             ), pointer, intent(inout) :: node
    logical                                  , intent(in   ) :: odeConverged
    logical                                  , intent(inout) :: interrupt
    procedure(                     ), pointer, intent(inout) :: interruptProcedure
    integer                                  , intent(in   ) :: propertyType
    class    (nodeComponentDisk    ), pointer                :: disk
 
    ! Get the disk and check that it is of our class.
    disk => node%disk()
    select type (disk)
    class is (nodeComponentDiskExponential)
      ...
      call disk%massStellarRate(stellarMassRate)
      ...
    end select
    return
  end subroutine Node_Component_Disk_Exponential_Rate_Comput
\end{lstlisting}
Here, we get the disk component and check that it of the {\normalfont \ttfamily exponential} variety. If it is, we compute the rates of change for one or more properties and then adjust their rates appropriately. If multiple instances of a component are used then the rate compute function should loop over all instances and adjust rates appropriately. The {\normalfont \ttfamily propertyType} argument will be set either to {\normalfont \ttfamily propertyTypeActive} or {\normalfont \ttfamily propertyTypeInactive}, and indicates if rates should be computed for active or inactive variables. (Rates for active variables can be computed and set even if inactive variables are requested, and vice versa. They will simply be ignored, and so this merely wastes compute time.) The {\normalfont \ttfamily odeConverged} variable indicates if the ODE solver has reached convergence---in some instances it is useful to trigger interrupts only once convergence is reached. If an interrupt occurs, {\normalfont \ttfamily interrupt} should be set to {\normalfont \ttfamily true}, and {\normalfont \ttfamily interruptProcedure} should be set to point to the function to call on interrupt.

When evolving ODEs the ODE solver aims to keep the error on property $i$ below
\begin{equation}
 D_i = \epsilon_\mathrm{abs} s_i + \epsilon_\mathrm{rel} |y_i|,
\end{equation}
where $epsilon_\mathrm{abs}=${\normalfont \ttfamily [odeToleranceAbsolute]}, $epsilon_\mathrm{rel}=${\normalfont \ttfamily [odeToleranceRelative]}, $y_i$ is the value of property $i$ and $s_i$ is a scaling factor which controls the absolute tolerance for this property. By default, $s_i=1$, but this can be changed for a component utilizing the {\normalfont \ttfamily scaleSetTask} directive. This allows a function to be called in which the component sets suitable scale factors for each of its properties prior to any ODE evolution being carried out. This can be very useful, for example, in cases where two components are coupled. Consider a case where a disk is transferring material to a spheroid via a bar instability. If the disk is orders of magnitude more massive that the spheroid then the rate of mass transfer can be very high (i.e. $\dot{y}/y$ for the spheroid will be large). With just a relative tolerance (i.e. the $\epsilon_\mathrm{rel} |y_i|$ term) this would require very short timesteps for the spheroid. However, in such cases we don't care about such tiny tolerances for the spheroid (since it will grow to be substantially more massive). Therefore, it may be appropriate to set $s_i$ to be equal to the sum of the disk and spheroid properties for example. The scale set directive and associated subroutine should follow this template:
\begin{verbatim}
  !# <scaleSetTask>
  !#  <unitName>Node_Component_Disk_Exponential_Scale_Set</unitName>
  !# </scaleSetTask>
  subroutine Node_Component_Disk_Exponential_Scale_Set(thisNode)
    implicit none
    type (treeNode         ), pointer, intent(inout) :: thisNode
    class(nodeComponentDisk), pointer                :: disk

    ! Get the disk component.
    disk => thisNode%disk()
    ! Check if an exponential disk component exists.
    select type (disk)
    class is (nodeComponentDiskExponential)
      ...
      call disk%massStellarScale(massScale)
      ...
    end select
    return
  end subroutine Node_Component_Disk_Exponential_Scale_Set
\end{verbatim}
Sensible choices for the $s_i$ factors can significantly speed-up execution of \glc.

\subsubsection{Evolution Interrupts}\index{interrupts}\index{evolution!interrupt}

It is often necessary to interrupt the smooth ODE evolution of a node in \glc. This can happen if, for example, a galaxy mergers with another galaxy (in which case the merger must be processed prior to further evolution) or if a component must be created before evolution can continue. The rate adjust and rate compute subroutines allow for interrupts to be flagged via their {\normalfont \ttfamily interrupt} and {\normalfont \ttfamily interruptProcedure} arguments. If an interrupt is required then {\normalfont \ttfamily interrupt} should be set to true, while {\normalfont \ttfamily interruptProcedure} should be set to point to a procedure which will handle the interrupt. Then, providing no other interrupt occurred earlier, the evolution will be stopped and the interrupt procedure called before evolution is continued.

An interrupt procedure should have the form:
\begin{lstlisting}[escapechar=@,breaklines,prebreak=\&,postbreak=\&]
  subroutine My_Interrupt_Procedure(thisNode)
    implicit none
    type(treeNode), pointer, intent(inout) :: thisNode
  
    ! Do whatever needs to be done to handle the interrupt.

    return
  end subroutine My_Interrupt_Procedure
\end{lstlisting}

\section{Existing Method Types}

\subsection{Functions}

Functions implement basic calculations (e.g. computing the power spectrum).

\IfFileExists{./autoMethods.tex}{\input{autoMethods}}{}

\subsubsection{Accretion Disks}\label{sec:AccretionDisks}

Additional methods for accretion disk properties can be added using the {\normalfont \ttfamily accretionDisksMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily Shakura-Sunyae} method is described by a directive:
\begin{verbatim}
 !# <accretionDisksMethod>
 !#  <unitName>Accretion_Disks_Shakura_Sunyaev_Initialize</unitName>
 !# </accretionDisksMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Accretion\_Disks\_Shakura\_Sunyaev\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(accretionDisksMethod,Accretion_Disk_Radiative_Efficiency_Get,Black_Hole_Spin_Up_Rate_Get,Accretion_Disk_Jet_Power_Get)
    implicit none
    type(varying_string),          intent(in)    :: accretionDisksMethod
    procedure(),          pointer, intent(inout) :: Accretion_Disk_Radiative_Efficiency_Get,Black_Hole_Spin_Up_Rate_Get,Accretion_Disk_Jet_Power_Get
    
    if (accretionDisksMethod == 'myMethod') then
       Accretion_Disk_Radiative_Efficiency_Get => My_Accretion_Disk_Radiative_Efficiency_Get
       Black_Hole_Spin_Up_Rate_Get             => My_Black_Hole_Spin_Up_Rate_Get
       Accretion_Disk_Jet_Power_Get            => My_Accretion_Disk_Jet_Power_Get
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily accretionDisksMethod} input parameter. The procedure pointers {\normalfont \ttfamily Accretion\_Disk\_Radiative\_Efficiency\_Get}, {\normalfont \ttfamily Black\_Hole\_Spin\_Up\_Rate\_Get} and {\normalfont \ttfamily Accretion\_Disk\_Jet\_Power\_Get} must be set to point to functions which return the radiative efficiency, black hole spin up rate and jet power for the accretion disk respectively as described below. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The radiative efficiency function must have the form:
\begin{verbatim}
 double precision function My_Accretion_Disk_Radiative_Efficiency_Get(thisNode,massAccretionRate)
    implicit none
    type(treeNode),   intent(inout), pointer :: thisNode
    double precision, intent(in)             :: massAccretionRate
    .
    .
    .
    return
 end function My_Accretion_Disk_Radiative_Efficiency_Get
\end{verbatim}
The function must return the radiative efficiency for the accretion disk in {\normalfont \ttfamily thisNode}. The black hole spin function must have the form:
\begin{verbatim}
 double precision function My_Black_Hole_Spin_Up_Rate_Get(thisNode,massAccretionRate)
    implicit none
    type(treeNode),   intent(inout), pointer :: thisNode
    double precision, intent(in)             :: massAccretionRate
    .
    .
    .
    return
 end function My_Black_Hole_Spin_Up_Rate_Get
\end{verbatim}
The function must return the spin-up rate for the black hole in {\normalfont \ttfamily thisNode} given the {\normalfont \ttfamily massAccretionRate}. The jet power function must have the form:
\begin{verbatim}
 double precision function My_Accretion_Disk_Jet_Power_Get(thisNode,massAccretionRate)
    implicit none
    type(treeNode),   intent(inout), pointer :: thisNode
    double precision, intent(in)             :: massAccretionRate
    .
    .
    .
    return
 end function My_Accretion_Disk_Jet_Power_Get
\end{verbatim}
The function must return (in units of $M_\odot$ (km/s)$^2$ Gyr$^{-1}$) the jet power for the black hole/accretion disk system in {\normalfont \ttfamily thisNode} given the {\normalfont \ttfamily massAccretionRate}.

Currently defined accretion disk methods are:
\begin{description}
 \item [{\normalfont \ttfamily Shakura-Sunyaev}] Computes the properties of a thin, radiatively efficiency accretion disk.
 \item [{\normalfont \ttfamily ADAF}] Computes the properties of an ADAF using the model of \cite{benson_maximum_2009}.
 \item [{\normalfont \ttfamily switched}] Select either {\normalfont \ttfamily Shakura-Sunyaev} or {\normalfont \ttfamily ADAF} accretion disks based on the accretion rate:
 \begin{eqnarray}
  \dot{m}_\mathrm{minimum} < \dot{M}_{\bullet, 0}/\dot{M}_\mathrm{Eddington} < \dot{m}_\mathrm{maximum} &\rightarrow& \hbox{ Shakura-Sunyaev} \nonumber \\
  \hbox{otherwise } &\rightarrow& \hbox{ ADAF},
 \end{eqnarray}
 where $\dot{m}_\mathrm{minimum}$={\normalfont \ttfamily accretionRateThinDiskMinimum} and $\dot{m}_\mathrm{maximum}$={\normalfont \ttfamily accretionRateThinDiskMaximum} are input parameters.
 \item [{\normalfont \ttfamily eddingtonLimited}] Assumes no specific disk structure, instead setting the radiative efficiency to a fixed number and the jet power to a fixed fraction of the Eddington luminosity.
\end{description}

\subsubsection{Analysis}

Additional methods for on-the-fly analysis of merger trees can be added using the {\normalfont \ttfamily mergerTreeAnalysisTask} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the mass distributions method is described by a directive:
\begin{verbatim}
 !# <mergerTreeAnalysisTask>
 !#  <unitName>Galacticus_Output_Analysis_Mass_Dpndnt_Sz_Dstrbtins</unitName>
 !# </mergerTreeAnalysisTask>
\end{verbatim}
Here, {\normalfont \ttfamily Galacticus\_Output\_Analysis\_Mass\_Dpndnt\_Sz\_Dstrbtins} is the name of a subroutine which will be called to perform the analysis. The analysis subroutine must have the following form:
\begin{verbatim}
  subroutine Tree_Analyze(thisTree,thisNode,iOutput,mergerTreeAnalyses)
    implicit none
    type            (mergerTree    ), intent(in   )                 :: thisTree
    type            (treeNode      ), intent(inout), pointer        :: thisNode
    integer                         , intent(in   )                 :: iOutput
    type            (varying_string), intent(in   ), dimension(:  ) :: mergerTreeAnalyses
    .
    .
    .
    return
  end subroutine Method_Initialize
\end{verbatim}
This function will be called once for each node in each tree being output. The function is passed the merger tree object as {\normalfont \ttfamily thisTree}, along with a pointer to the node to be analyzed as {\normalfont \ttfamily thisNode}. Additionally, the current output number is passed as {\normalfont \ttfamily iOutput}. Finally, a list of analyses that were requested (by user input) to be performed is given in the {\normalfont \ttfamily mergerTreeAnalyses} array. The function should check if one or more of the entries in {\normalfont \ttfamily mergerTreeanalyses} correspond to analyses that it performs. (Note that this need only be done on the first call to this function---the values of {\normalfont \ttfamily mergerTreeAnalyses} will not change between calls.) If an analysis is matched in this way it should be performed. Typically, an analysis function might accumulate the results of analysis and then finalize and output them prior to completion of the \glc\ model through the use of a {\normalfont \ttfamily hdfPreCloseTask} (see \S\ref{sec:HDFFileClose}).

Currently defined merger tree analysis methods are (see \S\ref{sec:OnTheFlyAnalysis}):
\begin{description}
 \item [mass functions] Constructs mass functions for a variety of different surveys. Currently supported analysis names are: {\normalfont \ttfamily sdssStellarMassFunctionZ0.07}, {\normalfont \ttfamily alfalfaHiMassFunctionZ0.00}, {\normalfont \ttfamily primusStellarMassFunctionZ0.100}, {\normalfont \ttfamily primusStellarMassFunctionZ0.250}, {\normalfont \ttfamily primusStellarMassFunctionZ0.350}, {\normalfont \ttfamily primusStellarMassFunctionZ0.450}, {\normalfont \ttfamily primusStellarMassFunctionZ0.575}, {\normalfont \ttfamily primusStellarMassFunctionZ0.725}, and {\normalfont \ttfamily primusStellarMassFunctionZ0.900}. Each such analysis is defined internally to this module through the appropriate redshift, binning, random and systematic errors, and arbitrary mapping of component masses into observed masses. The covariance matrix of the mass function is also computed (see \S\ref{sec:AnalysisALFALFAHIMassFunction} for details).
 \item [mass-dependent size distributions] Constructs a two-dimensional histogram of galaxy sizes in bins of stellar mass. Currently supported analyses are {\normalfont \ttfamily sdssSizeFunctionZ0.07}. Each such analysis is defined internally to this module through the appropriate redshift, binning, random and systematic errors, and arbitrary mapping of component masses/radii into observed masses/radii. The covariance matrix of the size function is also computed (see \S\ref{sec:SDSSLateTypeGalaxySizeDistribution} for details).
\end{description}

\subsubsection{Radiation Components}\index{radiation}\label{sec:radiationComponents}

Radiation components (i.e. types of radiation field that may be added to any radiation object; see \S\ref{sec:RadiationSubsystem}) are defined using a combination of several directives: {\normalfont \ttfamily radiationLabel}, {\normalfont \ttfamily radiationSet}, {\normalfont \ttfamily radiationTemperature} and {\normalfont \ttfamily radiationFlux}. For example, the cosmic microwave background radiation component is defined by the following set of directives:
\begin{verbatim}
  !# <radiationLabel>
  !#  <label>CMB</label>
  !# </radiationLabel>

  !# <radiationSet>
  !#  <unitName>Radiation_Set_CMB</unitName>
  !#  <label>CMB</label>
  !# </radiationSet>

  !# <radiationTemperature>
  !#  <unitName>Radiation_Temperature_CMB</unitName>
  !#  <label>CMB</label>
  !# </radiationTemperature>

  !# <radiationFlux>
  !#  <unitName>Radiation_Flux_CMB</unitName>
  !#  <label>CMB</label>
  !# </radiationFlux>
\end{verbatim}
The first of these, {\normalfont \ttfamily radiationLabel}, should contain a single element, {\normalfont \ttfamily label}, which gives a label that will be used to identify this component, both in other directives and also in the internal parameters used to select this radiation component (e.g. in this case, a parameter {\normalfont \ttfamily radiationTypeCMB} will be available within \glc\ to select the cosmic microwave background component). The other directives must all specify the same {\normalfont \ttfamily label} element and additional give, in a {\normalfont \ttfamily unitName} element, the name of a function/subroutine to be called to perform the relevant calculation.

The {\normalfont \ttfamily radiationSet} directive must specify a subroutine with the following template:
\begin{verbatim}
  subroutine Radiation_Set(componentMatched,thisNode,radiationProperties)
   implicit none
   logical,          intent(in)                               :: componentMatched
   type(treeNode),   intent(inout), pointer                   :: thisNode
   double precision, intent(inout), allocatable, dimension(:) :: radiationProperties

   if (.not.componentMatched) return
   .
   .
   .
   return
  end subroutine Radiation_Set
\end{verbatim}
If {\normalfont \ttfamily componentMatched} is true, then the subroutine should set the radiation component, otherwise it should exit immediately. If the radiation component is to be set, then the routine can allocate the {\normalfont \ttfamily radiationProperties} array as necessary to store any data needed to specify the radiation field. These data should then be set using, if necessary, any relevant information from {\normalfont \ttfamily thisNode}.

The {\normalfont \ttfamily radiationTemperature} directive should specify a subroutine with the following template:
\begin{verbatim}
  subroutine Radiation_Temperature(requestedType,ourType,radiationProperties,radiationTemperature,radiationType)
   implicit none
   integer,          intent(in)                            :: requestedType,ourType
   double precision, intent(in),              dimension(:) :: radiationProperties
   double precision, intent(inout)                         :: radiationTemperature
   integer,          intent(in),    optional, dimension(:) :: radiationType

   if (requestedType /= ourType) return
   if (present(radiationType)) then
      if (all(radiationType /= ourType)) return
   end if
   .
   .
   .
   return
  end subroutine Radiation_Temperature
\end{verbatim}
The tests in the above should always be included so that the subroutine exits immediately if the component type is not active or not requested. Once these tests have been made, the subroutine should set the temperature (in units of Kelvin) of the radiation field (if applicable).

The {\normalfont \ttfamily radiationFlux} directive should specify a subroutine with the following template:
\begin{verbatim}
  subroutine Radiation_Flux(requestedType,ourType,radiationProperties,wavelength,radiationFlux,radiationType)
    implicit none
    integer,          intent(in)                           :: requestedType,ourType
    double precision, intent(in)                           :: wavelength
    double precision, intent(in),             dimension(:) :: radiationProperties
    double precision, intent(inout)                        :: radiationFlux
    integer,          intent(in),   optional, dimension(:) :: radiationType

    if (requestedType /= ourType) return
    if (present(radiationType)) then
       if (all(radiationType /= ourType)) return
    end if
    .
    .
    .
    return
  end subroutine Radiation_Flux
\end{verbatim}
The tests in the above should always be included so that the subroutine exits immediately if the component type is not active or not requested. Once these tests have been made, the subroutine should add the flux (in units of ergs cm$^2$ s$^{-1}$ Hz$^{-1}$ ster$^{-1}$) at the specified {\normalfont \ttfamily wavelength} (in units of \AA) of the radiation field to that in {\normalfont \ttfamily radiationFlux}.

Currently defined radiation component types are:
\begin{description}
 \item [{\normalfont \ttfamily null}] A null component with no radiation.
 \item [{\normalfont \ttfamily CMB}] The cosmic microwave background, assumed to be a perfect blackbody spectrum with a temperature equal to {\normalfont \ttfamily [T\_CMB]}$(1+z)$.
 \item [{\normalfont \ttfamily IGB}] The intergalactic background light, set using the method selected by {\normalfont \ttfamily [radiationIntergalacticBackgroundMethod]; see \S\ref{sec:radiationIGB}}.
\end{description}

\subsubsection{Radiation Components: Intergalactic Background}\label{sec:radiationIGB}

Additional methods for the intergalactic background radiation component can be added using the {\normalfont \ttfamily radiationIntergalacticBackgroundMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily file} method is described by a directive:
\begin{verbatim}
 !# <radiationIntergalacticBackgroundMethod>
 !#  <unitName>Radiation_IGB_File_Initialize</unitName>
 !# </radiationIntergalacticBackgroundMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Radiation\_IGB\_File\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(radiationIntergalacticBackgroundMethod,Radiation_Set_Intergalactic_Background_Do,Radiation_Flux_Intergalactic_Background_Do)
    implicit none
    type(varying_string),          intent(in)    :: radiationIntergalacticBackgroundMethod
    procedure(),          pointer, intent(inout) :: Radiation_Set_Intergalactic_Background_Do,Radiation_Flux_Intergalactic_Background_Do
    
    if (radiationIntergalacticBackgroundMethod == 'myMethod') then
      Radiation_Set_Intergalactic_Background_Do  => My_Method_Set
      Radiation_Flux_Intergalactic_Background_Do => My_Method_Flux
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily radiationIntergalacticBackgroundMethod} input parameter. The procedure pointers {\normalfont \ttfamily Radiation\_Set\_Intergalactic\_Background\_Do} and {\normalfont \ttfamily Radiation\_Flux\_Intergalactic\_Background\_Do} must be set to point to subroutines which set the radiation field and return its flux as described below. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The set subroutine must have the form:
\begin{verbatim}
  subroutine My_Method_Set(thisNode,radiationProperties)
    implicit none
    type(treeNode),   intent(inout), pointer                   :: thisNode
    double precision, intent(inout), allocatable, dimension(:) :: radiationProperties

    return
  end subroutine My_Method_Set
\end{verbatim}
and should set the radiation component as described in \S\ref{sec:radiationComponents}. The flux subroutine must have the form:
\begin{verbatim}
   subroutine My_Method_Flux(radiationProperties,wavelength,radiationFlux)
    implicit none
    double precision, intent(in)                 :: wavelength
    double precision, intent(in),   dimension(:) :: radiationProperties
    double precision, intent(inout)              :: radiationFlux

    return
   end subroutine My_Method_Flux
\end{verbatim}
and should increment {\normalfont \ttfamily radiationFlux} as described in \S\ref{sec:radiationComponents}.

Currently defined intergalactic background radiation methods are:
\begin{description}
 \item [{\normalfont \ttfamily file}] The intergalatic background radiation field, specified as a function of cosmic time, is read from a file. The flux is determined by linearly interpolating to the required time and wavelength. The XML file to read is specified by {\normalfont \ttfamily [radiationIGBFileName]}. An example of the required file structure is:
 \begin{verbatim}
<spectrum>
  <URL>http://adsabs.harvard.edu/abs/1996ApJ...461...20H</URL>
  <description>Cosmic background radiation spectrum from quasars alone.</description>
  <reference>Haardt, F. &amp; Madau, P. 1996, ApJ, 461, 20</reference>
  <source>Francesco Haardt on Aug 6 2005, via Cloudy 08.00</source>
  <wavelengths>
    <datum>0.0002481</datum>
    <datum>0.001489</datum>
    .
    .
    .
    <units>Angstroms</units>
  </wavelengths>
  <spectra>
    <datum>7.039E-49</datum>
    <datum>8.379E-48</datum>
    <datum>1.875E-39</datum>
    <datum>7.583E-38</datum>
    .
    .
    .
    <redshift>0</redshift>
    <units>erg cm^-2 s^-1 Hz^-1 sr^-1</units>
  </spectra>
</spectrum>
 \end{verbatim}
\end{description}
The optional {\normalfont \ttfamily URL}, {\normalfont \ttfamily description}, {\normalfont \ttfamily reference} and {\normalfont \ttfamily source} elements can be used to give the provenance of the data. The {\normalfont \ttfamily wavelengths} element should contain a set of {\normalfont \ttfamily datum} elements each containing a wavelength (in increasing order) at which the spectrum will be tabulated. Wavelengths must be given in Angstroms. Multiple {\normalfont \ttfamily spectra} elements can be given, each specifying the spectrum at a redshift as given in the {\normalfont \ttfamily redshift} element. Each {\normalfont \ttfamily spectra} element must contain an array of {\normalfont \ttfamily datum} elements that gives the spectrum at each wavelength listed in the {\normalfont \ttfamily wavelength} element. Spectra must be in units of erg cm$^{-2}$ s$^{-1}$ Hz$^{-1}$ sr$^{-1}$.

\subsubsection{Tree Timing}

Additional methods for tree timing (i.e. the time taken to process a given merger tree) can be added using the {\normalfont \ttfamily timePerTreeMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily file} method is described by a directive:
\begin{verbatim}
  !# <timePerTreeMethod>
  !#  <unitName>Galacticus_Time_Per_Tree_File_Initialize</unitName>
  !# </timePerTreeMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Galacticus\_Time\_Per\_Tree\_File\_Initialize} is the name of a subroutine which will be called to initialize the method. The initialization subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize(timePerTreeMethod,Galacticus_Time_Per_Tree_Get)
    implicit none
    type(varying_string),          intent(in)    :: timePerTreeMethod
    procedure(),          pointer, intent(inout) :: Galacticus_Time_Per_Tree_Get
    
    if (timePerTreeMethod == 'myMethod') then
       Galacticus_Time_Per_Tree_Get => My_Time_Per_Tree_Get
       .
       .
       .
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily timePerTreeMethod} input parameter. The procedure pointer {\normalfont \ttfamily Galacticus\_Time\_Per\_Tree\_Get} must be set to point to a function which returns an estimate of the time taken (in seconds) to process a merger tree. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The function must have the form:
\begin{verbatim}
   double precision function Time_Per_Tree(treeRootMass)
    implicit none
    double precision, intent(in) :: treeRootMass
    .
    .
    .
    return
   end function Time_Per_Tree 
\end{verbatim}
The function must return an estimate of the time taken (in seconds) to process a merger tree with the given {\normalfont \ttfamily treeRootMass}.

Currently defined tree timing methods are:
\begin{description}
 \item [{\normalfont \ttfamily file}] This method reads coefficients of a simple fitting formula for the processing time from a file, specified via the {\normalfont \ttfamily [timePerTreeFitFileName]} parameter (see \S\ref{sec:TreeTimingFile}).
\end{description}

\subsection{Events}

Events are triggered during merger tree evolution. Examples are when a node needs to be promoted to its parent node, or when a minor node merges with its parent.

\subsubsection{Node Promotion Events}

Additional methods for node promotion (i.e. when a primary progenitor reaches its parent halo) can be added using the {\normalfont \ttfamily nodePromotionTask} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily basic} tree node method uses this directive as follows:
\begin{verbatim}
  !# <nodePromotionTask>
  !#  <unitName>Tree_Node_Basic_Promote</unitName>
  !# </nodePromotionTask>
\end{verbatim}
Here, {\normalfont \ttfamily Tree\_Node\_Basic\_Promote} is the name of a subroutine which will be called to perform whatever tasks are required prior to the promotion. The subroutine must have the following form:
\begin{verbatim}
   subroutine Node_Promotion_Task(thisNode)
    implicit none
    type(treeNode), pointer, intent(inout) :: thisNode
    .
    .
    .
    return
  end subroutine Node_Promotion_Task
\end{verbatim}
where {\normalfont \ttfamily thisNode} is the node about to be promoted.

\subsection{Tasks}

Tasks are any processing which must be performed on a node as a result of some specific event (such as a merger).

\subsubsection{Calculation Reset Tasks}\label{sec:CalculationResetTask}

Additional methods for calculation reset tasks (i.e. flagging that the properties of a node may have changed so that any calculations must be performed anew) can be added using the {\normalfont \ttfamily calculationResetTask} directive. The directive should contain a single argument, giving the name of a subroutine to be called to perform the task. For example, the standard hot halo component adds a task as follows:
\begin{verbatim}
  !# <calculationResetTask>
  !#  <unitName>Tree_Node_Hot_Halo_Reset_Standard</unitName>
  !# </calculationResetTask>
\end{verbatim}
Here, {\normalfont \ttfamily Tree\_Node\_Hot\_Halo\_Reset\_Standard} is the name of a subroutine which will be called to perform whatever tasks are required. The subroutine must have the following form:
\begin{verbatim}
   subroutine Reset_Task(thisNode)
    implicit none
    type(treeNode), pointer, intent(inout) :: thisNode
    .
    .
    .
    return
  end subroutine Prederivative_Task
\end{verbatim}
where {\normalfont \ttfamily thisNode} is the node for which derivatives will be computed. Tasks typically involve precomputing quantities that will be used in finding the derivatives or resetting the state so that stored quantities will be recomputed as needed.

\subsubsection{Decode Property Identifier Tasks}\label{sec:DecodePropertyIndentifierTask}

Additional property identifier decoding tasks (i.e. determining the name of a property from a set of integer identifiers) can be added using the {\normalfont \ttfamily decodePropertyIdentifiersTask} directive. The directive should contain a single argument, giving the name of a subroutine to be called to perform the task. For example, the Hernquist spheroid component adds a task as follows:
\begin{verbatim}
  !# <decodePropertyIdentifiersTask>
  !#  <unitName>Hernquist_Spheroid_Property_Identifiers_Decode</unitName>
  !# </decodePropertyIdentifiersTask>
\end{verbatim}
Here, {\normalfont \ttfamily Hernquist\_Spheroid\_Property\_Identifiers\_Decode} is the name of a subroutine which will be called to perform the decoding task. The subroutine must have the following form:
\begin{verbatim}
   subroutine Property_Identifier_Decode_Task(propertyComponent,propertyObject,propertyIndex,matchedProperty,propertyName)
    implicit none
    integer,              intent(in)    :: propertyComponent,propertyObject,propertyIndex
    logical,              intent(inout) :: matchedProperty
    type(varying_string), intent(inout) :: propertyName
    .
    .
    .
    return
  end subroutine Property_Identifier_Decode_Task
\end{verbatim}
The task should check whether {\normalfont \ttfamily propertyComponent} matches its stored {\normalfont \ttfamily componentIndex} value. If it does, it should set {\normalfont \ttfamily propertyName} to a suitable name (e.g. {\normalfont \ttfamily hernquistSpheroid::stellarMass}) and set {\normalfont \ttfamily matchedProperty}$=${\normalfont \ttfamily true}. The value of {\normalfont \ttfamily propertyObject} will be either {\normalfont \ttfamily objectTypeProperty} indicating that the object in question is a standard property, or {\normalfont \ttfamily objectTypeHistory} indicating that it is a history. The value of {\normalfont \ttfamily propertyIndex} then gives the position of the object in question in the array of properties or histories.

\subsubsection{Evolution Timestep Tasks}

Merger tree nodes are evolved over some fixed timestep before evolution is stopped and other processing is allowed. The timestep is always sufficiently small such that the node does not evolve past the time of its parent node, nor does it evolve past the time of any of its satellite nodes. An arbitrary number of other criteria can be used to adjust the timestep. Such a criterion can be added using the {\normalfont \ttfamily timeStepsTask} directive. For example, the {\normalfont \ttfamily simple} timestep task adds itself using
\begin{verbatim}
 !# <timeStepsTask>
 !#  <unitName>Merger_Tree_Timestep_Simple</unitName>
 !# </timeStepsTask>
\end{verbatim}
Here, {\normalfont \ttfamily unitName} gives the name of the subroutine to be called to (possibly) adjust the timestep. It should have the following form:
\begin{verbatim}
  subroutine My_Timestep(thisNode,timeStep,End_Of_Timestep_Task,report,lockNode,lockType)
    implicit none
    type     (treeNode      ), intent(inout), pointer           :: thisNode
    procedure(              ), intent(inout), pointer           :: End_Of_Timestep_Task
    double precision         , intent(inout)                    :: timeStep
    logical                  , intent(in   )                    :: report
    type     (treeNode      ), intent(inout), pointer, optional :: lockNode
    type     (varying_string), intent(inout),          optional :: lockType
    .
    .
    .
    return
  end subroutine My_Timestep
\end{verbatim}
This subroutine should compute a suitable timestep for {\normalfont \ttfamily thisNode} and, if it is less than the currently defined value of {\normalfont \ttfamily timeStep} should set {\normalfont \ttfamily timeStep} to that value. Optionally, the procedure pointer {\normalfont \ttfamily End\_Of\_Timestep\_Task} can be set to point to a subroutine which will be called after the node is evolved to the end of the timestep. It is acceptable for this pointer to be null. Note that the {\normalfont \ttfamily End\_Of\_Timestep\_Task} will only be called for the task which provided the shortest timestep---other tasks can always request to be called again when the next timestep is determined. The subroutine to be called at the end of the timestep must have the form:
\begin{verbatim}
  subroutine My_End_Of_Timestep_Task(thisTree,thisNode,deadlockStatus)
    implicit none
    type(mergerTree), intent(in)             :: thisTree
    type(treeNode),   intent(inout), pointer :: thisNode
    integer,          intent(inout)          :: deadlockStatus
    .
    .
    .
    return
  end subroutine My_End_Of_Timestep_Task
\end{verbatim}
The {\normalfont \ttfamily deadlockStatus} argument should be set to {\normalfont \ttfamily isNotDeadlocked} (provided by the \hyperlink{merger_trees.evolve.deadlock_options.F90:merger_trees_evolve_deadlock_status}{\normalfont \ttfamily Merger\_Trees\_Evolve\_Deadlock\_Status} module) if, and only if, the end of timestep task makes some change to the state of the tree (e.g. merging a node), to indicate that the tree was not deadlocked in this pass (i.e. something actually changed in the tree).

If the {\normalfont \ttfamily report} argument is {\normalfont \ttfamily true} then the function should report the value of {\normalfont \ttfamily timestep} prior to exiting. (This is used in reporting on timestepping criteri in deadlocked trees.) It is recommended that the report be made using the \hyperlink{merger_trees.evolve.timesteps.report.F90:evolve_to_time_reports:evolve_to_time_report}{\normalfont \ttfamily Evolve\_To\_Time\_Report()} function. Additionally, if the optional {\normalfont \ttfamily lockNode} and {\normalfont \ttfamily lockType} arguments are present then additional information can be supplied to aid in diagnosing deadlock conditions. If the current task is limiting the timestep then the {\normalfont \ttfamily lockNode} pointer should be set to point to whichever node is causing the limit (which may be {\normalfont \ttfamily thisNode} or some other node, e.g. a satellite of {\normalfont \ttfamily thisNode}, etc.), and {\normalfont \ttfamily lockType} should be set to a short description label identifying the type of limit.

\subsubsection{Galactic Component Density}\label{sec:GalacticComponentDensity}

The function {\normalfont \ttfamily Galactic\_Structure\_Density()} computes the density of material at a given position within a node. To have their density counted, each component must register a task using:
\begin{verbatim}
 !# <densityTask>
 !#  <unitName>Density_Procedure</unitName>
 !# </densityTask>
\end{verbatim}
where {\normalfont \ttfamily Density\_Procedure} is the name of a function with the following template
\begin{verbatim}
 double precision function Density_Procedure(thisNode,position,coordinateSystem,componentType,massType,weightBy,weightIndex,haloLoaded)
    type(treeNode),   intent(inout), pointer  :: thisNode
    integer,          intent(in)              :: massType,coordinateSystem,componentType,weightBy,weightIndex
    double precision, intent(in)              :: radius
    logical         , intent(in),    optional :: haloLoaded
    .
    .
    .
    return
 end function Density_Procedure
\end{verbatim}
If {\normalfont \ttfamily componentType} is a match to the component then the function should return the density of the component matching type {\normalfont \ttfamily massType} at {\normalfont \ttfamily position} for {\normalfont \ttfamily thisNode}. {\normalfont \ttfamily componentType} and {\normalfont \ttfamily massType} can take one of the values described in \S\ref{sec:ComponentMassTypes}. In the above ``density'' can actually refer to different quantities depending on the values of {\normalfont \ttfamily weightBy} (and {\normalfont \ttfamily weightIndex}):
\begin{description}
\item [{\normalfont \ttfamily weightByMass}] The actual mass should be returned (the value of {\normalfont \ttfamily weightIndex} is irrelevant);
\item [{\normalfont \ttfamily weightByLuminosity}] The {\normalfont \ttfamily weightIndex}$^\mathrm{th}$ luminosity should be returned.
\end{description}
If {\normalfont \ttfamily haloLoaded}$=${\normalfont \ttfamily true} (which should be the default if this option is not present), then the effects of baryonic loading on the halo profile should be taken into account where necessary. Otherwise, the effects of baryonic loading should be ignored.

\subsubsection{Galactic Component Enclosed Mass}

The function {\normalfont \ttfamily Galactic\_Structure\_Enclosed\_Mass()} computes the mass within a specified radius in a node. To have their mass counted, each component must register a task using:
\begin{verbatim}
 !# <enclosedMassTask>
 !#  <unitName>Enclosed_Mass_Procedure</unitName>
 !# </enclosedMassTask>
\end{verbatim}
where {\normalfont \ttfamily Enclosed\_Mass\_Procedure} is the name of a function with the following template
\begin{verbatim}
 double precision function Enclosed_Mass_Procedure(thisNode,radius,componentType,massType,weightBy,weightIndex,haloLoaded)
    type(treeNode),   intent(inout), pointer  :: thisNode
    integer,          intent(in)              :: massType,componentType,weightBy,weightIndex
    double precision, intent(in)              :: radius
    logical         , intent(in),    optional :: haloLoaded
    .
    .
    .
    return
 end function Enclosed_Mass_Procedure
\end{verbatim}
If {\normalfont \ttfamily componentType} is a match to the component then the function should return the ``mass'' of the component matching type {\normalfont \ttfamily massType} within {\normalfont \ttfamily radius} for {\normalfont \ttfamily thisNode}.  {\normalfont \ttfamily componentType} and {\normalfont \ttfamily massType} can take one of the values described in \S\ref{sec:ComponentMassTypes}.
If {\normalfont \ttfamily radius} is equal to or greater than {\normalfont \ttfamily radiusLarge} the routine should the total ``mass'' (i.e. ``mass'' within infinite radius). In the above ``mass'' can actually refer to different quantities depending on the values of {\normalfont \ttfamily weightBy} (and {\normalfont \ttfamily weightIndex}):
\begin{description}
\item [{\normalfont \ttfamily weightByMass}] The actual mass should be returned (the value of {\normalfont \ttfamily weightIndex} is irrelevant);
\item [{\normalfont \ttfamily weightByLuminosity}] The {\normalfont \ttfamily weightIndex}$^\mathrm{th}$ luminosity should be returned.
\end{description}
If {\normalfont \ttfamily haloLoaded}$=${\normalfont \ttfamily true} (which should be the default if this option is not present), then the effects of baryonic loading on the halo profile should be taken into account where necessary. Otherwise, the effects of baryonic loading should be ignored.

\subsubsection{Galactic Component Rotation Curve}

The function {\normalfont \ttfamily Galactic\_Structure\_Rotation\_Curve()} computes the rotation curve at a specified radius in a node. To have their contribution counted, each component must register a task using:
\begin{verbatim}
 !# <rotationCurveTask>
 !#  <unitName>Rotation_Curve_Procedure</unitName>
 !# </rotationCurveTask>
\end{verbatim}
where {\normalfont \ttfamily Rotation\_Curve\_Procedure} is the name of a function with the following template
\begin{verbatim}
 double precision function Rotation_Curve_Procedure(thisNode,radius,componentType,massType,haloLoaded)
    type(treeNode),   intent(inout), pointer  :: thisNode
    integer,          intent(in)              :: massType,componentType
    double precision, intent(in)              :: radius
    logical         , intent(in),    optional :: haloLoaded
    .
    .
    .
    return
 end function Rotation_Curve_Procedure
\end{verbatim}
If {\normalfont \ttfamily componentType} is a match to the component then the procedure should return the contribution to the rotation curve due to the component matching type {\normalfont \ttfamily massType} within {\normalfont \ttfamily radius} for {\normalfont \ttfamily thisNode}. {\normalfont \ttfamily componentType} and {\normalfont \ttfamily massType} can take one of the values described in \S\ref{sec:ComponentMassTypes}. If {\normalfont \ttfamily haloLoaded}$=${\normalfont \ttfamily true} (which should be the default if this option is not present), then the effects of baryonic loading on the halo profile should be taken into account where necessary. Otherwise, the effects of baryonic loading should be ignored.

\subsubsection{Galactic Component Rotation Curve Gradient}

The function {\normalfont \ttfamily Galactic\_Structure\_Rotation\_Curve\_Gradient()} computes the gradient of the rotation curve at a specified radius in a node. To have their contribution counted, each component must register a task using:
\begin{verbatim}
 !# <rotationCurveGradientTask>
 !#  <unitName>Rotation_Curve_Gradient_Procedure</unitName>
 !# </rotationCurveGradientTask>
\end{verbatim}
where {\normalfont \ttfamily Rotation\_Curve\_Gradient\_Procedure} is the name of a function with the following template
\begin{verbatim}
 double precision function Rotation_Curve_Gradient_Procedure(thisNode,radius,componentType,massType,haloLoaded)
    type(treeNode),   intent(inout), pointer  :: thisNode
    integer,          intent(in)              :: massType,componentType
    double precision, intent(in)              :: radius
    logical         , intent(in),    optional :: haloLoaded
    .
    .
    .
    return
 end function Rotation_Curve_Gradient_Procedure
\end{verbatim}
If {\normalfont \ttfamily componentType} is a match to the component then the function should return the contribution to the gradient of $V_\mathrm{c}^2(r)$ due to the component matching type {\normalfont \ttfamily massType} within {\normalfont \ttfamily radius} for {\normalfont \ttfamily thisNode}. \emph{Note that this is the gradient of the square of the rotation curve to permit gradients to be directly summed.} {\normalfont \ttfamily componentType} and {\normalfont \ttfamily massType} can take one of the values described in \S\ref{sec:ComponentMassTypes}. If {\normalfont \ttfamily haloLoaded}$=${\normalfont \ttfamily true} (which should be the default if this option is not present), then the effects of baryonic loading on the halo profile should be taken into account where necessary. Otherwise, the effects of baryonic loading should be ignored.

\subsubsection{Galactic Component Potential}

The function {\normalfont \ttfamily Galactic\_Structure\_Potential()} computes the potential at a specified radius in a node. To have their contribution counted, each component must register a task using:
\begin{verbatim}
  !# <potentialTask>
  !#  <unitName>Potential_Task</unitName>
  !# </potentialTask>
\end{verbatim}
where {\normalfont \ttfamily Potential\_Task} is the name of a function with the following template
\begin{verbatim}
 double precision function Potential_Procedure(thisNode,radius,componentType,massType,haloLoaded)
    type(treeNode),   intent(inout), pointer   :: thisNode
    integer,          intent(in),    optional  :: componentType  
    double precision, intent(in)               :: radius
    logical         , intent(in),    optional :: haloLoaded
    .
    .
    return
 end function Potential_Procedure
\end{verbatim}
If {\normalfont \ttfamily componentType} is a match to the component then the procedure should return the contribution to the rotation curve due to the component matching type {\normalfont \ttfamily massType} within {\normalfont \ttfamily radius} for {\normalfont \ttfamily thisNode}. {\normalfont \ttfamily componentType} and {\normalfont \ttfamily massType} can take one of the values described in \S\ref{sec:ComponentMassTypes}. If {\normalfont \ttfamily haloLoaded}$=${\normalfont \ttfamily true} (which should be the default if this option is not present), then the effects of baryonic loading on the halo profile should be taken into account where necessary. Otherwise, the effects of baryonic loading should be ignored.

\subsubsection{Galactic Component Surface Density}

The function {\normalfont \ttfamily Galactic\_Structure\_Surface\_Density()} computes the surface density of material at a given position within a node. Note that while a 3-D position is specified the routine should return the surface density corresponding to integrating the component density through the minor axis (typically the $z$-axis). To have their surface density counted, each component must register a task using:
\begin{verbatim}
 !# <surfaceDensityTask>
 !#  <unitName>Surface_Density_Procedure</unitName>
 !# </surfaceDensityTask>
\end{verbatim}
where {\normalfont \ttfamily Surface\_Density\_Procedure} is the name of a function with the following template
\begin{verbatim}
 double precision function Surface_Density_Procedure(thisNode,position,coordinateSystem,componentType,massType,haloLoaded)
    type(treeNode),   intent(inout), pointer     :: thisNode
    integer,          intent(in)                 :: massType,coordinateSystem,componentType
    double precision, intent(in),    dimension(3):: position
    logical         , intent(in),    optional    :: haloLoaded
    .
    .
    .
    return
 end function Surface_Density_Procedure
\end{verbatim}
If {\normalfont \ttfamily componentType} is a match to the component then the function should return the surface density of the component matching type {\normalfont \ttfamily massType} at {\normalfont \ttfamily position} for {\normalfont \ttfamily thisNode}. {\normalfont \ttfamily componentType} and {\normalfont \ttfamily massType} can take one of the values described in \S\ref{sec:ComponentMassTypes}.
The coordinate system in which {\normalfont \ttfamily position} is specified is given by {\normalfont \ttfamily coordinateSystem} which can take on the following values:
\begin{description}
 \item [{\normalfont \ttfamily coordinateSystemCartesian}] Cartesian $(x,y,z)$;
 \item [{\normalfont \ttfamily coordinateSystemSpherical}] Spherical $(r,\theta,\phi)$;
 \item [{\normalfont \ttfamily coordinateSystemCylindrical}] Cylindrical $(R,\phi,z)$.
\end{description}
If {\normalfont \ttfamily haloLoaded}$=${\normalfont \ttfamily true} (which should be the default if this option is not present), then the effects of baryonic loading on the halo profile should be taken into account where necessary. Otherwise, the effects of baryonic loading should be ignored.

\subsubsection{Halo Formation Events}\label{sec:HaloFormationEvents}

Tasks to be performed when a halo is deemed to have ``formed'' (or reformed) can be registered using the {\normalfont \ttfamily haloFormationTask} directive. For example, the {\normalfont \ttfamily Tree\_Node\_Methods\_Hot\_Halo} module registers a task using
\begin{verbatim}
 !# <haloFormationTask>
 !#  <unitName>Hot_Halo_Formation_Task</unitName>
 !# </haloFormationTask>
\end{verbatim}
The contents of {\normalfont \ttfamily <unitName>} should give the name of the subroutine to be called on halo formation. The subroutine should have a single argument, {\normalfont \ttfamily thisNode}, which is the node that has (re)formed.

\subsubsection{HDF5 File Close}\label{sec:HDFFileClose}

Tasks to be performed just prior to closing the \glc\ output HDF5 file (typically involving writing accumulated data to that file) can be registered using the {\normalfont \ttfamily hdfPreCloseTask} directive. For example, the {\normalfont \ttfamily Merger\_Tree\_Timesteps\_History} module registers a task using
\begin{verbatim}
 !# <hdfPreCloseTask>
 !#  <unitName>Merger_Tree_History_Write</unitName>
 !# </hdfPreCloseTask>
\end{verbatim}
The contents of {\normalfont \ttfamily <unitName>} should give the name of the subroutine to be called prior to HDF5 file closure. The subroutine should have no arguments.

\subsubsection{Merger Tree Extra Output Tasks}

Extra outputs for merger trees (i.e. those which do not involve output of a fixed number of properties for every node---examples might be star formation histories for a subset of galaxies) can be added using the directive: {\normalfont \ttfamily mergerTreeExtraOutputTask}. The directive should give the name of the subroutine to be called to perform the task. A template for this task is:
\begin{verbatim}
  !# <mergerTreeExtraOutputTask>
  !#  <unitName>Galacticus_Extra_Output_Example</unitName>
  !# </mergerTreeExtraOutputTask>
  subroutine Galacticus_Extra_Output_Example(thisNode,iOutput,treeIndex,nodePassesFilter)
    implicit none
    type(treeNode),          intent(inout), pointer :: thisNode
    integer,                 intent(in)             :: iOutput
    integer(kind=kind_int8), intent(in)             :: treeIndex
    logical,                 intent(in)             :: nodePassesFilter
    .
    .
    .
    return
  end subroutine Galacticus_Extra_Output_Example
\end{verbatim}
The subroutine will be called for each node in each merger tree at each output, and should perform whatever extra output related to {\normalfont \ttfamily thisNode}. The index of the output and tree are provided as {\normalfont \ttfamily iOutput} and {\normalfont \ttfamily treeIndex} for reference, and may be used in organizing output. The {\normalfont \ttfamily nodePassesFilter} flag will be set to {\normalfont \ttfamily true} if {\normalfont \ttfamily thisNode} passed all active output filters (see \S\ref{sec:methodsGalacticFilter}). If it is {\normalfont \ttfamily false} then typically no output should occur (although other tasks may still be undertaken).

\subsubsection{Merger Tree Output Tasks}

Additional outputs for merger trees can be added using three directives: {\normalfont \ttfamily mergerTreeOutputPropertyCount}, {\normalfont \ttfamily mergerTreeOutputNames} and {\normalfont \ttfamily mergerTreeOutputTask}. Each directive should give the name of the subroutine to be called to perform the task and, additionally, a name for sorting (this should be the same for all three directives and ensures that output tasks are always called in the correct order). Templates for these tasks are:
\begin{verbatim}
  !# <mergerTreeOutputNames>
  !#  <unitName>Galacticus_Output_Tree_Example_Names</unitName>
  !#  <sortName>Galacticus_Output_Tree_Example</sortName>
  !# </mergerTreeOutputNames>
  subroutine Galacticus_Output_Tree_Example_Names(integerProperty,integerPropertyNames,integerPropertyComments,integerPropertyUnitsSI &
       &,doubleProperty,doublePropertyNames,doublePropertyComments,doublePropertyUnitsSI,time)
    implicit none
    double precision, intent(in)                  :: time
    integer,          intent(inout)               :: integerProperty,doubleProperty
    character(len=*), intent(inout), dimension(:) :: integerPropertyNames,integerPropertyComments,doublePropertyNames &
         &,doublePropertyComments
    double precision, intent(inout), dimension(:) :: integerPropertyUnitsSI,doublePropertyUnitsSI
    .
    .
    .
    return
  end subroutine Galacticus_Output_Tree_Example_Names

  !# <mergerTreeOutputPropertyCount>
  !#  <unitName>Galacticus_Output_Tree_Example_Property_Count</unitName>
  !#  <sortName>Galacticus_Output_Tree_Example</sortName>
  !# </mergerTreeOutputPropertyCount>
  subroutine Galacticus_Output_Tree_Example_Property_Count(integerPropertyCount,doublePropertyCount)
    implicit none
    integer, intent(inout) :: integerPropertyCount,doublePropertyCount
    .
    .
    .
    return
  end subroutine Galacticus_Output_Tree_Example_Property_Count

  !# <mergerTreeOutputTask>
  !#  <unitName>Galacticus_Output_Tree_Example</unitName>
  !#  <sortName>Galacticus_Output_Tree_Example</sortName>
  !# </mergerTreeOutputTask>
  subroutine Galacticus_Output_Tree_Example(thisNode,integerProperty,integerBufferCount,integerBuffer,doubleProperty&
       &,doubleBufferCount,doubleBuffer)
    implicit none
    type(treeNode),          intent(inout), pointer :: thisNode
    integer,                 intent(inout)          :: integerProperty,integerBufferCount,doubleProperty,doubleBufferCount
    integer(kind=kind_int8), intent(inout)          :: integerBuffer(:,:)
    double precision,        intent(inout)          :: doubleBuffer(:,:)
    .
    .
    .
    return
  end subroutine Galacticus_Output_Tree_Example
\end{verbatim}
The {\normalfont \ttfamily mergerTreeOutputPropertyCount} subroutine must simply increment {\normalfont \ttfamily integerPropertyCount} and {\normalfont \ttfamily doublePropertyCount} by the number of integer and double precision properties that will be output respectively. The {\normalfont \ttfamily mergerTreeOutputNames} subroutine must store the dataset names, comments and units in the SI system\footnote{For dimensionless quantities, the units may be set to zero. In such cases, the {\normalfont \ttfamily unitsInSI} attribute for the dataset will not be written to the \protect\glc\ output file.} for each integer and double precision property in the supplied arrays. The value of {\normalfont \ttfamily integerProperty} and {\normalfont \ttfamily doubleProperty} should be incremented by 1 before each property name/comment is set---these then supply the position within the input arrays in which to store the name. The {\normalfont \ttfamily mergerTreeOutputTask} subroutine must similarly place the desired property values for {\normalfont \ttfamily thisNode} into the supplied arrays. The value of {\normalfont \ttfamily integerProperty} and {\normalfont \ttfamily doubleProperty} should be incremented by 1 
before each property value is set. The value can then be stored in, for example, {\normalfont \ttfamily integerBuffer(integerBufferCount,integerProperty)}.

\subsubsection{Merger Tree Pre-Construction Tasks}\label{sec:MergerTreePreConstructionTask}

Additional tasks to be performed prior to the construction of each merger tree can be added using the {\normalfont \ttfamily mergerTreePreTreeConstructionTask} directive. For example, the tree timing task uses this directive as follows:
\begin{verbatim}
  !# <mergerTreePreTreeConstructionTask>
  !#   <unitName>Meta_Tree_Timing_Pre_Construction</unitName>
  !# </mergerTreePreTreeConstructionTask>
\end{verbatim}
Here, {\normalfont \ttfamily Meta\_Tree\_Timing\_Pre\_Construction} is the name of a subroutine which will be called to perform whatever tasks are required. The subroutine must have the following form:
\begin{verbatim}
   subroutine Merger_Tree_PreConstruction_Task()
    implicit none
    .
    .
    .
    return
  end subroutine Merger_Tree_PreConstruction_Task
\end{verbatim}
The subroutine will be called once for each tree, before the tree has been constructed.

\subsubsection{Merger Tree Post-Evolution Tasks}\label{sec:MergerTreePostEvolveTask}

Additional tasks to be performed after the evolution (and subsequent destruction) of each merger tree can be added using the {\normalfont \ttfamily mergerTreePostEvolveTasker} directive. For example, the tree timing task uses this directive as follows:
\begin{verbatim}
  !# <mergerTreePostEvolveTask>
  !#   <unitName>Meta_Tree_Timing_Post_Evolve</unitName>
  !# </mergerTreePostEvolveTask>
\end{verbatim}
Here, {\normalfont \ttfamily Meta\_Tree\_Timing\_Post\_Evolve} is the name of a subroutine which will be called to perform whatever tasks are required. The subroutine must have the following form:
\begin{verbatim}
   subroutine Merger_Tree_PostEvolution_Task()
    implicit none
    .
    .
    .
    return
  end subroutine Merger_Tree_PostEvolution_Task
\end{verbatim}
The subroutine will be called once for each tree, after the tree has been evolved and destroyed.

\subsubsection{Merger Tree Pre-Evolution Tasks}\label{sec:MergerTreePreEvolveTask}

Additional tasks to be performed on merger trees prior to their evolution can be added using the {\normalfont \ttfamily mergerTreePreEvolveTask} directive. For example, the mass accretion history task uses this directive as follows:
\begin{verbatim}
  !# <mergerTreePreEvolveTask>
  !#   <unitName>Merger_Tree_Mass_Accretion_History_Output</unitName>
  !# </mergerTreePreEvolveTask>
\end{verbatim}
Here, {\normalfont \ttfamily Merger\_Tree\_Mass\_Accretion\_History\_Output} is the name of a subroutine which will be called to perform whatever tasks are required. The subroutine must have the following form:
\begin{verbatim}
   subroutine Merger_Tree_PreEvolution_Task(thisTree)
    implicit none
    type(mergerTree), intent(in) :: thisTree
    .
    .
    .
    return
  end subroutine Merger_Tree_PreEvolution_Task
\end{verbatim}
where {\normalfont \ttfamily thisTree} is the tree to be processed. The function will be called once for each tree, prior to the tree being evolved. Note that {\normalfont \ttfamily thisTree} may link to other trees via its {\normalfont \ttfamily nextTree} pointer. The function may want to process each tree in this linked list.

\subsubsection{Merger Tree Initialization Tasks}

Additional tasks to be performed during merger tree initialization can be added using the {\normalfont \ttfamily mergerTreeInitializeTask} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily standard} basic component method uses this directive as follows:
\begin{verbatim}
  !# <satelliteMergerTask>
  !#  <unitName>Halo_Mass_Accretion_Rate</unitName>
  !# </satelliteMergerTask>
\end{verbatim}
Here, {\normalfont \ttfamily Halo\_Mass\_Accretion\_Rate} is the name of a subroutine which will be called to perform whatever tasks are required as a result of the merger. The subroutine must have the following form:
\begin{verbatim}
   subroutine Merger_Tree_Initialize_Task(thisNode)
    implicit none
    type(treeNode), pointer, intent(inout) :: thisNode
    .
    .
    .
    return
  end subroutine Merger_Tree_Initialize_Task
\end{verbatim}
where {\normalfont \ttfamily thisNode} is the node to be initialized. The subroutine will be called once for each node in the tree.

\subsubsection{Merger Tree Structure Output Tasks}

Additional outputs for merger tree structure output can be added using the {\normalfont \ttfamily mergerTreeStructureOutputTask}. The directive should give the name of the subroutine to be called to perform the task. The templates for this tasks is:
\begin{verbatim}
  !# <mergerTreeStructureOutputTask>
  !#  <unitName>Structure_Output_Task</unitName>
  !# </mergerTreeStructureOutputTask>
  subroutine Structure_Output_Task(baseNode,nodeProperty,treeGroup)
    implicit none
    type(treeNode),   intent(in),    pointer      :: baseNode
    double precision, intent(inout), dimension(:) :: nodeProperty
    type(hdf5Object), intent(inout)               :: treeGroup
    .
    .
    .
    return
  end subroutine Structure_Output_Task
\end{verbatim}
The subroutine must walk the merger tree beginning from the given {\normalfont \ttfamily baseNode} and store each property to output in the given {\normalfont \ttfamily nodeProperty} array. Once populated, this array can be written to the appropriate HDF5 group, given by {\normalfont \ttfamily treeGroup}, in the \glc\ output file.

\subsubsection{Node Dump}

The function {\normalfont \ttfamily Node\_Dump(thisNode)} writes out all properties of a node to the display. To have their properties listed, each component must register a task using:
\begin{verbatim}
 !# <nodeDumpTask>
 !#  <unitName>Node_Dump_Procedure</unitName>
 !# </nodeDumpTask>
\end{verbatim}
where {\normalfont \ttfamily Node\_Dump\_Procedure} is the name of a subroutine with the following template
\begin{verbatim}
 subroutine Node_Dump_Procedure(thisNode)
    type(treeNode),   intent(inout), pointer :: thisNode
    .
    .
    .
    return
 end subroutine Node_Dump_Procedure
\end{verbatim}
If the node contains an active component, this subroutine should display all relevant properties of the component. If not, it can display a short message indicating that fact.

\subsubsection{Output Group Output Tasks}\index{output groups}\index{tasks!output}

Extra outputs for output groups (i.e. the groups which hold all merger tree data for a given output time) can be added using the directive: {\normalfont \ttfamily outputGroupOutputTask}. The directive should give the name of the subroutine to be called to perform the task. A template for this task is:
\begin{verbatim}
  !# <outputGroupOutputTask>
  !#  <unitName>Galacticus_Output_Group_Output_Example</unitName>
  !# </outputGroupOutputTask>
  subroutine Galacticus_Output_Group_Output_Example(outputGroup,time)
    implicit none
    type(hdf5Object), intent(inout) :: outputGroup
    double precision, intent(in)    :: time
    .
    .
    .
    return
  end subroutine Galacticus_Output_Group_Output_Example
\end{verbatim}
The subroutine will be called for each output group created, and should perform whatever extra output it requires. The {\normalfont \ttfamily outputGroup} object and the corresponding output {\normalfont \ttfamily time} are provided as input parameters.


\subsubsection{Post-evolve Tasks}\index{post-evolve task}\index{task, post-evolve}

Additional methods for post-evolve tasks (i.e. things that should be done after each node is evolved differentially to the next output time, interrupt, or event) can be added using the {\normalfont \ttfamily postEvolveTask} directive. The directive should contain a single argument, giving the name of a subroutine to be called to perform the task. For example, the standard hot halo component adds a task as follows:
\begin{verbatim}
  !# <postEvolveTask>
  !#  <unitName>Tree_Node_Hot_Halo_Postevolve_Standard</unitName>
  !# </postEvolveTask>
\end{verbatim}
Here, {\normalfont \ttfamily Tree\_Node\_Hot\_Halo\_Postevolve\_Standard} is the name of a subroutine which will be called to perform whatever tasks are required. The subroutine must have the following form:
\begin{verbatim}
   subroutine Post_Evolve_Task(node)
    implicit none
    type(treeNode), intent(inout) :: node
    .
    .
    .
    return
  end subroutine Post_Evolve_Task
\end{verbatim}
where {\normalfont \ttfamily node} is the node for which tasks will be performed. Tasks typically involve cleaning up after differential evolution.

\subsubsection{Post-step Tasks}\index{post-step task}\index{task, post-step}

Additional methods for post-step tasks (i.e. things that should be done after each ODE solver step when evoling a node differentially) can be added using the {\normalfont \ttfamily postStepTask} directive. The directive should contain a single argument, giving the name of a subroutine to be called to perform the task. For example, the standard hot halo component adds a task as follows:
\begin{verbatim}
  !# <postStepTask>
  !#  <unitName>Tree_Node_Hot_Halo_Poststep_Standard</unitName>
  !# </postStepTask>
\end{verbatim}
Here, {\normalfont \ttfamily Tree\_Node\_Hot\_Halo\_Poststep\_Standard} is the name of a subroutine which will be called to perform whatever tasks are required. The subroutine must have the following form:
\begin{verbatim}
   subroutine Post_Step_Task(node,status)
    implicit none
    type   (treeNode), intent(inout) :: node
    integer          , intent(inout) :: status
    .
    .
    .
    return
  end subroutine Post_Step_Task
\end{verbatim}
where {\normalfont \ttfamily node} is the node for which tasks should be performed. If any change is made to the state of the node then {\normalfont \ttfamily status} should be set equal to {\normalfont \ttfamily FGSL\_Failure}. Tasks typically involve cleaning up after differential evolution.

\subsubsection{Pre-derivative Tasks}\index{pre-derivative task}\index{task, pre-derivative}

Additional methods for pre-derivative tasks (i.e. things that should be done just prior to the computation of derivatives or properties for a node) can be added using the {\normalfont \ttfamily preDerivativeTask} directive. The directive should contain a single argument, giving the name of a subroutine to be called to perform the task. For example, the standard hot halo component adds a task as follows:
\begin{verbatim}
  !# <preDerivativeTask>
  !#  <unitName>Tree_Node_Hot_Halo_Prederivative_Standard</unitName>
  !# </preDerivativeTask>
\end{verbatim}
Here, {\normalfont \ttfamily Tree\_Node\_Hot\_Halo\_Prederivative\_Standard} is the name of a subroutine which will be called to perform whatever tasks are required. The subroutine must have the following form:
\begin{verbatim}
   subroutine Prederivative_Task(thisNode)
    implicit none
    type(treeNode), pointer, intent(inout) :: thisNode
    .
    .
    .
    return
  end subroutine Prederivative_Task
\end{verbatim}
where {\normalfont \ttfamily thisNode} is the node for which derivatives will be computed. Tasks typically involve precomputing quantities that will be used in finding the derivatives.

\subsubsection{Radius Solver Tasks}\label{sec:radius_solver}

Galactic radii solver functions (see \S\ref{sec:methodsGalacticStructureSolver}) need to be able to interact with the components of a tree node to
\begin{enumerate}
 \item Determine which components want a radius to be solved for;
 \item Get and set the properties of those components.
\end{enumerate}
The  {\normalfont \ttfamily radiusSolverPlausibility} and {\normalfont \ttfamily radiusSolverTask} directives facilitate this. A component which has a radius to be solved for should include directives of the form:
\begin{verbatim}
 !# <radiusSolverTask>
 !#  <unitName>Component_Radius_Solver_Plausibility</unitName>
 !# </radiusSolverTask>
\end{verbatim}
and
\begin{verbatim}
 !# <radiusSolverTask>
 !#  <unitName>Component_Radius_Solver</unitName>
 !# </radiusSolverTask>
\end{verbatim}
where {\normalfont \ttfamily Component\_Radius\_Solver\_Plausibility} is the name of a subroutine which will specify whether or not the component is physically plausible for radius solving (e.g. has non-negative mass) and should have the following form:
\begin{verbatim}
 subroutine Component_Radius_Solver_Plausibility(thisNode,galaxyIsPhysicallyPlausible)
    implicit none
    type(treeNode), pointer, intent(inout) :: thisNode
    logical,                 intent(inout) :: galaxyIsPhysicallyPlausible
    .
    .
    .
    return
 end subroutine Component_Radius_Solver_Plausibility
\end{verbatim}
which should set {\normalfont \ttfamily galaxyIsPhysicallyPlausible} to false if the component is not physically plausible, but should otherwise leave {\normalfont \ttfamily galaxyIsPhysicallyPlausible} unchanged. Additionally, {\normalfont \ttfamily Component\_Radius\_Solver} is the name of a subroutine which will supply the necessary information about the node, and which should have the following form:
\begin{verbatim}
 subroutine Component_Radius_Solver(thisNode,componentActive,specificAngularMomentum,Radius_Get,Radius_Set,Velocity_Get,Velocity_Set)
    implicit none
    type(treeNode),   pointer, intent(inout) :: thisNode
    logical,                   intent(out)   :: componentActive
    double precision,          intent(out)   :: specificAngularMomentum
    procedure(),      pointer, intent(out)   :: Radius_Get,Velocity_Get
    procedure(),      pointer, intent(out)   :: Radius_Set,Velocity_Set
    .
    .
    .
    return
 end subroutine Component_Radius_Solver
\end{verbatim}
When called, the subroutine should set {\normalfont \ttfamily componentActive} to indicate whether or not this nod contains an active component of the type. If it does, it should also set {\normalfont \ttfamily specificAngularMomentum} to reflect the specific angular momentum (in km s$^{-1}$ Mpc) of the component (at whatever point in its profile the radius is required) and should point the four procedure pointers to routines which get and set the radius and circular velocity properties of the component (which should have the standard form for component get and set methods). It is acceptable for the set procedures to point to dummy routines.

The galactic structure radii solver routines will use this information to determine (and set) the radius and circular velocity of the component. An advantage of this approach is that different radii solver methods can all use this same system, ensuring that just a single interface is needed in each component.

\subsubsection{Satellite Host Change Tasks}

Additional methods for satellite host change events (i.e. when a satellite node moves to a new host) can be added using the {\normalfont \ttfamily satelliteHostChangeTask} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily simple} satellite orbits components uses this directive as follows:
\begin{verbatim}
  !# <satelliteHostChangeTask>
  !#  <unitName>Satellite_Orbit_New_Host</unitName>
  !# </satelliteHostChangeTask>
\end{verbatim}
Here, {\normalfont \ttfamily Satellite\_Orbit\_New\_Host} is the name of a subroutine which will be called to perform whatever tasks are required as a result of the host change. The subroutine must have the following form:
\begin{verbatim}
   subroutine New_Host_Task(thisNode)
    implicit none
    type(treeNode), pointer, intent(inout) :: thisNode
    .
    .
    .
    return
  end subroutine New_Host_Task
\end{verbatim}
where {\normalfont \ttfamily thisNode} is the node which has changed host (the new host halo is {\normalfont \ttfamily thisNode\%parentNode}).

\subsubsection{Satellite Merger Tasks}

Additional methods for satellite merger tasks can be added using the {\normalfont \ttfamily satelliteMergerTask} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily simple} satellite orbits components uses this directive as follows:
\begin{verbatim}
  !# <satelliteMergerTask>
  !#  <unitName>Satellite_Merger_Task</unitName>
  !# </satelliteMergerTask>
\end{verbatim}
Here, {\normalfont \ttfamily Satellite\_Merger\_Task} is the name of a subroutine which will be called to perform whatever tasks are required as a result of the merger. The subroutine must have the following form:
\begin{verbatim}
   subroutine Satellite_Merger_Task(thisNode)
    implicit none
    type(treeNode), pointer, intent(inout) :: thisNode
    .
    .
    .
    return
  end subroutine Satellite_Merger_Task
\end{verbatim}
where {\normalfont \ttfamily thisNode} is the node about to merge with {\normalfont \ttfamily thisNode\%parentNode}.

\subsubsection{Star Formation History Tasks}\index{star formation history}\label{sec:StarFormationHistoryTasks}

Additional methods for star formation history tracking  can be added using the {\normalfont \ttfamily starFormationHistoriesMethod} directive. The directive should contain a single argument, giving the name of a subroutine to be called to initialize the method. For example, the {\normalfont \ttfamily metallicitySplit} method uses this directive as follows:
\begin{verbatim}
  !# <starFormationHistoriesMethod>
  !#  <unitName>Star_Formation_Histories_Metallicity_Split_Initialize</unitName>
  !# </starFormationHistoriesMethod>
\end{verbatim}
Here, {\normalfont \ttfamily Star\_Formation\_Histories\_Metallicity\_Split\_Initialize} is the name of a subroutine which will be called to initialize the method. The subroutine must have the following form:
\begin{verbatim}
  subroutine Method_Initialize( starFormationHistoriesMethod     &
       &                       ,Star_Formation_History_Create_Do &
       &                       ,Star_Formation_History_Scales_Do &
       &                       ,Star_Formation_History_Record_Do &
       &                       ,Star_Formation_History_Output_Do &
       &                      )
    implicit none
    type(varying_string),          intent(in)    ::  starFormationHistoriesMethod
    procedure(),          pointer, intent(inout) ::  Star_Formation_History_Create_Do &
       &                                            ,Star_Formation_History_Scales_Do &
       &                                            ,Star_Formation_History_Record_Do &
       &                                            ,Star_Formation_History_Output_Do
    
    if (starFormationHistoriesMethod == 'myMethod') then
       Star_Formation_History_Create_Do => My_Create
       Star_Formation_History_Scales_Do => My_Scales
       Star_Formation_History_Record_Do => My_Record
       Star_Formation_History_Output_Do => My_Output
    end if
    return
  end subroutine Method_Initialize
\end{verbatim}
where {\normalfont \ttfamily myMethod} is the name of this method as will be specified by the {\normalfont \ttfamily starFormationHistoriesMethod} input parameter. The procedure pointers must be set to point to subroutines which perform the functions described below. The initialization subroutine should perform any other tasks required to initialize the module (such as reading parameters etc.).

The {\normalfont \ttfamily Star\_Formation\_History\_Create\_Do} subroutine must have the form:
\begin{verbatim}
  subroutine My_Create(thisNode,thisHistory)
    implicit none
    type(treeNode), intent(inout), pointer :: thisNode
    type(history),   ntent(inout)          :: thisHistory
    return
  end subroutine My_Create
\end{verbatim}
and should return a history object in {\normalfont \ttfamily thisHistory} suitable for holding a star formation history for {\normalfont \ttfamily thisNode}.

The {\normalfont \ttfamily Star\_Formation\_History\_Scales\_Do} subroutine must have the form:
\begin{verbatim}
  subroutine My_Scales(thisHistory,stellarMass,stellarAbundances)
    implicit none
    double precision,          intent(in)    :: stellarMass
    type(abundancesStructure), intent(in)    :: stellarAbundances
    type(history),             intent(inout) :: thisHistory
    return
  end subroutine My_Scales
\end{verbatim}
and should set the ODE solver error tolerance scales in {\normalfont \ttfamily thisHistory}, using the provided information on {\normalfont \ttfamily stellarMass} and {\normalfont \ttfamily stellarAbundances} if required.

The {\normalfont \ttfamily Star\_Formation\_History\_Record\_Do}\index{star formation history!recording} subroutine must have the form:
\begin{verbatim}
  subroutine My_Record(thisNode,thisHistory,fuelAbundances,starFormationRate)
    implicit none
    type(treeNode),            intent(inout), pointer :: thisNode
    type(history),             intent(inout)          :: thisHistory
    type(abundancesStructure), intent(in)             :: fuelAbundances
    double precision,          intent(in)             :: starFormationRate
    return
  end subroutine My_Record
\end{verbatim}
and should record the contribution to the star formation history in {\normalfont \ttfamily thisHistory} for {\normalfont \ttfamily thisNode} given the current {\normalfont \ttfamily starFormationRate} and star formation {\normalfont \ttfamily fuelAbundances}. That is, the subroutine should adjust the rates in {\normalfont \ttfamily thisHistory} appropriately.

The {\normalfont \ttfamily Star\_Formation\_History\_Output\_Do}\index{star formation history!outputting} subroutine must have the form:
\begin{verbatim}
  subroutine My_Output(thisNode,thisHistory,iOutput,treeIndex,componentLabel)
    implicit none
    type(treeNode),          intent(inout), pointer :: thisNode
    type(history),           intent(inout)          :: thisHistory
    integer,                 intent(in)             :: iOutput
    integer(kind=kind_int8), intent(in)             :: treeIndex
    character(len=*),        intent(in)             :: componentLabel
    return
  end subroutine My_Output
\end{verbatim}
and should write the star formation history, {\normalfont \ttfamily thisHistory}, for {\normalfont \ttfamily thisNode} to the output file. The output number and tree index are provided as {\normalfont \ttfamily iOutput} and {\normalfont \ttfamily treeIndex} for reference, and {\normalfont \ttfamily componentLabel} provides a suitable label for the component to which the history belongs (and so should be used in the name of the datasets to which the history is written for example).

Conventionally, star formation histories are output as follows:
\begin{verbatim}
HDF5 "galacticus.hdf5" {
GROUP "starFormationHistories" {
   COMMENT "Star formation history data."
   GROUP "Output1" {
      COMMENT "Star formation histories for all trees at each out"
      GROUP "mergerTree1" {
         COMMENT "Star formation histories for each tree."
         DATASET "diskSFH<nodeID>" {
         COMMENT "Star formation history stellar masses of the disk "
            DATATYPE  H5T_IEEE_F64LE
            DATASPACE  SIMPLE { }
         }
         DATASET "diskTime<nodeID>" {
         COMMENT "Star formation history times of the disk component"
            DATATYPE  H5T_IEEE_F64LE
            DATASPACE  SIMPLE { }
         }
         DATASET "spheroidSFH<nodeID>" {
         COMMENT "Star formation history stellar masses of the spher"
            DATATYPE  H5T_IEEE_F64LE
            DATASPACE  SIMPLE { }
         }
         DATASET "spheroidTime<nodeID>" {
         COMMENT "Star formation history times of the spheroid compo"
            DATATYPE  H5T_IEEE_F64LE
            DATASPACE  SIMPLE { }
         }
      }
      GROUP "mergerTree2" {
      .
      .
      .
      }
   }
   GROUP "Output1" {
   .
   .
   .
   }
}
}
\end{verbatim}
where {\normalfont \ttfamily nodeID} is the index of the relevant node. The specifics of each dataset will depend on the selected star formation history method.

Currently defined star formation history methods are:
\begin{description}
 \item [\hyperlink{galacticus.output.merger_tree.star_formation.metallicity_split.F90:star_formation_histories_metallicity_split}{{\normalfont \ttfamily metallicitySplit}}] The star formation history is tabulated on a grid of time and metallicity. The binning in time is chosen such that bins are at most of size {\normalfont \ttfamily [starFormationHistoryTimeStep]} between the time at which each galaxy formed and the final output time, and at most of size {\normalfont \ttfamily [starFormationHistoryFineTimeStep]} in the period {\normalfont \ttfamily [starFormationHistoryFineTime]} prior to each output time (all times specified in Gyr). The allows fine binning of recent star formation just prior to each output. Usually, the metallicity binning is arranged logarithmically in metallicity with {\normalfont \ttfamily [starFormationHistoryMetallicityCount]} bins between {\normalfont \ttfamily [starFormationHistoryMetallicityMinimum]} and {\normalfont \ttfamily [starFormationHistoryMetallicityMaximum]} (specified in Solar units). Note that the metallicity associated with each bin is the minimum metallicity for that bin (the maximum being the metallicity value associated with the next bin, except for the final bin which extends to infinite metallicity). If {\normalfont \ttfamily [starFormationHistoryMetallicityCount]}$=0$ is set, then the star formation history is not split by metallicity (i.e. a single metallicity bin encompassing all metallicities from zero to infinity is used). Alternatively, specific metallicity bin boundaries can be set via the {\normalfont \ttfamily [starFormationHistoryMetallicityBoundaries]} parameter---a final boundary corresponding to infinity is always added automatically. Output follows the conventional format, with 2D star formation history datasets to represent the history as a function of time and metallicity. An additional {\normalfont \ttfamily metallicities} dataset is added to the {\normalfont \ttfamily starFormationHistories} output group to record the metallicity binning as follows:
\begin{verbatim}
DATASET "metallicities" {
 COMMENT "Metallicities at which star formation histories are tabulated"
   DATATYPE  H5T_IEEE_F64LE
   DATASPACE  SIMPLE { ( [starFormationHistoryMetallicityCount] ) / ( [starFormationHistoryMetallicityCount] ) }
}
\end{verbatim}
 \item [\hyperlink{galacticus.output.merger_tree.star_formation.in_situ.F90:star_formation_histories_in_situ}{{\normalfont \ttfamily inSitu}}] The star formation history is tabulated on a grid of time and is split between in-situ and accreted star formation. The time grid is the same as (and controlled by the same parameters) are for the {\normalfont \ttfamily metallicitySplit} method. Output follows the conventional format, with 2D star formation history datasets to represent the history as a function of time and origin. The first element in the origin dimension records in-situ star formation, while the second element records total star formation.
\end{description}

\section{Subsystems}

This section describes some of the subsystems within \glc\ that support various physical entities or processes.

\subsection{Kepler Orbits}\label{sec:KeplerOrbits}

The {\normalfont \ttfamily keplerOrbit} object (provided by the \href{objects.kepler_orbits.F90:kepler_orbits_structure}{{\normalfont \ttfamily Kepler\_Orbits\_Structure}} module) stores the parameters of a single Keplerian orbit. It internally handles computation of additional/alternate orbital parameters once an orbit has been fully defined. Currently, the orientation of orbits (i.e. the unit vector normal to the orbital plane and the argument of periapsis) is not tracked. As such, orbits are fully defined by three parameters (in addition to the masses of the orbitting bodies). The following limitations presently apply to the {\normalfont \ttfamily keplerOrbit} object:
\begin{itemize}
 \item If an orbit is overdefined (i.e. if more than three parameters are set manually) no checking is performed to ensure that the parameters are consistent with a Keplerian orbit;
 \item Not all interconversions between parameters are supported\footnote{The {\normalfont \ttfamily keplerOrbit} object works by trying to convert to the combination radius, radial and tengential velocities. Once these are defined, all other parameters can be computed. However, for orbits defined in terms of other parameters, the {\normalfont \ttfamily keplerOrbit} object does not know how to convert from every such combination of parameters.}. If a conversion cannot be performed, an error message will be given. 
\end{itemize}
A {\normalfont \ttfamily keplerOrbit} object can be reset by calling the {\normalfont \ttfamily reset()} method, and its defined/undefined status can be tested with the {\normalfont \ttfamily isDefined()} method or asserted with the {\normalfont \ttfamily assertIsDefined()} method. The following orbital parameters are supported, each method returning the value of the parameter and a corresponding method suffixed with {\normalfont \ttfamily Set} can be used to set the parameter: {\normalfont \ttfamily radius}, {\normalfont \ttfamily velocityRadial}, {\normalfont \ttfamily velocityTengentail}, {\normalfont \ttfamily energy}, {\normalfont \ttfamily angularMomentum}, {\normalfont \ttfamily eccentricity}, {\normalfont \ttfamily semiMajorAxis}, {\normalfont \ttfamily radiusPericenter}, {\normalfont \ttfamily radiusApocenter}. Additionally, the masses of the orbitting bodies are provided by the {\normalfont \ttfamily hostMass()} and {\normalfont \ttfamily reducedMassSpecific()}$=M_\mathrm{host}/(M_\mathrm{host}+M_\mathrm{satellite})$ methods. Finally, the {\normalfont \ttfamily velocityScale()} method returns $\mathrm{G}M_\mathrm{host}/r$ where $r$ is the radius of the orbit.

\subsection{Chemicals}\label{sec:ChemicalSubsystem}

The chemicals subsystem provides both a interface to a database of known chemicals (allowing their physical properties to be queried) and a structure to store abundances/masses/etc. of the set of chemicals being tracked in \glc. The name ``chemicals'' is used to denote any chemical species that might be involved in reactions, including molecules, atoms, atomic and molecular ions and electrons.

\subsubsection{Chemical Database}

The file {\normalfont \ttfamily data/Chemical\_Database.cml} contains a database of chemicals that can currently be used by \glc. It uses a simplified version of the \href{http://www.xml-cml.org}{Chemical Markup Language} to describe chemicals. An excerpt from the database is shown below:
\begin{verbatim}
 <list>
  <chemical>
   <id>MolecularHydrogenAnion</id>
   <formalCharge>-1</formalCharge>
   <atomArray>
     <atom>
      <id>1</id>
      <elementType>H</elementType>
     </atom>
     <atom>
      <id>2</id>
      <elementType>H</elementType>
     </atom>
   </atomArray>
   <bondArray>
     <bond>
      <atomRefs2>1 2</atomRefs2>
      <order>1</order>
     </bond>
   </bondArray>
  </chemical>
  .
  .
  .
 </list>
\end{verbatim}
The database contains a {\normalfont \ttfamily list} of chemicals, each contained within a {\normalfont \ttfamily chemical} element. The {\normalfont \ttfamily id} element provides a label for the chemical (usually a descriptive name with no white space). The {\normalfont \ttfamily formalCharge} element gives the charge of the chemical in units of the elementary charge. The chemical is then describe by a list of atoms and bonds inside {\normalfont \ttfamily atomArray} and {\normalfont \ttfamily bondArray} elements respectively. The {\normalfont \ttfamily atomArray} can contain any number of {\normalfont \ttfamily atom} elements, which should describe each atom in the chemical giving it a unique {\normalfont \ttfamily id} number and an {\normalfont \ttfamily elementType}, which is the short one or two letter label for the element (e.g. H, Ni, etc.). The {\normalfont \ttfamily bondArray} should contain a {\normalfont \ttfamily bond} entry for each atomic bond, which itself contains a {\normalfont \ttfamily atomRefs2} element giving the IDs of the two atoms participating in the bond and an {\normalfont \ttfamily order} element which gives the order of the bond (e.g. ``1'' for a single bond).

\subsubsection{Chemical Structure}

Within \glc\ a chemical is represeted using the {\normalfont \ttfamily chemicalStructure} type which is provided by the {\normalfont \ttfamily Chemical\_Structures} module. A {\normalfont \ttfamily chemicalStructure} object can be assigned a particular chemical by retrieving that chemical from the database using:
\begin{verbatim}
 call myChemical%retrieve("chemicalID")
\end{verbatim}
where {\normalfont \ttfamily chemicalID} is the ID of the chemical in the databse. Any chemical can be exported to a CML file using
\begin{verbatim}
 call myChemical%export(fileName)
\end{verbatim}
where {\normalfont \ttfamily fileName} gives the name of the file to which to export.

Once assigned a chemical, basic properties such as mass and charge (in atomic units) can be accessed using {\normalfont \ttfamily myChemical\%mass} and {\normalfont \ttfamily myChemical\%charge} respectively. The mass is computed from the known atomic masses of the constituent atoms of the chemical.

\subsubsection{Chemical Abundances}

Within \glc\ a set of abundances (or masses, or densities\ldots) for all chemicals being tracked, as specified by the {\normalfont \ttfamily [chemicalsToTrack]} input parameter, is stored within a {\normalfont \ttfamily chemicalAbundancesStructure} type, as provided by the {\normalfont \ttfamily Chemical\_Abundances\_Structure} module. The structure provides interfaces for setting and retrieving the abundance of a given chemical species, to pack/unpack all chemicals to/from an array, to convert from mass-weighted to number-weigted quantities and to multiplty and divide the chemicals abundances by a given amount. Additionally, the {\normalfont \ttfamily Chemical\_Abundances\_Structure} module provides functions which provide a count of the number of chemicals tracked, to look up the index of a chemical array represetation from its name, and to retrieve the name of a given chemical.

\subsection{Radiation}\label{sec:RadiationSubsystem}

This subsystem handles radiation fields, providing convenient means to communicate radiation fields from one part of the \glc\ code to another. A radiation object can hold multiple different types of radiation field (e.g. it could contain both the cosmic microwave background and an interstellar radiation field localized to a specific galaxy).

\subsubsection{Radiation Structure}

Within \glc\ radiation fields are represented by the {\normalfont \ttfamily radiationStructure} type which is provided by the {\normalfont \ttfamily Radiation\_Structures} module. A {\normalfont \ttfamily radiationStructure} object must first be defined using:
\begin{verbatim}
 call myRadiation%define([radiationType1,radiationType2])
\end{verbatim}
where the list of {\normalfont \ttfamily radiationType}s specifies what radiation components will be present in this radiation object. Currently defined radiation types are:
\begin{description}
 \item[{\normalfont \ttfamily CMB}] The cosmic microwave background;
 \item[{\normalfont \ttfamily Null}] A null (zero radiation) component.
\end{description}
For example,
\begin{verbatim}
 call myRadiation%define([radiationTypeCMB])
\end{verbatim}
will define the {\normalfont \ttfamily myRadiation} object to contain just the cosmic microwave background.

Once defined, the specific radiation field can be set using:
\begin{verbatim}
 call myRadiation%set(thisNode)
\end{verbatim}
This will cause all components to set their radiation fields using (if necessary) the properties of {\normalfont \ttfamily thisNode}. Radiation objects can be queried using the following methods:
\begin{description}
 \item[{\normalfont \ttfamily temperature(radiationTypes)}] Returns the temperature (in Kelvin) of the radiation object. The optional {\normalfont \ttfamily radiationTypes} array specifies which radiation types are to be queried.
 \item[{\normalfont \ttfamily flux(wavelength,radiationTypes)}] Returns the flux (in ergs cm$^2$ s$^{-1}$ Hz$^{-1}$ ster$^{-1}$) of the radiation object at the given {\normalfont \ttfamily wavelength} (specified in units of \AA). The optional {\normalfont \ttfamily radiationTypes} array specifies which radiation types are to be queried.
\end{description}

\subsection{Coordinates}\label{sec:Coordinates}

The {\normalfont \ttfamily coordinate} class, provided by the \hyperlink{objects.coordinates.F90:coordinates}{\normalfont \ttfamily Coordinates} module provides an object describing a position in three-dimensional space. Each extension of this class (currently, {\normalfont \ttfamily coordinateCartesian}, {\normalfont \ttfamily coordinateCylindrical}, and {\normalfont \ttfamily coordinateSpherical}) supply methods to convert to and from Cartesian coordinates. The assignment operator ({\normalfont \ttfamily =}) is overloaded such that coordinate objects of any class can be assigned to any other class and conversion to the appropriate coordinate system will happen automatically. A function accepting a {\normalfont \ttfamily class(coordinate)} object can therefore convert it to, for example, spherical coordinates simply using
\begin{verbatim}
 class(coordinate         ), intent(in) :: coordinates
 type (coordinateSpherical)             :: coordinatesSpherical
 coordinatesSpherical=coordinates
\end{verbatim}
and thereby allow a position to be passed to it in any coordinate system.

Each extension of the base class also provides methods to get and set the values of each component of the relevant coordinate system (see \S\ref{sec:AutoMethodsCoordinate} for complete details).
